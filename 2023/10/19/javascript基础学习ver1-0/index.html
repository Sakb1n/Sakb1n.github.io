<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>javaScript基础学习ver1.2 | Bin&#39;s blog</title><meta name="author" content="Binbin"><meta name="description" content="小彬彬的博客"><meta name="keywords" content="hexo,node,blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><link rel="icon" href="/images/pic.jpg"><script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css"><link rel="stylesheet" href="/css/fonts.min.css"><script>const mixins={}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script><script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"><script src="/js/lib/highlight.js"></script><script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script><script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css"><script src="/js/lib/math.js"></script><script src="/js/lib/preview.js"></script><script src="https://cdn.staticfile.org/gitalk/1.8.0/gitalk.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.8.0/gitalk.min.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Bin's blog" type="application/atom+xml"></head><body><div id="background"></div><div id="layout"><transition name="fade"><div id="loading" v-show="loading"><div id="loading-circle"><h2>LOADING</h2><p>加载过慢请开启缓存 浏览器默认开启</p><img src="/images/loading.gif"></div></div></transition><div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}"><nav id="desktop-menu"><a class="title" href="/"><span>BIN&#39;S BLOG</span> </a><a href="/"><i class="fa-solid fa-house fa-fw"></i> <span>&ensp;Home</span> </a><a href="/about"><i class="fa-solid fa-id-card fa-fw"></i> <span>&ensp;About</span> </a><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> <span>&ensp;Archives</span> </a><a href="/categories"><i class="fa-solid fa-bookmark fa-fw"></i> <span>&ensp;Categories</span> </a><a href="/tags"><i class="fa-solid fa-tags fa-fw"></i> <span>&ensp;Tags</span></a></nav><nav id="mobile-menu"><div class="title" @click="showMenuItems = !showMenuItems"><i class="fa-solid fa-bars fa-fw"></i> <span>&emsp;BIN&#39;S BLOG</span></div><transition name="slide"><div class="items" v-show="showMenuItems"><a href="/"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-house fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Home</div></div></a><a href="/about"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-id-card fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">About</div></div></a><a href="/archives"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-box-archive fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Archives</div></div></a><a href="/categories"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-bookmark fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Categories</div></div></a><a href="/tags"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-tags fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Tags</div></div></a></div></transition></nav></div><transition name="fade"><div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div></transition><div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'"><div class="article"><div><h1>javaScript基础学习ver1.2</h1></div><div class="info"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2023/10/19 </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0/"><span class="icon"><i class="fa-solid fa-bookmark fa-fw"></i> </span>学习 </a></span><span class="tags"><span class="icon"><i class="fa-solid fa-tags fa-fw"></i> </span><span class="tag"><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="color:#00bcd4">学习</a></span></span></div><div class="content" v-pre><p>2023.10.22: 更新了js对象内容(ver1.2)<br>2023.10.21: 优化了排版，更新至ver1.1<br>2023.10.19：更新js ver1.0</p><hr><h1 id="JavaScript学习（MDN）"><a href="#JavaScript学习（MDN）" class="headerlink" title="JavaScript学习（MDN）"></a>JavaScript学习（MDN）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。</p><span id="more"></span><h2 id="JavaScript第一步"><a href="#JavaScript第一步" class="headerlink" title="JavaScript第一步"></a>JavaScript第一步</h2><h3 id="什么是javaScript？"><a href="#什么是javaScript？" class="headerlink" title="什么是javaScript？"></a>什么是javaScript？</h3><h4 id="js简要"><a href="#js简要" class="headerlink" title="js简要"></a>js简要</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javascript是<strong>轻量级解释型</strong>语言，使用<strong>即时编译</strong>：会编译为二进制的格式。</p><h4 id="js使用"><a href="#js使用" class="headerlink" title="js使用"></a>js使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用内部js(在<code>&lt;/head&gt;</code>标签结束前插入<code>&lt;script&gt;</code>元素)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者直接外联（推荐):	<code>&lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt;</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不建议</strong>内联（太乱了）</p><h4 id="案例：使用addEventListener"><a href="#案例：使用addEventListener" class="headerlink" title="案例：使用addEventListener"></a>案例：使用addEventListener</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用querySelectorAll()函数选择按钮，使用addEventListener()为每个按钮分配一个处理器。</p><pre><code class="js">const buttons = document.querySelectorAll(&quot;button&quot;);
for (let i = 0; i &lt; buttons.length; i++) &#123;
  buttons[i].addEventListener(&quot;click&quot;, createParagraph);
&#125;
</code></pre><h4 id="脚本调用策略"><a href="#脚本调用策略" class="headerlink" title="脚本调用策略"></a>脚本调用策略</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML是按其出现在页面中的次序调用的，若js加载在欲操作的元素之前会发生错误。</p><p>1.内部：</p><pre><code class="js">document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123;
  // …
&#125;);
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：这个事件监听器能监听浏览器的<code>DOMContentLoaded</code>事件，标志着HTML文档体完全加载和解析，而在该代码需在事件触发后才进行，从而避免了错误。</p><p>2.外部：</p><pre><code class="html">&lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>&lt;script&gt;</code>最后加入defer解决问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：defer告知浏览器在遇到<code>&lt;script&gt;</code>元素时继续下载HTML内容。</p><h4 id="async-和-defer-的区别"><a href="#async-和-defer-的区别" class="headerlink" title="async 和 defer 的区别"></a>async 和 defer 的区别</h4><ul><li>使用<code>async</code> 脚本时不会阻塞页面渲染，而是直接下载然后运行。但是，一旦下载完成，脚本就会执行，从而阻止页面渲染。脚本的运行次序无法控制。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，<code>async</code> 是最理想的选择。</li><li>使用 <code>defer</code> 属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完毕之前，脚本不会运行，如果脚本依赖于 DOM 的存在（例如，脚本修改了页面上的一个或多个元素），这一点非常有用。</li></ul><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript/async-defer.jpg"></p><p>例:</p><pre><code class="html">&lt;script async src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script async src=&quot;js/script2.js&quot;&gt;&lt;/script&gt;
&lt;script async src=&quot;js/script3.js&quot;&gt;&lt;/script&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三者的调用顺序是不确定的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>async</code> 应该在有大量后台脚本需要加载，并且只想尽快加载到位的情况下使用</strong></p><pre><code class="html">&lt;script defer src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script defer src=&quot;js/script2.js&quot;&gt;&lt;/script&gt;
&lt;script defer src=&quot;js/script3.js&quot;&gt;&lt;/script&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>这将会按顺序以此加载。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li><pre><code class="js">// 注释
</code></pre></li><li><pre><code class="js">/*
  注释
*/
</code></pre></li></ul><h3 id="javaScript初体验"><a href="#javaScript初体验" class="headerlink" title="javaScript初体验"></a>javaScript初体验</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉没什么要写的，很多都是在java中学过的了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章更多是在讲第一个程序，贴个链接：[JavaScript 初体验](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/A_first_splash">JavaScript 初体验 - 学习 Web 开发 | MDN (mozilla.org)</a>)</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;侦听事件的结构称为事件监听器(Event Listener）, 响应事件触发而运行的代码块称为事件处理器(Event Handler)。</p><h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for of循环"></a>for of循环</h4><pre><code class="js">const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;];
for (const fruit of fruits) &#123;
  console.log(fruit);
&#125;
</code></pre><p>结果：</p><pre><code class="js">&#39;apples&#39;,&#39;bananas&#39;,&#39;cherries&#39;
</code></pre><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for of在这里干了什么：获取fruits的第一个元素赋值给fruit，运行代码块，再重复这两个操作一直到fruits的末尾。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="验证变量存在"><a href="#验证变量存在" class="headerlink" title="验证变量存在"></a>验证变量存在</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用变量的方式验证变量是否存在：</p><pre><code class="js">myName;
myAge;		//若没数值会返回undefined，若不存在会产生报错信息
</code></pre><h4 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h4><pre><code class="js">var myName = &quot;Chris&quot;;
var myAge = 37;
</code></pre><h4 id="更新变量"><a href="#更新变量" class="headerlink" title="更新变量"></a>更新变量</h4><pre><code class="js">myName = &quot;Bob&quot;;
myAge = 40;
</code></pre><h4 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h4><blockquote><p><code>let</code> 是在现代版本中的 JavaScript 创建的一个新的关键字，用于创建与 <code>var</code> 工作方式有些不同的变量，解决了过程中的问题。</p></blockquote><p>D1:</p><pre><code class="js">myName = &quot;Chris&quot;;
function logName() &#123;
  console.log(myName);
&#125;
logName();
var myName;			//变量提升
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let将不再允许该操作，并产生错误。</p><p>D2:</p><pre><code class="js">var myName = &quot;Chris&quot;;
var myName = &quot;Bob&quot;;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let不能多次声明相同名称的变量。</p><p><strong>注：Internet Explorer 直到第 11 版才支持 <code>let</code> !</strong></p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>Number</li><li>String</li><li>Boolean</li><li>Array</li><li>Object</li></ul><p><strong>注：js的变量为动态类型</strong></p><h3 id="数字与操作符"><a href="#数字与操作符" class="headerlink" title="数字与操作符"></a>数字与操作符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof：返回数据类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**:	幂，	<code>5 ** 5</code> &#x3D;3125</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x3D;&#x3D;&#x3D;：严格等于，要求数据类型相等</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js的字符串用单双引号都可以,但不能在字符串中包含相同的引号。</p><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><pre><code class="js">let bigmouth = &#39;I\&#39;ve got no right to take my place...&#39;;	//	使用\&#39;转义
</code></pre><h4 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与字符串相互转换，用Number() 和 toString()方法。</p><pre><code class="js">let myNum = Number(myString);	//转换为数值
let myString = myNum.toString();	//转换为字符串
</code></pre><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length方法返回长度：</p><pre><code class="js">browserType.length;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexOf方法查找子字符串：</p><pre><code class="js">browserType.indexOf(&quot;zilla&quot;);	//找不到返回-1
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice方法提取字符串：</p><pre><code class="js">browserType.slice(0, 3);		//范围不包含第二个参数
browserType.slice(3);			//返回自第三个字符后的字符串
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toLowerCase、toUpperCase大小写转换：</p><pre><code class="js">let radData = &quot;mY&quot;;
radData.toLowerCase();		//“my”
radData.toUpperCase();		//&quot;MY&quot;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace进行替换：</p><pre><code class="js">let browserType = mozilia;
browserType.replace(&quot;moz&quot;, &quot;van&quot;);		//vanilia
</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><pre><code class="js">let shopping = [&quot;bread&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot;];
let random = [&quot;tree&quot;, 795, [0, 1, 2]];			//不一定同一种类
</code></pre><h4 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h4><pre><code class="js">shopping[0] = &quot;tahini&quot;;
shopping;
// shopping will now return [ &quot;tahini&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot; ]
</code></pre><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><pre><code class="js">shopping.length;
</code></pre><h4 id="字符串和数组的转换"><a href="#字符串和数组的转换" class="headerlink" title="字符串和数组的转换"></a>字符串和数组的转换</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split方法:</p><pre><code class="js">let myData = &quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;;
let myArray = myData.split(&quot;,&quot;);
myArray;		//Manchester London Liverpool Birmingham Leeds Carlisle&quot;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join方法:</p><pre><code class="js">let myNewString = myArray.join(&quot;,&quot;);
myNewString;	//Manchester,London,Liverpool,Birmingham,Leeds,Carlisle
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toString方法：</p><pre><code class="js">myArray.toString();
</code></pre><h4 id="添加或删除数组项"><a href="#添加或删除数组项" class="headerlink" title="添加或删除数组项"></a>添加或删除数组项</h4><pre><code class="js">let myArray = [
  &quot;Manchester&quot;,
  &quot;London&quot;,
  &quot;Liverpool&quot;,
  &quot;Birmingham&quot;,
  &quot;Leeds&quot;,
  &quot;Carlisle&quot;,
];

myArray.push(&quot;Cardiff&quot;, &quot;Bradford&quot;);		//末尾添加Cardiff、Bradford
myArray.pop()		//删除最后一个元素
myArray.unshift(&quot;Edinburgh&quot;)	//首部添加Edinburgh
myArray.shift()		//删除第一个元素
</code></pre><h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><pre><code class="js">if (condition) &#123;
&#125; else &#123;
&#125;
</code></pre><p>例子:</p><pre><code class="html">&lt;label for=&quot;weather&quot;&gt;选择今天的天气：&lt;/label&gt;
&lt;select id=&quot;weather&quot;&gt;
  &lt;option value=&quot;&quot;&gt;--作出选择--&lt;/option&gt;
  &lt;option value=&quot;sunny&quot;&gt;晴天&lt;/option&gt;
  &lt;option value=&quot;rainy&quot;&gt;雨天&lt;/option&gt;
  &lt;option value=&quot;snowing&quot;&gt;雪天&lt;/option&gt;
  &lt;option value=&quot;overcast&quot;&gt;阴天&lt;/option&gt;
&lt;/select&gt;
&lt;p&gt;&lt;/p&gt;
</code></pre><pre><code class="js">const select = document.querySelector(&quot;select&quot;);
const para = document.querySelector(&quot;p&quot;);

select.addEventListener(&quot;change&quot;, setWeather);

function setWeather() &#123;
  const choice = select.value;

  if (choice === &quot;sunny&quot;) &#123;			//进行判断
    para.textContent = &quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;;
  &#125; else if (choice === &quot;rainy&quot;) &#123;
    para.textContent = &quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;;
  &#125; else if (choice === &quot;snowing&quot;) &#123;
    para.textContent =
      &quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;;
  &#125; else if (choice === &quot;overcast&quot;) &#123;
    para.textContent =
      &quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;;
  &#125; else &#123;
    para.textContent = &quot;&quot;;
  &#125;
&#125;
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同java，不再写笔记了。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><pre><code class="js">function myFunction() &#123;
  alert(&quot;hello world!&quot;);
&#125;

myFunction();
</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也称函数表达式，没有函数名的函数，经常与事件处理程序一起使用。</p><pre><code class="js">function() &#123;
  alert(&quot;hello world!&quot;);
&#125;
</code></pre><p>例:</p><pre><code class="js">var Button = document.querySelector(&quot;button&quot;);
Button.onclick = function()
&#123;
    alert(&quot;hello World!&quot;);
&#125;
</code></pre><p>又如:</p><pre><code class="js">var test = function () &#123;
  alert(&quot;hello world!&quot;);
&#125;;

test();
</code></pre><h3 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h3><blockquote><p>事件是发生在你正在编程的系统中的事情——当事件发生时，系统产生（或“触发”）某种信号，并提供一种机制，当事件发生时，可以自动采取某种行动（即运行一些代码）。事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了对一个事件做出反应，你要给它附加一个<strong>事件处理器</strong></p><h4 id="实例：处理点击事件"><a href="#实例：处理点击事件" class="headerlink" title="实例：处理点击事件"></a>实例：处理点击事件</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&lt;button&gt;</code>元素将在用户点击按钮时触发一个事件（定义了一个addEventListener函数）</p><pre><code class="html">&lt;button&gt;改变颜色&lt;/button&gt;	
</code></pre><pre><code class="js">const btn = document.querySelector(&quot;button&quot;);//引用
function random(number) &#123;
  return Math.floor(Math.random() * (number + 1));
&#125;

//click可以监听点击事件
btn.addEventListener(&quot;click&quot;, () =&gt; &#123;
  const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`;
  document.body.style.backgroundColor = rndCol;
&#125;);
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅仅可以监听点击事件，addEventListener还可以:</p><ul><li>focus:聚焦（按Tab）</li><li>blur:失焦(再次按下Tab)</li><li>dblclick:双击按键</li><li>mouseover：鼠标指针在按钮上悬停</li><li>mouseout：鼠标指针移出按钮</li></ul><h4 id="移除监听器"><a href="#移除监听器" class="headerlink" title="移除监听器"></a>移除监听器</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用removeEventListener()方法</p><pre><code class="js">btn.removeEventListener(&quot;click&quot;, changeBackground);
</code></pre><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以传递AbortSignal到addEventListener()，在拥有AbortSignal的控制器上调用abort()来删除。</p><pre><code class="js">const controller = new AbortController();

btn.addEventListener(&quot;click&quot;,() =&gt; &#123;
    const rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;, $&#123;random(255)&#125;)`;
    document.body.style.backgroundColor = rndCol;
  &#125;,
  &#123; signal: controller.signal &#125; // 向该处理器传递 AbortSignal
);
</code></pre><p>然后</p><pre><code class="js">controller.abort(); // 移除所有与该控制器相关的事件处理器
</code></pre><h4 id="在单个事件上添加多个监听器"><a href="#在单个事件上添加多个监听器" class="headerlink" title="在单个事件上添加多个监听器"></a>在单个事件上添加多个监听器</h4><pre><code class="js">myElement.addEventListener(&quot;click&quot;, functionA);
myElement.addEventListener(&quot;click&quot;, functionB);
</code></pre><h4 id="其他事件监听器机制"><a href="#其他事件监听器机制" class="headerlink" title="其他事件监听器机制"></a>其他事件监听器机制</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事件处理器属性</strong>：可以触发事件的对象通常有<code>on+事件名称</code>的属性，例如 <code>onclick</code>。</p><p>​	所以也可以这样写：</p><pre><code class="js">btn.onclick = () =&gt; &#123;
  const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`;
  document.body.style.backgroundColor = rndCol;
&#125;;
</code></pre><p>​	或者<code>btn.onclick = functionA</code>;</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事件处理器属性不能添加多个处理程序。</strong></p><p>​	<strong>内联事件处理器</strong></p><pre><code class="html">&lt;button onclick=&quot;bgChange()&quot;&gt;按下我&lt;/button&gt;
</code></pre><pre><code class="js">function bgChange() &#123;
  const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`;
  document.body.style.backgroundColor = rndCol;
&#125;
</code></pre><blockquote><p>许多常见的服务器配置将禁止内联 JavaScript。</p><p><strong>你永远不应该使用 HTML 事件处理器属性</strong>——那些已经过时了，使用它们是不好的做法。</p></blockquote><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在事件处理函数内部可能会看到一个固定指定名称的参数，例如 <code>event</code>、<code>evt</code> 或 <code>e</code>，这就是<strong>事件对象</strong>。</p><pre><code class="js">//e.target指的是按钮本身。事件对象 e 的 target 属性始终是事件刚刚发生的元素的引用
const btn = document.querySelector(&quot;button&quot;);
function bgChange(e) &#123;
  const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`;
  e.target.style.backgroundColor = rndCol;
  console.log(e);
&#125;

btn.addEventListener(&quot;click&quot;, bgChange);
</code></pre><p>​</p><h4 id="事件对象的额外属性"><a href="#事件对象的额外属性" class="headerlink" title="事件对象的额外属性"></a>事件对象的额外属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/keydown_event"><code>keydown</code></a> 事件在用户按下一个键时发生。它的事件对象是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent"><code>KeyboardEvent</code></a>，它是一个专门的 <code>Event</code> 对象，有一个 <code>key</code> 属性，告诉你哪个键被按下。</p><p>例：</p><pre><code class="html">&lt;input id=&quot;textBox&quot; type=&quot;text&quot; /&gt;
&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;
</code></pre><pre><code class="js">const textBox = document.querySelector(&quot;#textBox&quot;);
const output = document.querySelector(&quot;#output&quot;);
textBox.addEventListener(&quot;keydown&quot;, (event) =&gt; &#123;
  output.textContent = `You pressed &quot;$&#123;event.key&#125;&quot;.`;
&#125;);
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行后，每当你在输入框内敲下字母，将会显示你刚敲下的内容。</p><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码创造表单，要求填入名和姓，并有提交按钮。</p><pre><code class="html">&lt;form&gt;
  &lt;div&gt;
    &lt;label for=&quot;fname&quot;&gt;First name: &lt;/label&gt;
    &lt;input id=&quot;fname&quot; type=&quot;text&quot; /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;lname&quot;&gt;Last name: &lt;/label&gt;
    &lt;input id=&quot;lname&quot; type=&quot;text&quot; /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt;
  &lt;/div&gt;
&lt;/form&gt;
&lt;p&gt;&lt;/p&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在submit事件中实行简单检查，如果文本字段为空，调用<code>preventDefault()</code>停止提交并报告错误信息，否则继续提交。</p><pre><code class="js">const form = document.querySelector(&quot;form&quot;);
const fname = document.getElementById(&quot;fname&quot;);
const lname = document.getElementById(&quot;lname&quot;);
const para = document.querySelector(&quot;p&quot;);

form.addEventListener(&quot;submit&quot;, (e) =&gt; &#123;
  if (fname.value === &quot;&quot; || lname.value === &quot;&quot;) &#123;
    e.preventDefault();
    para.textContent = &quot;You need to fill in both names!&quot;;
  &#125;
&#125;);
</code></pre><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><pre><code class="html">&lt;body&gt;
&lt;div id=&quot;container&quot;&gt;
  &lt;button&gt;点我！&lt;/button&gt;
&lt;/div&gt;
&lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;
&lt;/body&gt;    
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素上附加事件处理器，也会触发单击事件：</p><pre><code class="js">const output = document.querySelector(&quot;#output&quot;);
function handleClick(e) &#123;
  output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\n`;
&#125;

const container = document.querySelector(&quot;#container&quot;);
container.addEventListener(&quot;click&quot;, handleClick);
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素与按钮上同时附加事件处理器，都会触发：</p><pre><code class="js">const output = document.querySelector(&quot;#output&quot;);
function handleClick(e) &#123;
  output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\n`;
&#125;

const container = document.querySelector(&quot;#container&quot;);
const button = document.querySelector(&quot;button&quot;);

document.body.addEventListener(&quot;click&quot;, handleClick);
container.addEventListener(&quot;click&quot;, handleClick);
button.addEventListener(&quot;click&quot;, handleClick);


/*Result:
    你在BUTTON元素上进行了点击
    你在DIV元素上进行了点击
    你在BODY元素上进行了点击
*/
</code></pre><h4 id="实例：视频播放器"><a href="#实例：视频播放器" class="headerlink" title="实例：视频播放器"></a>实例：视频播放器</h4><ul><li>单击显示”视频按钮“时，显示包含视频的盒子但不开始播放</li><li>单击视频时播放</li><li>单击盒子内视频以外的任何区域时隐藏盒子</li></ul><pre><code class="html">&lt;button&gt;显示视频&lt;/button&gt;

&lt;div class=&quot;hidden&quot;&gt;
  &lt;video&gt;
    &lt;source
      src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm&quot; type=&quot;video/webm&quot; /&gt;
    &lt;p&gt;
      你的浏览器不支持 HTML 视频，这里有视频的&lt;a href=&quot;rabbit320.mp4&quot;&gt;替代链接&lt;/a&gt;。
    &lt;/p&gt;
  &lt;/video&gt;
&lt;/div&gt;
</code></pre><pre><code class="js">const btn = document.querySelector(&quot;button&quot;);
const box = document.querySelector(&quot;div&quot;);
const video = document.querySelector(&quot;video&quot;);

btn.addEventListener(&quot;click&quot;, () =&gt; box.classList.remove(&quot;hidden&quot;));
video.addEventListener(&quot;click&quot;, () =&gt; video.play());
box.addEventListener(&quot;click&quot;, () =&gt; box.classList.add(&quot;hidden&quot;));
</code></pre><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当点击按钮后，因为div包含着video，盒子和视频都会同时显示，当点击视频时，会同时运行两个事件处理器，所以视频播放但盒子又消失了。</p><h4 id="使用stopPropagation-修复问题"><a href="#使用stopPropagation-修复问题" class="headerlink" title="使用stopPropagation()修复问题"></a>使用stopPropagation()修复问题</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event对象有一个<code>stopPropagation()</code>函数，可以在当一个事件处理器调用时防止事件向其他元素传递。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将video的addEventListener修改即可解决问题:</p><pre><code class="js">video.addEventListener(&quot;click&quot;, (event) =&gt; &#123;
  event.stopPropagation();
  video.play();
&#125;);
</code></pre><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote><p>先在<em>最小嵌套</em>元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件捕获默认禁用，需要在<code>addEventListener()</code>中的<code>capture</code>选项中启用</p><p>接事件冒泡中的代码：</p><pre><code class="js">const output = document.querySelector(&quot;#output&quot;);
function handleClick(e) &#123;
  output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\n`;
&#125;

const container = document.querySelector(&quot;#container&quot;);
const button = document.querySelector(&quot;button&quot;);
//设置事件捕获
document.body.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;);
container.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;);
button.addEventListener(&quot;click&quot;, handleClick);

/* Result:
    你在BODY元素上进行了点击
    你在DIV元素上进行了点击
    你在BUTTON元素上进行了点击
*/
</code></pre><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在父元素上设置监听器，让发生在它们身上的事件冒泡到父元素上。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>当用户点击一个按钮时页面的区域设置成随机颜色</em></p><pre><code class="html">&lt;div id=&quot;container&quot;&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><pre><code class="css">//设置区域尺寸
.tile &#123;
  height: 100px;
  width: 25%;
  float: left;
&#125;
</code></pre><pre><code class="js">function random(number) &#123;
  return Math.floor(Math.random() * number);
&#125;

function bgChange() &#123;
  const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`;
  return rndCol;
&#125;

const container = document.querySelector(&quot;#container&quot;);
container.addEventListener(&quot;click&quot;, (event) =&gt;&#123;
    event.target.style.backgroundColor = bgChange();
&#125;);
</code></pre><h2 id="javaScript对象介绍"><a href="#javaScript对象介绍" class="headerlink" title="javaScript对象介绍"></a>javaScript对象介绍</h2><h3 id="java对象基础"><a href="#java对象基础" class="headerlink" title="java对象基础"></a>java对象基础</h3><h4 id="构造对象以及表示法"><a href="#构造对象以及表示法" class="headerlink" title="构造对象以及表示法"></a>构造对象以及表示法</h4><pre><code class="js">/*构造一个空对象*/
const person = &#123;&#125;;
</code></pre><pre><code class="js">/*用对象字面量创造对象*/
const person = &#123;
  name: [&quot;Bob&quot;, &quot;Smith&quot;],
  age: 32,
 
  bio() &#123;
    console.log(`$&#123;this.name[0]&#125; $&#123;this.name[1]&#125; 现在 $&#123;this.age&#125; 岁了。`);
  &#125;,
  introduceSelf() &#123;
    console.log(`你好！我是 $&#123;this.name[0]&#125;。`);
  &#125;,
&#125;;

/*	调用对象方法和属性  
    1.点表示法		*/
person.name;
person.name[0];
person.age;
person.bio();
// &quot;Bob Smith 现在 32 岁了。&quot;
person.introduceSelf();
// &quot;你好！我是 Bob。&quot;

/*	2,括号表示法		*/
person[&quot;age&quot;];
person[&quot;name&quot;][&quot;first&quot;];
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多数情况下用<strong>点表示法</strong>，但某些情况下你必须用<strong>括号表示法</strong>。</p><pre><code class="js">/*当对象属性名称保存在变量中，只能用括号表示法*/
const person = &#123;
    name: [&quot;Bob&quot;, &quot;Smith&quot;];
    age:32;
&#125;;

function logProperty(propertyName)&#123;
    console.log(person[propertyName]);
&#125;

logProperty(&quot;name&quot;);
//[&quot;Bob&quot;, &quot;Smith&quot;]
logProperty(&quot;age&quot;);
// 32
</code></pre><h4 id="子命令空间"><a href="#子命令空间" class="headerlink" title="子命令空间"></a>子命令空间</h4><pre><code class="js">/*用一个对象来做另一个对象成员的值*/
const person = &#123;
    name:&#123;
          first:&quot;Bob&quot;,
        last:&quot;Smith&quot;,
    &#125;
&#125;;

//访问
person.name.first;
person.name.last;
</code></pre><h4 id="设置对象成员"><a href="#设置对象成员" class="headerlink" title="设置对象成员"></a>设置对象成员</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>括号表示法</strong>可以动态创建成员名字，而<strong>点表示法</strong>不行。</p><pre><code class="js">/*设置对象成员*/
person.age = 45;
person[&quot;name&quot;][&quot;last&quot;] = &quot;Cratchit&quot;;

/*创建对象成员*/
person[&quot;eyes&quot;] = &quot;hazel&quot;;
person.farewell = function()&#123;
  console.log(&quot;再见！&quot;);  
&#125;;

person[&quot;eyes&quot;];
person.farewell();
</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="js">/*创造person的构造函数*/
function Person(name)&#123;
    this.name = name;
    this.introduceSelf = function(
        console.log(`你好！我是$(this.name)。`);
    ); 
&#125;

/*调用构造函数*/
const salva = new Person(&quot;Salva&quot;);
salva.name;
salva.introduceSelf();
// &quot;你好！我是 Salva。&quot;
</code></pre><h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><pre><code class="js">const myObject = &#123;
  city: &quot;Madrid&quot;,
  greet()&#123;
    console.log(`来自$(this.city)的问候`);  
  &#125;,
&#125;;
myObject.greet(); 
//来自 Madrid 的问候
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用myObject.时,出现以下信息</p><pre><code class="js">__defineGetter__
__defineSetter__
__lookupGetter__
__lookupSetter__
__proto__
city
constructor
greet
hasOwnProperty
isPrototypeOf
propertyIsEnumerable
toLocaleString
toString
valueOf

//调用其中的toString
myObject.toString(); //&quot;[object Object]&quot;
</code></pre><blockquote><p>javaScript中所有对象都有一个内置属性，称作原型，原型对象也会有自己的原型，逐渐构成了原型链，原型链终止于拥有null作为其原型的对象上。</p></blockquote><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当访问一个对象的属性时，如果在其本身找不到该属性，就会在原型中搜索，仍然找不到则继续搜索原型的原型，直到链的末端（返回undefined）。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Object.prototype</code>是最基础的原型，所有对象默认都拥有它，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的原型是<code>null</code>，故其位于原型链的终点。</p><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes/myobject-prototype-chain.svg"></p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个对象的原型不一定就是<code>Object.prototype</code></p><pre><code class="js">const myDate = new Date();
let object = myDate;

do &#123;
  object = Object.getPrototypeOf(object);
  console.log(object);
&#125; while (object);

// Date.prototype
// Object &#123; &#125;
// null
</code></pre><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes/mydate-prototype-chain.svg"></p><h4 id="属性遮蔽"><a href="#属性遮蔽" class="headerlink" title="属性遮蔽"></a>属性遮蔽</h4><blockquote><p>如果在对象中定义属性，而在对象原型中也定义了一个同名属性会发生什么？</p></blockquote><pre><code class="js">const myDate = new Date(1995, 11, 17);
console.log(myDate.getYear()); // 95
myDate.getYear = function () &#123;
  console.log(&quot;别的东西！&quot;);
&#125;;
myDate.getYear(); // &#39;别的东西！&#39;

/*调用 getYear时，会先在myDate中寻找。这叫做属性遮蔽 */
</code></pre><h4 id="设置原型"><a href="#设置原型" class="headerlink" title="设置原型"></a>设置原型</h4><pre><code class="js">/*方式一：使用Object.create()*/
const personPrototype = &#123;
  greet() &#123;
    console.log(&quot;hello!&quot;);
  &#125;,
&#125;;
//创造一个以personPrototype为原型的新对象
const carl = Object.create(personPrototype);
//原型为对象提供了greet方法
carl.greet();


/*方式二：使用构造函数*/
//创造personPrototype对象，该对象具有方法greet。
const personPrototype = &#123;
  greet() &#123;
    console.log(`你好，我的名字是 $&#123;this.name&#125;！`);
  &#125;,
&#125;;

//创造Person的构造函数
function Person(name) &#123;
  this.name = name;
&#125;

//将personPrototype中的方法绑定到Person的prototype属性上
Object.assign(Person.prototype, personPrototype);
// 或
// Person.prototype.greet = personPrototype.greet;

//调用
const reuben = new Person(&quot;Reuben&quot;);
reuben.greet(); // 你好，我的名字是 Reuben！
</code></pre><h4 id="自有属性"><a href="#自有属性" class="headerlink" title="自有属性"></a>自有属性</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接在对象中定义的属性，被称为<strong>自有属性</strong>。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用静态方法 <code>Object.hasOwn()</code>检查一个属性是否是自有属性。</p><pre><code class="js">const irma = new Person(&quot;Irma&quot;);
console.log(Object.hasOwn(irma, &quot;name&quot;)); // true
console.log(Object.hasOwn(irma, &quot;greet&quot;)); // false
</code></pre><h3 id="面向对象编程基本概念"><a href="#面向对象编程基本概念" class="headerlink" title="面向对象编程基本概念"></a>面向对象编程基本概念</h3><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java方面知识，不再赘述。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>javaScript中的原型与对象很像java中的类与对象，但两者依旧有区别。</strong></p><h3 id="javaScript中的类"><a href="#javaScript中的类" class="headerlink" title="javaScript中的类"></a>javaScript中的类</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="js">//用class声明一个类
class Person&#123;
    name;
    //构造函数
    constructor(name)&#123;
        this.name = name;
    &#125;
    introduceSelf()&#123;
        console.log(`Hi! I&#39;m $&#123;this.name&#125;`);
    &#125;
&#125;
//创建并使用
const giles = new Person(&quot;Giles&quot;);
giles.introduceSelf(); // Hi! I&#39;m Giles
</code></pre><h4 id="省略构造函数"><a href="#省略构造函数" class="headerlink" title="省略构造函数"></a>省略构造函数</h4><pre><code class="js">/*不需要初始化时，默认构造函数将自动生成*/
class Animal &#123;
  sleep() &#123;
    console.log(&quot;zzzzzzz&quot;);
  &#125;
&#125;

const spot = new Animal();
spot.sleep(); //&#39;zzzzzzz&#39;
</code></pre><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><pre><code class="js">class Professor extends Person&#123;
    teaches;
    
    constructor(name, teaches)&#123;
        super(name);
        this.teaches = teaches;
    &#125;
    
    introduceSelf() &#123;
        console.log(
          `My name is $&#123;this.name&#125;, and I will be your $&#123;this.teaches&#125; professor.`,
    )&#125;;
    
    grade(paper) &#123;
        const grade = Math.floor(Math.random() * (5 - 1) + 1);
        console.log(grade);
  &#125;
&#125;


//使用
const walsh = new Professor(&quot;Walsh&quot;, &quot;Psychology&quot;);
walsh.introduceSelf();
// &#39;My name is Walsh, and I will be your Psychology professor&#39;
walsh.grade(&quot;my paper&quot;); // some random grade
</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code class="js">class Student extends Person &#123;
  //#year是私有数据属性,&#39;用#&#39;表示。
   #year;
  constructor(name, year) &#123;
    super(name);
    this.#year = year;
  &#125;
  introduceSelf() &#123;
    console.log(`Hi! I&#39;m $&#123;this.name&#125;, and I&#39;m in year $&#123;this.#year&#125;.`);
  &#125;
  canStudyArchery() &#123;
    return this.#year &gt; 1;
  &#125;
&#125;

//在类的外部尝试访问#year将会出错
const summers = new Student(&quot;Summers&quot;, 2);
summers.#year; // SyntaxError
</code></pre><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><pre><code class="js">//与私有属性一样
class Example &#123;
  somePublicMethod() &#123;
    this.#somePrivateMethod();
  &#125;
  #somePrivateMethod() &#123;
    console.log(&quot;You called me?&quot;);
  &#125;
&#125;
const myExample = new Example();
myExample.somePublicMethod(); // &#39;You called me?&#39;
myExample.#somePrivateMethod(); // SyntaxError
</code></pre><h3 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h3><h4 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h4><blockquote><p>javaScript对象表示法（JSON）是用于将结构化数据表示为 JavaScript 对象的标准格式，通常用于在网站上表示和传输数据。</p></blockquote><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON可以作为一个对象或者字符串存在，前者用于解读JSON中的数据，后者用于通过网络传输JSON数据。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串转换为原生对象称为反序列化，原生对象转换为字符串称为序列化。</p><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON存储在<code>.json</code>中。</p><p>​</p><h4 id="JSON结构"><a href="#JSON结构" class="headerlink" title="JSON结构"></a>JSON结构</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON类似于对象字面量。</p><pre><code class="json">&#123;
  &quot;squadName&quot;: &quot;Super hero squad&quot;,
  &quot;homeTown&quot;: &quot;Metro City&quot;,
  &quot;formed&quot;: 2016,
  &quot;secretBase&quot;: &quot;Super tower&quot;,
  &quot;active&quot;: true,
  &quot;members&quot;: [
    &#123;
      &quot;name&quot;: &quot;Molecule Man&quot;,
      &quot;age&quot;: 29,
      &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;,
      &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;]
    &#125;,
    &#123;
      &quot;name&quot;: &quot;Madame Uppercut&quot;,
      &quot;age&quot;: 39,
      &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;,
      &quot;powers&quot;: [
        &quot;Million tonne punch&quot;,
        &quot;Damage resistance&quot;,
        &quot;Superhuman reflexes&quot;
      ]
    &#125;,
    &#123;
      &quot;name&quot;: &quot;Eternal Flame&quot;,
      &quot;age&quot;: 1000000,
      &quot;secretIdentity&quot;: &quot;Unknown&quot;,
      &quot;powers&quot;: [
        &quot;Immortality&quot;,
        &quot;Heat Immunity&quot;,
        &quot;Inferno&quot;,
        &quot;Teleportation&quot;,
        &quot;Interdimensional travel&quot;
      ]
    &#125;
  ]
&#125;
</code></pre><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串加载入js程序中，并解析到名叫<code>superHeroes</code>变量中，可以用该变量访问数据。</p><pre><code class="json">superHeroes.hometown;
superHeroes[&quot;active&quot;];
//访问members数组的第二个元素，其中的powers数组的第三个元素
superHeroes[&quot;members&quot;][1][&quot;powers&quot;][2];
</code></pre><h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p>​	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组与JSON可以相互转换，比如这样写依然有效。</p><pre><code class="json">[
    &#123;
    &quot;name&quot;: &quot;Molecule Man&quot;,
    &quot;age&quot;: 29,
    &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;,
    &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;]
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Madame Uppercut&quot;,
    &quot;age&quot;: 39,
    &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;,
    &quot;powers&quot;: [
      &quot;Million tonne punch&quot;,
      &quot;Damage resistance&quot;,
      &quot;Superhuman reflexes&quot;
    ]
  &#125;
]


//调用
[0][&quot;powers&quot;][0];
</code></pre><h4 id="JSON注意事项"><a href="#JSON注意事项" class="headerlink" title="JSON注意事项"></a>JSON注意事项</h4><ul><li>是纯数据格式，只有属性，没有方法。</li><li>要求在字符串和属性名称周围用<strong>双引号</strong>。</li><li>JSON文件很容易出错，可以用<a target="_blank" rel="noopener" href="https://jsonlint.com/">JSONLint</a>验证JSON。</li><li>JSON中只有带引号的字符串可以用作属性。</li></ul></div><div id="comment"><div id="gitalk-container"></div></div></div><footer id="footer"><div id="footer-wrap"><div>&copy; 2023 - 2024 Bin&#39;s blog <span id="footer-icon"><i class="fa-solid fa-font-awesome fa-fw"></i> </span>&commat;Binbin</div><div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a></div></div></footer></div><transition name="fade"><div id="preview" ref="preview" v-show="previewShow"><img id="preview-content" ref="previewContent"></div></transition></div><script src="/js/main.js"></script><script>const gitalk=new Gitalk({clientID:"dc78a87f9661af4d8654",clientSecret:"9bd08e5d81504be459c5c6cf2271f2829856d941",repo:"Review",owner:"Sakb1n",admin:"Sakb1n".split(","),language:"zh-CN",id:decodeURI(location.pathname),proxy:"https://cors-anywhere.1l1.icu/https://github.com/login/oauth/access_token"});gitalk.render("gitalk-container")</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:150,height:300,hOffset:-15,vOffset:-15},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>