<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>WEB应用开发 | Bin&#39;s blog</title><meta name="author" content="Binbin"><meta name="description" content="小彬彬的博客"><meta name="keywords" content="hexo,node,blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><link rel="icon" href="/images/pic.jpg"><script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css"><link rel="stylesheet" href="/css/fonts.min.css"><script>const mixins={}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script><script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"><script src="/js/lib/highlight.js"></script><script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script><script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css"><script src="/js/lib/math.js"></script><script src="/js/lib/preview.js"></script><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Bin's blog" type="application/atom+xml"></head><body><div id="background"></div><div id="layout"><transition name="fade"><div id="loading" v-show="loading"><div id="loading-circle"><h2>LOADING</h2><p>加载过慢请开启缓存 浏览器默认开启</p><img src="/images/loading.gif"></div></div></transition><div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}"><nav id="desktop-menu"><a class="title" href="/"><span>BIN&#39;S BLOG</span> </a><a href="/"><i class="fa-solid fa-house fa-fw"></i> <span>&ensp;Home</span> </a><a href="/about"><i class="fa-solid fa-id-card fa-fw"></i> <span>&ensp;About</span> </a><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> <span>&ensp;Archives</span> </a><a href="/categories"><i class="fa-solid fa-bookmark fa-fw"></i> <span>&ensp;Categories</span> </a><a href="/tags"><i class="fa-solid fa-tags fa-fw"></i> <span>&ensp;Tags</span></a></nav><nav id="mobile-menu"><div class="title" @click="showMenuItems = !showMenuItems"><i class="fa-solid fa-bars fa-fw"></i> <span>&emsp;BIN&#39;S BLOG</span></div><transition name="slide"><div class="items" v-show="showMenuItems"><a href="/"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-house fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Home</div></div></a><a href="/about"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-id-card fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">About</div></div></a><a href="/archives"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-box-archive fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Archives</div></div></a><a href="/categories"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-bookmark fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Categories</div></div></a><a href="/tags"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-tags fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Tags</div></div></a></div></transition></nav></div><transition name="fade"><div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div></transition><div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'"><div class="article"><div><h1>WEB应用开发</h1></div><div class="info"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2024/1/6 </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0/"><span class="icon"><i class="fa-solid fa-bookmark fa-fw"></i> </span>学习 </a></span><span class="tags"><span class="icon"><i class="fa-solid fa-tags fa-fw"></i> </span><span class="tag"><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="color:#ffa2c4">学习</a></span></span></div><div class="content" v-pre><h3 id="速通WEB考试重点-祝大家都能顺利通过（）"><a href="#速通WEB考试重点-祝大家都能顺利通过（）" class="headerlink" title="速通WEB考试重点,祝大家都能顺利通过（）"></a>速通WEB考试重点,祝大家都能顺利通过（）</h3><span id="more"></span><h4 id="1-Web应用开发流程"><a href="#1-Web应用开发流程" class="headerlink" title="1.Web应用开发流程"></a>1.Web应用开发流程</h4><blockquote><p>需求分析: 确定项目的业务需求, 明确用户的功能和交互需求, 定义项目的范围、功能和特性, 确定开发团队的目标.<br>项目规划: 制定项目计划, 包括开发阶段、测试阶段、上线时间等.<br>UI&#x2F;UX设计: 进行用户界面（UI）和用户体验（UX）的设计, 设计页面布局、颜色和交互流程.<br>前端开发: 使用HTML、CSS、JavaScript等技术实现UI设计, 前端框架（如React、Vue、Angular）的选择和使用.<br>后端开发： 选择后端技术栈(如Java、Python、Node.js), 开发后端业务逻辑.<br>数据库开发: 设计数据库表结构, 确定数据存储方式. 使用数据库管理系统（如MySQL、PostgreSQL、MongoDB）进行开发.<br>集成测试: 对前端、后端和数据库进行集成测试, 确保系统各部分协同工作,并检查系统是否满足需求.<br>系统测试: 对整个系统进行全面测试, 包括功能测试、性能测试、安全测试等.<br>部署: 部署到服务器, 配置服务器环境,设置域名、SSL证书等, 配置反向代理(如Nginx、Apache).<br>维护和优化: 定期进行系统维护,如数据库备份、日志清理等.根据用户反馈和系统监控数据,进行系统优化和升级.</p></blockquote><blockquote><p>C&#x2F;S架构: 开发客户端&#x2F;服务端软件、部署服务端程序、部署客户端程序、安装客户端软件.<br>B&#x2F;S架构: 开发服务器端代码、部署到Web服务器.</p><p>C&#x2F;S偏向用户体验, B&#x2F;S偏向功能服务实现, 两者并没有优劣之分.</p></blockquote><h4 id="2-静态网页的显示可以不依赖于Web服务器"><a href="#2-静态网页的显示可以不依赖于Web服务器" class="headerlink" title="2.静态网页的显示可以不依赖于Web服务器"></a>2.静态网页的显示可以不依赖于Web服务器</h4><blockquote><p>正确.</p></blockquote><h4 id="3-表格布局比DIV-CSS布局的兼容性更好"><a href="#3-表格布局比DIV-CSS布局的兼容性更好" class="headerlink" title="3.表格布局比DIV+CSS布局的兼容性更好"></a>3.表格布局比DIV+CSS布局的兼容性更好</h4><blockquote><p>正确. 由于采用的是HTML标签 &lt;table&gt;,各种浏览器都能准确解析该标签, DIV+CSS还没有实现所有浏览器的统一兼容.</p></blockquote><h4 id="4-表格布局比DIV-CSS布局更灵活多样"><a href="#4-表格布局比DIV-CSS布局更灵活多样" class="headerlink" title="4.表格布局比DIV+CSS布局更灵活多样"></a>4.表格布局比DIV+CSS布局更灵活多样</h4><blockquote><p>错误. 请多相信CSS的能力!</p></blockquote><h4 id="5-表单标记通过method属性设置后台的处理程序"><a href="#5-表单标记通过method属性设置后台的处理程序" class="headerlink" title="5.表单标记通过method属性设置后台的处理程序"></a>5.表单标记通过method属性设置后台的处理程序</h4><blockquote><p>正确. method可以取”GET”和”POST”值.</p></blockquote><h4 id="6-表单的主要作用是发布信息"><a href="#6-表单的主要作用是发布信息" class="headerlink" title="6.表单的主要作用是发布信息"></a>6.表单的主要作用是发布信息</h4><blockquote><p>错误. 表单的主要作用是收集和提交信息.</p></blockquote><h4 id="7-表单中的输入组件都是通过标记定义的"><a href="#7-表单中的输入组件都是通过标记定义的" class="headerlink" title="7.表单中的输入组件都是通过&lt;input&gt;标记定义的"></a>7.表单中的输入组件都是通过&lt;input&gt;标记定义的</h4><blockquote><p>错误. 其实不仅限于&lt;input&gt;, &lt;textarea&gt;&lt;select&gt;等都能标记定义.</p></blockquote><h4 id="8-表单中的密码框的输入回显字符只能是”-“"><a href="#8-表单中的密码框的输入回显字符只能是”-“" class="headerlink" title="8.表单中的密码框的输入回显字符只能是” * “"></a>8.表单中的密码框的输入回显字符只能是” * “</h4><blockquote><p>错误. 通常是圆点或者星号.</p></blockquote><h4 id="9-表单中一组单选按钮的name属性要相同"><a href="#9-表单中一组单选按钮的name属性要相同" class="headerlink" title="9.表单中一组单选按钮的name属性要相同"></a>9.表单中一组单选按钮的name属性要相同</h4><blockquote><p>正确. radio是以name属性进行分组的.</p></blockquote><h4 id="10-表单中一组复选按钮的name属性不需要相同"><a href="#10-表单中一组复选按钮的name属性不需要相同" class="headerlink" title="10.表单中一组复选按钮的name属性不需要相同"></a>10.表单中一组复选按钮的name属性不需要相同</h4><blockquote><p>正确. checkbox的name属性不用于分组.</p></blockquote><h4 id="11-表单中的列表默认只显示1个选项"><a href="#11-表单中的列表默认只显示1个选项" class="headerlink" title="11.表单中的列表默认只显示1个选项"></a>11.表单中的列表默认只显示1个选项</h4><blockquote><p>正确.</p></blockquote><h4 id="12-表单中的列表只能选择1个选项"><a href="#12-表单中的列表只能选择1个选项" class="headerlink" title="12.表单中的列表只能选择1个选项"></a>12.表单中的列表只能选择1个选项</h4><blockquote><p>错误. 使用multiple属性可以多个.</p></blockquote><h4 id="13-通过CSS的应用可以同时更新多个网页的样式"><a href="#13-通过CSS的应用可以同时更新多个网页的样式" class="headerlink" title="13. 通过CSS的应用可以同时更新多个网页的样式"></a>13. 通过CSS的应用可以同时更新多个网页的样式</h4><blockquote><p>正确.</p></blockquote><h4 id="14-CSS可以在网页中定义也可以在CSS文件中定义"><a href="#14-CSS可以在网页中定义也可以在CSS文件中定义" class="headerlink" title="14.CSS可以在网页中定义也可以在CSS文件中定义"></a>14.CSS可以在网页中定义也可以在CSS文件中定义</h4><blockquote><p>正确.</p></blockquote><h4 id="15-表单关键元素和相关设置"><a href="#15-表单关键元素和相关设置" class="headerlink" title="15.表单关键元素和相关设置"></a>15.表单关键元素和相关设置</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form">MDN form元素</a></p><blockquote><p>form标签用于向Web服务器提交信息.<br>主要属性:<br>&nbsp;&nbsp; &nbsp; name: 表单名称<br>&nbsp;&nbsp; &nbsp; action: 表单提交的URL<br>&nbsp;&nbsp; &nbsp; method: HTTP方式提交表单</p></blockquote><pre><code class="html">&lt;form action=&quot;/submit&quot; method=&quot;post&quot;&gt;
    &lt;!-- 表单中的其他元素 --&gt;
&lt;/form&gt;
</code></pre><h4 id="16-JavaScript变量名是区分大小写的"><a href="#16-JavaScript变量名是区分大小写的" class="headerlink" title="16.JavaScript变量名是区分大小写的"></a>16.JavaScript变量名是区分大小写的</h4><blockquote><p>正确.</p></blockquote><h4 id="17-JavaScript主要用于接受服务器端的响应"><a href="#17-JavaScript主要用于接受服务器端的响应" class="headerlink" title="17.JavaScript主要用于接受服务器端的响应"></a>17.JavaScript主要用于接受服务器端的响应</h4><blockquote><p>错误. 不仅仅接受服务器端的响应, 还有用户与页面的交互.</p></blockquote><h4 id="18-JavaScript变量的类型根据变量赋值来确定"><a href="#18-JavaScript变量的类型根据变量赋值来确定" class="headerlink" title="18.JavaScript变量的类型根据变量赋值来确定"></a>18.JavaScript变量的类型根据变量赋值来确定</h4><blockquote><p>正确. 弱类型语言.</p></blockquote><h4 id="19-JavaScript变量使用var声明时必须赋初值"><a href="#19-JavaScript变量使用var声明时必须赋初值" class="headerlink" title="19.JavaScript变量使用var声明时必须赋初值"></a>19.JavaScript变量使用var声明时必须赋初值</h4><blockquote><p>错误. 完全可以不赋初值, 默认undefined.</p></blockquote><h4 id="20-JavaScript实现表单提交参数验证"><a href="#20-JavaScript实现表单提交参数验证" class="headerlink" title="20.JavaScript实现表单提交参数验证"></a>20.JavaScript实现表单提交参数验证</h4><blockquote><p>来源于PPT.</p></blockquote><pre><code class="javascript">&lt;button onclick=&quot;check();&quot;/&gt;
&lt;script language=&quot;JavaScript&quot;&gt;
    function check()&#123;
        if(frm.userName.value==&quot;&quot;)&#123;
            alert(&quot;userName excepted!&quot;);
            frm.userName.focus();
            return;
        &#125;
        frm.submit();
    &#125;
&lt;/script&gt;

</code></pre><pre><code class="javascript">&lt;submit onclick=&quot;return check();&quot;/&gt;
&lt;script language=&quot;JavaScript&quot;&gt;
    function check()&#123;
        if(frm.userName.value==&quot;&quot;)&#123;
            alert(&quot;userName excepted!&quot;);
            frm.userName.focus();
            return false;
        &#125;
    return true;
&#125;
&lt;/script&gt;
</code></pre><h4 id="21-正则表达式"><a href="#21-正则表达式" class="headerlink" title="21.正则表达式"></a>21.正则表达式</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions">MDN 正则表达式</a></p><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo1.png"> <img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo2.png"><h4 id="22-JSON是一种轻量级的数据交换格式"><a href="#22-JSON是一种轻量级的数据交换格式" class="headerlink" title="22.JSON是一种轻量级的数据交换格式"></a>22.JSON是一种轻量级的数据交换格式</h4><blockquote><p>正确.</p></blockquote><h4 id="23-JSON和XML比较JSON体积更小"><a href="#23-JSON和XML比较JSON体积更小" class="headerlink" title="23.JSON和XML比较JSON体积更小"></a>23.JSON和XML比较JSON体积更小</h4><blockquote><p>正确. JSON有更简洁的语法结构.</p></blockquote><h4 id="24-JSON数据前端显示"><a href="#24-JSON数据前端显示" class="headerlink" title="24.JSON数据前端显示"></a>24.JSON数据前端显示</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON">MDN JSON</a></p><p>&nbsp;&nbsp; &nbsp;JSON是一种语法.<br>&nbsp;&nbsp; &nbsp;JSON不是JavaScript, JavaScript不是JSON.<br>&nbsp;&nbsp; &nbsp;JSON方法:</p><pre><code class="javascript">//JSON.parse():解析JSON字符串, 转换为JavaScript值(JSON字符串不允许用逗号结尾)
const json = &#39;&#123;&quot;result&quot;:true, &quot;count&quot;:40&#125;&#39;;
const obj = JSON.parse(json);
console.log(obj.count); // Expected output: 42
console.log(obj.result); // Expected output: true

//JSON.stringify(): 将JavaScript值转换为JSON字符串
console.log(JSON.stringify(&#123; x: 5, y: 6 &#125;)); // Expected output: &#39;&#123;&quot;x&quot;:5,&quot;y&quot;:6&#125;&#39;
console.log(
    JSON.stringify([new Number(3), new String(&#39;false&#39;), new Boolean(false)]),
);// Expected output: &#39;[3,&quot;false&quot;,false]&#39;

//undefined、任意的函数以及 symbol 值, 在序列化过程中会被转换成 null.
console.log(JSON.stringify(&#123; x: [10, undefined, function () &#123;&#125;, Symbol(&#39;&#39;)] &#125;));// Expected output: &#39;&#123;&quot;x&quot;:[10,null,null,null]&#125;&#39;

//以 symbol 为属性键的属性都会被完全忽略掉
JSON.stringify(&#123; [Symbol.for(&quot;foo&quot;)]: &quot;foo&quot; &#125;, [Symbol.for(&quot;foo&quot;)]);// &#39;&#123;&#125;&#39;
</code></pre><p>课上示例：</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt; 
var testData;
testData=[
    &#123;&quot;code&quot;:&quot;00001&quot;,&quot;name&quot;:&quot;王亮&quot;,&quot;sex&quot;:0,&quot;grade&quot;:2015,&quot;major&quot;:&quot;软件工程&quot;&#125;,
    &#123;&quot;code&quot;:&quot;00002&quot;,&quot;name&quot;:&quot;李树国 &quot;,&quot;sex&quot;:0,&quot;grade&quot;:2015,&quot;major&quot;:&quot;软件工程&quot;&#125;,
    &#123;&quot;code&quot;:&quot;00003&quot;,&quot;name&quot;:&quot;赵欣&quot;,&quot;sex&quot;:1,&quot;grade&quot;:2015,&quot;major&quot;:&quot;空间信息&quot;&#125;
    ];

function WriteStList(data)&#123;
    var studentList=data;
    var strHtml=&quot;&quot;;
    strHtml+=&quot;&lt;table width=\&quot;100%\&quot;  border=\&quot;0\&quot; cellpadding=\&quot;0\&quot; cellspacing=\&quot;0\&quot; align=\&quot;center\&quot;&gt;	&quot;;
    for(var i=0;i&lt;studentList.length;i++)&#123;
        strHtml+=&quot;&lt;tr class=\&quot;td_&quot;+(i%2+1)+&quot;\&quot;&gt;&quot;;
        strHtml+=&quot;&lt;td width=\&quot;15%\&quot;&gt;&quot;+studentList[i][&quot;code&quot;]+&quot;&lt;/td&gt;&quot;;
        strHtml+=&quot;&lt;td width=\&quot;15%\&quot;&gt;&quot;+studentList[i][&quot;name&quot;]+&quot;&lt;/td&gt;&quot;;
        strHtml+=&quot;&lt;td width=\&quot;15%\&quot;&gt;&quot;+(studentList[i][&quot;sex&quot;]==0?&quot;男&quot;:&quot;女&quot;)+&quot;&lt;/td&gt;&quot;;
        strHtml+=&quot;&lt;td width=\&quot;15%\&quot;&gt;&quot;+studentList[i][&quot;grade&quot;]+&quot;&lt;/td&gt;&quot;;
        strHtml+=&quot;&lt;td width=\&quot;15%\&quot;&gt;&quot;+studentList[i][&quot;major&quot;]+&quot;&lt;/td&gt;&quot;;
        strHtml+=&quot;&lt;td&gt;&lt;a href=\&quot;student_edit.html\&quot;&gt;编辑&lt;/a&gt;&quot;;
        strHtml+=&quot;&lt;a href=\&quot;JavaScript:alert(&#39;准备删除学号为&quot;+studentList[i][&quot;code&quot;]+&quot;的学生信息&#39;)\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;	
    &#125;
    strHtml+=&quot;&lt;/table&gt;&quot;;
    document.getElementById(&quot;studentsSpan&quot;).innerHTML =strHtml;
&#125;  
&lt;/script&gt;
</code></pre><h4 id="25-JSP开发中最常用的两种设计模式"><a href="#25-JSP开发中最常用的两种设计模式" class="headerlink" title="25.JSP开发中最常用的两种设计模式"></a>25.JSP开发中最常用的两种设计模式</h4><p>1.JSP+JavaBean<br><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo3.png"><br>&nbsp;&nbsp; &nbsp; 用户通过客户端请求WEB服务器, 服务端接收请求后调用JSP页面, JSP中调用JavaBean, JavaBean中连接和操作数据库实现业务逻辑后将结果返回到JSP页面, WEB服务器读取JSP中的内容并将最终结果返回到客户端中进行显示.</p><p>2.MVC模式<br>&nbsp;&nbsp; &nbsp; 即模型-视图-控制器.<br>&nbsp;&nbsp; &nbsp; <strong>模型</strong>: 用于存储数据的对象(一个或多个JavaBean对象). <strong>视图</strong>:显示模型中的数据(一个或多个JSP页面). <strong>控制器</strong>:业务逻辑操作(一个或多个servlet对象).</p><h4 id="26-JSP技术的MVC模式描述"><a href="#26-JSP技术的MVC模式描述" class="headerlink" title="26.JSP技术的MVC模式描述"></a>26.JSP技术的MVC模式描述</h4><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo4.png"> &nbsp;&nbsp; &nbsp; 用户通过浏览器发送请求到servlet, servlet将调用JavaBean完成数据的操作处理与封装并调用相应的JSP页面, JSP页面将调用JavaBean获取需要的数据, 最终将结果返回到客户端浏览器上进行显示.<h4 id="27-JSP页面中的Java脚本标记包括哪三种元素"><a href="#27-JSP页面中的Java脚本标记包括哪三种元素" class="headerlink" title="27.JSP页面中的Java脚本标记包括哪三种元素"></a>27.JSP页面中的Java脚本标记包括哪三种元素</h4><blockquote><p>JSP表达式: &lt;%&#x3D; %&gt;<br>声明标识: &lt;%! %&gt;<br>脚本程序: &lt;% %&gt;</p></blockquote><h4 id="28-JSP页面中标记的用途"><a href="#28-JSP页面中标记的用途" class="headerlink" title="28.JSP页面中&lt;%! %&gt;标记的用途"></a>28.JSP页面中&lt;%! %&gt;标记的用途</h4><blockquote><p>声明变量或代码.</p></blockquote><h4 id="29-JSP内置对象"><a href="#29-JSP内置对象" class="headerlink" title="29.JSP内置对象"></a>29.JSP内置对象</h4><blockquote><p>request: 请求对象<br>response: 响应对象<br>out: JSP输出流对象<br>session: 会话对象<br>application: ServletContext对象<br>config: ServletConfig对象<br>page: 指向当前jsp的对象<br>pageContext: jsp上下文对象<br>exception: 异常对象</p></blockquote><h4 id="30-JSP第一次访问过后，将生成一个exe文件"><a href="#30-JSP第一次访问过后，将生成一个exe文件" class="headerlink" title="30.JSP第一次访问过后，将生成一个exe文件"></a>30.JSP第一次访问过后，将生成一个exe文件</h4><blockquote><p>错误. 转换为一个servlet文件, servlet文件编译为class文件后再执行.<br>JSP页面转换为java类, 该类继承了HttpJspBase类, 而HttpJspBase类继承了HttpServlet类, 故一个JSP可以理解为一个Servlet.</p></blockquote><h4 id="31-转发和重定向的区别"><a href="#31-转发和重定向的区别" class="headerlink" title="31.转发和重定向的区别"></a>31.转发和重定向的区别</h4><blockquote><p>转发可以通过request对象直接传递到目标页面, 而重定向需要使用更大范围的Session等方式进行传递.<br>转发是服务器内部行为, 过程中, 浏览器URL是不会发生变化的; 而重定向过程中, 浏览器会根据新的URL发送请求.</p></blockquote><h4 id="32-JavaBean的特点-一次编写-任何地方执行-任何地方重用"><a href="#32-JavaBean的特点-一次编写-任何地方执行-任何地方重用" class="headerlink" title="32.JavaBean的特点, 一次编写, 任何地方执行, 任何地方重用"></a>32.JavaBean的特点, 一次编写, 任何地方执行, 任何地方重用</h4><blockquote><p>JavaBean用于封装对象, 要提供get、set方法.</p></blockquote><pre><code class="java">public class MyClass &#123;
    private String propertyName;
    public String getPropertyName() &#123;
        return propertyName;
    &#125;
    public void setPropertyName(String propertyName) &#123;
        this.propertyName = propertyName;
    &#125;
&#125;
</code></pre><h4 id="33-根据用途JavaBean分类"><a href="#33-根据用途JavaBean分类" class="headerlink" title="33.根据用途JavaBean分类"></a>33.根据用途JavaBean分类</h4><blockquote><p>通用工具JavaBean: 实现基本功能(字符转换、类型转换等)<br>值JavaBean: 封装实体<br>业务处理JavaBean: 处理数据</p></blockquote><h4 id="34-不可视化JavaBean的属性主要有哪些"><a href="#34-不可视化JavaBean的属性主要有哪些" class="headerlink" title="34.不可视化JavaBean的属性主要有哪些"></a>34.不可视化JavaBean的属性主要有哪些</h4><blockquote><p>get、set、构造方法之类.</p></blockquote><h4 id="35-JavaBean编写规范"><a href="#35-JavaBean编写规范" class="headerlink" title="35.JavaBean编写规范"></a>35.JavaBean编写规范</h4><blockquote><p>实现java.io.Serializable接口<br>是一个公共类<br>存在无参数的构造函数<br>提供set、get方法</p></blockquote><h4 id="36-JDBC访问数据库过程"><a href="#36-JDBC访问数据库过程" class="headerlink" title="36.JDBC访问数据库过程"></a>36.JDBC访问数据库过程</h4><blockquote><p>加载驱动程序 -&gt; 建立数据库连接 -&gt; 执行sql语句 -&gt; 处理结果 -&gt; 关闭连接</p></blockquote><pre><code class="java">    String diverClass= &quot;com.mysql.jdbc.Driver&quot;;
    String dbUrl= &quot;jdbc:mysql://localhost:3306/db_database08&quot;;
    //1、建立数据库连接
    Class.forName(diverClass);	// 1.1加载驱动程序
    Connection con=
        DriverManager.getConnection (dbUrl, “root&quot;, “rootpassword&quot;);  //1.2创建链接
    //2、执行SQL语句(不建议用statement了)
    Statement sql=con.createStatement();  //2.1创建sql语句执行对象
    ResultSet rs=sql.executeQuery(&quot;select * from tb_user”); //2.2执行sql
    //3、处理SQL语句执行结果
    while(rs.next())&#123;    获取记录中每个字段的数据   &#125;//遍历结果集对象
    //4、关闭数据库连接
    rs.close();	sql.close();	con.close();
</code></pre><h4 id="37-JDBC常用接口及其描述"><a href="#37-JDBC常用接口及其描述" class="headerlink" title="37.JDBC常用接口及其描述"></a>37.JDBC常用接口及其描述</h4><p>&nbsp;&nbsp; &nbsp; Driver: 驱动程序接口, 用于加载驱动.</p><pre><code class="java">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 加载类时自动注册mysql驱动
</code></pre><p>&nbsp;&nbsp; &nbsp; DriverManager: 管理用户与数据库连接, 一般使用getConnection方法.</p><pre><code class="java">    DriverManager.getConnection(String url, String user, String password) // 连接数据库
</code></pre><p>&nbsp;&nbsp; &nbsp; Connection: 数据库连接接口, 有close方法.</p><pre><code class="java">    Connection conn = DriverManager.getConnection(url, user, password);
</code></pre><p>&nbsp;&nbsp; &nbsp; Statement: 执行静态Sql语句, 返回结果集ResultSet, 不推荐(存在sql注入问题)</p><p>&nbsp;&nbsp; &nbsp; PreparedStatement: 执行动态Sql语句, 需要填充占位符”?”.</p><pre><code class="java">    String sql = &quot;select * from users WHERE name = ?&quot;; // sql语句
    PreparedStatement ps = conn.prepareStatement(sql)l //预编译
    ps.setObject(1, &quot;bin&quot;);     //填充占位符, 注意是从1开始编号
    ResultSet rs = ps.executeQuery(); //执行sql语句
</code></pre><p>&nbsp;&nbsp; &nbsp; CallableStatement: 调用存储过程, 继承于PreparedStatement.</p><p>&nbsp;&nbsp; &nbsp; ResultSet: 类似于sql中的一个表, 可以获得表行列的数据.<br>&nbsp;&nbsp; &nbsp; ResultSet维护了一个指向当前数据行的游标, 可以通过next()方法移动到下一行并判断该行是否有效.相当于Iterator的hasNext()与next()的结合.</p><pre><code class="java"> public static &lt;T&gt; List&lt;T&gt; newselect1(Class&lt;T&gt; clazz, String sql, Object ...args)&#123;
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try &#123;
            conn = JDBCUtils.getConnection();
            ps = conn.prepareStatement(sql);
            for (int i = 0; i &lt; args.length; i++)
            &#123;
                ps.setObject(i + 1, args[i]);
            &#125;
            rs = ps.executeQuery();
            ResultSetMetaData rsmd = rs.getMetaData();
            int count = rsmd.getColumnCount();
            ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;();
            while(rs.next())&#123;
                T t = clazz.newInstance();
                for (int i = 0; i &lt; count; i++)&#123;
                    Object columnValue = rs.getObject(i + 1);
                    String columnName = rsmd.getColumnLabel(i + 1);
                    Field field = t.getClass().getDeclaredField(columnName);
                    field.setAccessible(true);
                    field.set(t, columnValue);
                &#125;
                list.add(t);
            &#125;
            return list;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            JDBCUtils.closeResource(conn, ps, rs);
        &#125;
    &#125;
</code></pre><h4 id="38-PreparedStatement接口的特点"><a href="#38-PreparedStatement接口的特点" class="headerlink" title="38.PreparedStatement接口的特点"></a>38.PreparedStatement接口的特点</h4><blockquote><p>PreparedStatement是Statement的子接口, 它的重要特点是预编译, 性能提升的同时还可以防止SQL注入的问题.</p></blockquote><h4 id="39-Resultset接口"><a href="#39-Resultset接口" class="headerlink" title="39.Resultset接口"></a>39.Resultset接口</h4><blockquote><p>同37.</p></blockquote><h4 id="40-DBManager类获得数据库连接-执行sql查询操作流程"><a href="#40-DBManager类获得数据库连接-执行sql查询操作流程" class="headerlink" title="40.DBManager类获得数据库连接, 执行sql查询操作流程"></a>40.DBManager类获得数据库连接, 执行sql查询操作流程</h4><blockquote><p>同37.<br>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动, 但在调用Driver接口时, 自动执行静态代码块, 所以不需要额外编写, 只需加载类即可.</p></blockquote><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo5.png"><h4 id="41-业务逻辑Bean-获取数据库数据封装到值型JavaBean-流程"><a href="#41-业务逻辑Bean-获取数据库数据封装到值型JavaBean-流程" class="headerlink" title="41.业务逻辑Bean(获取数据库数据封装到值型JavaBean)流程"></a>41.业务逻辑Bean(获取数据库数据封装到值型JavaBean)流程</h4><p>&nbsp;&nbsp; &nbsp; 1.定义JavaBean</p><pre><code class="java">public class User &#123;
    private int id;
    private String username;
    private String email;

    // 省略 getter 和 setter 方法
&#125;
</code></pre><p>&nbsp;&nbsp; &nbsp; 2.创建业务逻辑Bean</p><pre><code class="java">import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class UserBean &#123;
    // 获取数据库连接
    private Connection getConnection() throws SQLException &#123;
        // 实现获取数据库连接的逻辑，可以使用连接池等方式
        // 返回数据库连接对象
    &#125;
    // 查询所有用户信息
    public List&lt;User&gt; getAllUsers() &#123;
        List&lt;User&gt; userList = new ArrayList&lt;&gt;();
        try (Connection connection = getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(&quot;SELECT * FROM user&quot;);
             ResultSet resultSet = preparedStatement.executeQuery()) &#123;
             while (resultSet.next()) &#123;
                User user = new User();
                user.setId(resultSet.getInt(&quot;id&quot;));
                user.setUsername(resultSet.getString(&quot;username&quot;));
                user.setEmail(resultSet.getString(&quot;email&quot;));
                userList.add(user);
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace(); // 实际中应该进行异常处理
        &#125;
        return userList;
    &#125;
&#125;
</code></pre><h4 id="42-Servlet的生命周期"><a href="#42-Servlet的生命周期" class="headerlink" title="42.Servlet的生命周期"></a>42.Servlet的生命周期</h4><blockquote><p>1.用户通过客户端浏览器请求服务器，服务器加载Servlet，并创建一个Servlet实例.<br>2.容器调用Servlet的init()方法构造.<br>3.容器调用service()方法，并将HttpServletRequest和HttpServletResponse对象传递给该方法，在service()方法中处理用户请求.<br>4.在Servlet中请求处理结束后，将结果返回给容器.<br>5.容器将结果返回给客户端进行显示.<br>6.当Web服务器关闭时，调用destroy()方法销毁Servlet实例.</p></blockquote><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo6.png"><h4 id="43-web-xml中servlet配置的XML标记"><a href="#43-web-xml中servlet配置的XML标记" class="headerlink" title="43.web.xml中servlet配置的XML标记"></a>43.web.xml中servlet配置的XML标记</h4><pre><code class="java">&lt;servlet&gt;       //定义servlet  
    &lt;servlet-name&gt;EmpServlet&lt;/servlet-name&gt;		//servlet名称
    &lt;servlet-class&gt;cuit.emp.EmpServlet&lt;/servlet-class&gt; //servlet类
&lt;/servlet&gt;  
&lt;servlet-mapping&gt; 					//定义servlet映射
    &lt;servlet-name&gt;EmpServlet &lt;/servlet-name&gt;       //servlet名称
    &lt;url-pattern&gt; /servlet/EmpServlet &lt;/url-pattern&gt;     //servlet地址
&lt;/servlet-mapping&gt;
</code></pre><h4 id="44-Ajax代码异步请求方式"><a href="#44-Ajax代码异步请求方式" class="headerlink" title="44.Ajax代码异步请求方式"></a>44.Ajax代码异步请求方式</h4><p>传统派：</p><pre><code class="javascript">let s = document.getElementById(&quot;btn&quot;);
s.onclick = function()&#123;
    let xhr = new XMLHttpRequest();     //创建Ajax对象
    xhr.open(&quot;GET&quot;, url, true);         //设置属性
    xhr.send();         //提交请求
    xhr.onreadystatechange = function()&#123;    //接受返回内容
        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;
            
        &#125;
    &#125;
&#125;
</code></pre><p>维新派:</p><pre><code class="javascript">$.get(&quot;deal.jsp&quot;,
    &#123;name:&quot;无语&quot;,branch:&quot;java&quot;&#125;
);
$.post(&quot;deal.jsp&quot;,
    &#123;title:&quot;祝福&quot;,content:&quot;祝愿天下的所有母亲平安、健康…&quot;&#125;,
    function(data)&#123;
        alert(data);
    &#125;
);
</code></pre><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo8.png"><h4 id="45-服务器端servlet相应处理请求流程-获取表单参数、校验和提交、生成响应"><a href="#45-服务器端servlet相应处理请求流程-获取表单参数、校验和提交、生成响应" class="headerlink" title="45.服务器端servlet相应处理请求流程(获取表单参数、校验和提交、生成响应)"></a>45.服务器端servlet相应处理请求流程(获取表单参数、校验和提交、生成响应)</h4><blockquote><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo7.png"> &nbsp;&nbsp; &nbsp; 用户在客户端浏览器中发送请求至WEB服务器, WEB服务器调用实例servlet的service方法创建一个request和response对象, servlet从request中读取信息, 处理数据后将其写入response中封装, 由WEB服务器传回数据给客户端浏览器.</blockquote><h4 id="46-Ajax请求获取列表形式的JSON数据"><a href="#46-Ajax请求获取列表形式的JSON数据" class="headerlink" title="46.Ajax请求获取列表形式的JSON数据"></a>46.Ajax请求获取列表形式的JSON数据</h4><pre><code class="javascript">document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;
    var xhr = new XMLHttpRequest();     // 创建 XMLHttpRequest 对象
    xhr.open(&quot;GET&quot;, &quot;your_backend_endpoint&quot;, true);     // 配置请求
    xhr.responseType = &quot;json&quot;;     // 设置响应类型为 JSON
    xhr.onload = function () &#123;
        if (xhr.status === 200) &#123;             // 请求成功，处理返回的 JSON 数据
            var userList = xhr.response;
            renderUserList(userList);
        &#125; else &#123;
            console.error(&quot;Failed to fetch user data. Status code: &quot; + xhr.status);           // 请求失败，处理错误
        &#125;
    &#125;;
    xhr.onerror = function () &#123;     // 处理网络错误时的回调函数
        console.error(&quot;Network error occurred&quot;);
    &#125;;
    xhr.send();     //发送请求
&#125;);
function renderUserList(userList) &#123;
    var userListElement = document.getElementById(&quot;userList&quot;);
    userListElement.innerHTML = &quot;&quot;;
    // 遍历用户列表并添加到 HTML 中
    userList.forEach(function (user) &#123;
        var listItem = document.createElement(&quot;li&quot;);
        listItem.textContent = &quot;ID: &quot; + user.id + &quot;, Name: &quot; + user.name + &quot;, Email: &quot; + user.email;
        userListElement.appendChild(listItem);
    &#125;);
&#125;
</code></pre><h4 id="47-Spring-MVC是对Servlet的再封装"><a href="#47-Spring-MVC是对Servlet的再封装" class="headerlink" title="47.Spring MVC是对Servlet的再封装"></a>47.Spring MVC是对Servlet的再封装</h4><blockquote><p>正确. Spring MVC通过对Servlet进行封装,提供了更高级别的抽象,使得Web应用程序的开发更加简便和灵活.</p></blockquote><h4 id="48-Spring-MVC的工作原理"><a href="#48-Spring-MVC的工作原理" class="headerlink" title="48.Spring MVC的工作原理"></a>48.Spring MVC的工作原理</h4><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo9.png"><blockquote><p>1．客户端请求提交到DispatcherServlet.<br>2．由DispatcherServlet控制器寻找一个或多个HandlerMapping,找到处理请求的Controller.<br>3．DispatcherServlet将请求提交到Controller.<br>4．Controller调用业务逻辑处理后，返回ModelAndView.<br>5．DispatcherServlet寻找一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图.<br>6．视图负责将结果显示到客户端.</p></blockquote><h4 id="49-Spring容器管理的bean默认是单实例的"><a href="#49-Spring容器管理的bean默认是单实例的" class="headerlink" title="49.Spring容器管理的bean默认是单实例的"></a>49.Spring容器管理的bean默认是单实例的</h4><blockquote><p>正确. 应用程序启动时, Spring容器都会创建并初始化Bean, 每次请求该Bean时, 都会返回相同的实例.</p></blockquote><h4 id="50-Spring配置文件名是固定的"><a href="#50-Spring配置文件名是固定的" class="headerlink" title="50.Spring配置文件名是固定的"></a>50.Spring配置文件名是固定的</h4><blockquote><p>错误. 可以更改,最好固定.</p></blockquote><h4 id="51-Spring用标签定义对象时-标签中必须申明id"><a href="#51-Spring用标签定义对象时-标签中必须申明id" class="headerlink" title="51.Spring用标签定义对象时, 标签中必须申明id"></a>51.Spring用<bean>标签定义对象时,<bean>标签中必须申明id</bean></bean></h4><blockquote><p>错误. 不声明id时, Spring自动生成一个唯一的标识符.</p></blockquote><h4 id="52-Spring获取容器创建的对象的方法"><a href="#52-Spring获取容器创建的对象的方法" class="headerlink" title="52.Spring获取容器创建的对象的方法"></a>52.Spring获取容器创建的对象的方法</h4><blockquote><p>ApplicationContext接口 和 注解.</p></blockquote><h4 id="53-Spring-AOP的一个切入点可能横切多个业务组件。"><a href="#53-Spring-AOP的一个切入点可能横切多个业务组件。" class="headerlink" title="53.Spring AOP的一个切入点可能横切多个业务组件。"></a>53.Spring AOP的一个切入点可能横切多个业务组件。</h4><blockquote><p>正确.</p></blockquote><h4 id="54-Spring容器实现了I0C和AOP机制-这些机制可以简化Bean对象创建和Bean对象之间的解耦。"><a href="#54-Spring容器实现了I0C和AOP机制-这些机制可以简化Bean对象创建和Bean对象之间的解耦。" class="headerlink" title="54.Spring容器实现了I0C和AOP机制, 这些机制可以简化Bean对象创建和Bean对象之间的解耦。"></a>54.Spring容器实现了I0C和AOP机制, 这些机制可以简化Bean对象创建和Bean对象之间的解耦。</h4><blockquote><p>正确.</p></blockquote><h4 id="55-Autowired用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作，默认按照Bean的名称进行装配"><a href="#55-Autowired用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作，默认按照Bean的名称进行装配" class="headerlink" title="55.@Autowired用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作，默认按照Bean的名称进行装配"></a>55.@Autowired用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作，默认按照Bean的名称进行装配</h4><blockquote><p>正确.</p></blockquote><h4 id="56-Hibernate和MyBatis均是全自动映射的框架"><a href="#56-Hibernate和MyBatis均是全自动映射的框架" class="headerlink" title="56.Hibernate和MyBatis均是全自动映射的框架"></a>56.Hibernate和MyBatis均是全自动映射的框架</h4><blockquote><p>错误. Mybatis是半自动映射框架.</p></blockquote><h4 id="57-Hibernate和MyBatis都可以自动生成SQL"><a href="#57-Hibernate和MyBatis都可以自动生成SQL" class="headerlink" title="57.Hibernate和MyBatis都可以自动生成SQL"></a>57.Hibernate和MyBatis都可以自动生成SQL</h4><blockquote><p>错误. Mybatis不能.</p></blockquote><h4 id="58-应用在Web应用中的数据库系统有哪些"><a href="#58-应用在Web应用中的数据库系统有哪些" class="headerlink" title="58.应用在Web应用中的数据库系统有哪些"></a>58.应用在Web应用中的数据库系统有哪些</h4><blockquote><p>MySQL、PostgreSQL、Oracle、Redis、Microsoft SQL Server等.</p></blockquote><h4 id="59-使用MyBatis框架-一般需要先建立与数据库表对应的实体类。"><a href="#59-使用MyBatis框架-一般需要先建立与数据库表对应的实体类。" class="headerlink" title="59.使用MyBatis框架,一般需要先建立与数据库表对应的实体类。"></a>59.使用MyBatis框架,一般需要先建立与数据库表对应的实体类。</h4><blockquote><p>正确.</p></blockquote><h4 id="60-MyBatis和Hibernate是目前流行的ORM框架"><a href="#60-MyBatis和Hibernate是目前流行的ORM框架" class="headerlink" title="60.MyBatis和Hibernate是目前流行的ORM框架."></a>60.MyBatis和Hibernate是目前流行的ORM框架.</h4><blockquote><p>正确.</p></blockquote><h4 id="61-MyBatis-的程序里最终使用的对象"><a href="#61-MyBatis-的程序里最终使用的对象" class="headerlink" title="61.MyBatis 的程序里最终使用的对象"></a>61.MyBatis 的程序里最终使用的对象</h4><blockquote><p>数据库表对应的 Java 对象(实体类、POJO).</p></blockquote><h4 id="62-MyBatis工作流程或主要步骤"><a href="#62-MyBatis工作流程或主要步骤" class="headerlink" title="62.MyBatis工作流程或主要步骤"></a>62.MyBatis工作流程或主要步骤</h4><img src="/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/photo10.png"><blockquote><p>1．读取MyBatis配置文件mybatis-config.xml, 该文件配置了MyBatis的运行环境等信息.<br>2．加载SQL映射文件, 文件中配置了操作数据库的SQL语句, 需要在mybatis-config.xml中加载, 可以加载多个映射文件.<br>3．构建会话工厂SqlSessionFactory.<br>4．创建SqlSession对象, 该对象中包含执行SQL语句的所有方法.<br>5．使用Executor接口来操作数据库, 根据SqlSession传递的参数动态地生成需要执行的SQL语句,同时负责查询缓存的维护.<br>6．在Executor接口的执行方法中有MappedStatement类型参数, 该参数是对映射信息的封装, 用于存储要映射的SQL语句的id、参数等信息.<br>7．输入参数映射. 输入参数类型可以是Map、List等集合类型,也可以是基本数据类型和POJO类型, 输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程.<br>8．输出结果映射. 输出结果类型可以是Map、List等集合类型,也可以是基本数据类型和POJO类型, 输出结果映射过程类似于JDBC对结果集的解析过程.</p></blockquote><h4 id="63-MyBatis映射文件中的常用元素及其作用"><a href="#63-MyBatis映射文件中的常用元素及其作用" class="headerlink" title="63.MyBatis映射文件中的常用元素及其作用"></a>63.MyBatis映射文件中的常用元素及其作用</h4><p>select</p><pre><code class="xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM users WHERE id = #&#123;id&#125;
&lt;/select&gt;
</code></pre><p>insert</p><pre><code class="xml">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;
    INSERT INTO users (username, password) VALUES (#&#123;username&#125;, #&#123;password&#125;)
&lt;/insert&gt;
</code></pre><p>update</p><pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;
    UPDATE users SET username = #&#123;username&#125;, password = #&#123;password&#125; WHERE id = #&#123;id&#125;
&lt;/update&gt;
</code></pre><p>delete</p><pre><code class="xml">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    DELETE FROM users WHERE id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre><p>resultMap</p><pre><code class="xml">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
    &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
    &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt;
&lt;/resultMap&gt;
</code></pre><h4 id="64-MyBatis中动态SQL的常用元素及其作用"><a href="#64-MyBatis中动态SQL的常用元素及其作用" class="headerlink" title="64.MyBatis中动态SQL的常用元素及其作用"></a>64.MyBatis中动态SQL的常用元素及其作用</h4><p>if元素: 判断</p><pre><code class="xml">&lt;select id=&quot;getUsers&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM users
    &lt;where&gt;
        &lt;if test=&quot;username != null&quot;&gt;
            AND username = #&#123;username&#125;
        &lt;/if&gt;
        &lt;if test=&quot;email != null&quot;&gt;
            AND email = #&#123;email&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre><p>choose、when、otherwise: switch</p><pre><code class="xml">&lt;select id=&quot;getUsers&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM users
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;username != null&quot;&gt;
                AND username = #&#123;username&#125;
            &lt;/when&gt;
            &lt;when test=&quot;email != null&quot;&gt;
                AND email = #&#123;email&#125;
            &lt;/when&gt;
            &lt;otherwise&gt;
                AND status = &#39;ACTIVE&#39;
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre><p>trim、set: 修剪</p><pre><code class="xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;
    UPDATE users
    &lt;set&gt;
        &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;
        &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;
    &lt;/set&gt;
    WHERE id = #&#123;id&#125;
&lt;/update&gt;
</code></pre><p>foreach: 迭代</p><pre><code class="xml">&lt;select id=&quot;getUsersByIdList&quot; parameterType=&quot;list&quot; resultType=&quot;User&quot;&gt;
    SELECT * FROM users
    WHERE id IN
    &lt;foreach collection=&quot;idList&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
        #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/select&gt;
</code></pre><p>blind: 定义变量</p><pre><code class="xml">&lt;select id=&quot;getUsersByNameAndAge&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt;
    &lt;bind name=&quot;nameCondition&quot; value=&quot;&#39;%&#39; + name + &#39;%&#39;&quot;/&gt;
    SELECT * FROM users
    WHERE name LIKE #&#123;nameCondition&#125;
    AND age = #&#123;age&#125;
&lt;/select&gt;
</code></pre><h4 id="65-Spring中的通知按照在目标类方法的连接点位置-分为5种通知"><a href="#65-Spring中的通知按照在目标类方法的连接点位置-分为5种通知" class="headerlink" title="65.Spring中的通知按照在目标类方法的连接点位置,分为5种通知"></a>65.Spring中的通知按照在目标类方法的连接点位置,分为5种通知</h4><blockquote><p>环绕通知: 在目标方法执行前和执行后实施增强.<br>前置通知: 在目标方法执行前实施增强.<br>后置返回通知: 在目标方法成功执行后实施增强.<br>最终通知: 不管是否发生异常, 在目标方法执行后实施增强.<br>异常通知: 在方法抛出异常后实施增强.</p></blockquote><h4 id="66-Hibernate和MyBatis和JDBC各自特点和优势"><a href="#66-Hibernate和MyBatis和JDBC各自特点和优势" class="headerlink" title="66.Hibernate和MyBatis和JDBC各自特点和优势"></a>66.Hibernate和MyBatis和JDBC各自特点和优势</h4><blockquote><p>JDBC: 简单直接,适用于小型项目或者需要直接控制数据库操作的场景, 基于标准化, 可以与任何支持JDBC的数据库进行交互.<br>Hibernate: ORM框架, 不需要编写SQL语句.<br>Mybatis: 使用连接池管理, 提供了更多的抽象和方便的映射, 基于XML配置的持久化框架,将Java对象映射到数据库中的SQL语句.</p></blockquote><h4 id="67-JSP、Servlet、SpringMVC各自优势"><a href="#67-JSP、Servlet、SpringMVC各自优势" class="headerlink" title="67.JSP、Servlet、SpringMVC各自优势"></a>67.JSP、Servlet、SpringMVC各自优势</h4><blockquote><p>JSP: 使用标记语言, 在HTML中嵌入Java代码, 易于上手; 将Java代码与HTML结合, 实现前端和后端的紧密集合, 开发网页相对简单; 通常用于表示视图层, 与Servlet结合使用.<br>Servlet: 控制强大, 可以处理请求、响应、会话管理等功能; 编写Java代码处理HTTP请求和响应, 具有强大的灵活性; 适用于处理业务逻辑, 实现底层逻辑控制.<br>SpringMVC: 模块化和松耦合, 通过使用MVC架构, 将应用程序分为模型、视图和控制器, 实现了更好的松耦合; 支持AOP, 允许开发人员通过切面处理横切关注点; 拥有强大的配置, 允许使用注解或XML配置定义映射、拦截器等; 与SpringBoot等整合, 提供了更全面的解决方案.</p></blockquote><h4 id="68-Spring框架的优势和特点"><a href="#68-Spring框架的优势和特点" class="headerlink" title="68.Spring框架的优势和特点"></a>68.Spring框架的优势和特点</h4><blockquote><p>轻量级和非侵入性:<br>Spring是一个轻量级的框架,不需要大量的配置信息,使得开发更加简单;不需要继承特定的类或实现特定的接口,可以与其他框架和应用程序集成.<br>依赖注入:<br>提供了依赖注入机制,通过IoC容器管理对象的依赖关系,降低了组件之间的耦合度, 对象的创建和组装由Spring容器负责,提高了代码的可维护性和可测试性.<br>面向切面编程:<br>支持AOP,允许通过切面在应用程序中横切关注点,如事务管理、日志记录等. 可以将横切关注点从核心业务逻辑中分离,提高了代码的模块化和可重用性.<br>模块化设计: Spring采用了模块化的设计,各个模块提供不同的功能,如数据访问、事务管理、消息传递. 可以选择性地使用这些模块，根据项目需求进行集成.<br>数据访问抽象层： 提供了一致的数据访问抽象层,支持多种数据访问技术,如JDBC、Hibernate、JPA等.简化了数据访问代码的编写，提高了灵活性.<br>事务管理: 支持声明式事务管理,通过注解或XML配置,简化了事务的控制. 提供了编程式事务管理的方式,允许更细粒度的控制事务.<br>灵活配置： 支持多种配置方式,包括XML配置、注解配置、Java配置等.</p></blockquote></div><div id="comment"><div id="giscus-container" class="giscus"></div></div></div><footer id="footer"><div id="footer-wrap"><div>&copy; 2023 - 2024 Bin&#39;s blog <span id="footer-icon"><i class="fa-solid fa-font-awesome fa-fw"></i> </span>&commat;Binbin</div><div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a></div></div></footer></div><transition name="fade"><div id="preview" ref="preview" v-show="previewShow"><img id="preview-content" ref="previewContent"></div></transition></div><script src="/js/main.js"></script><script src="https://giscus.app/client.js" data-repo="Sakb1n/Review" data-repo-id="R_kgDOLDDvkw" data-category="Announcements" data-category-id="DIC_kwDOLDDvk84CjKqj" data-mapping="title" data-strict="0" data-reactions-enabled="top" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin async></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/z16.model.json"},display:{position:"right",width:150,height:300,hOffset:-15,vOffset:-15},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>