{"meta":{"title":"Bin's blog","subtitle":"","description":"小彬彬的博客","author":"Binbin","url":"https://sakb1n.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2023-10-01T13:00:23.000Z","updated":"2023-10-08T06:28:53.169Z","comments":true,"path":"about/index.html","permalink":"https://sakb1n.github.io/about/index.html","excerpt":"","text":"这是我的简介 The supreme happiness of life is the conviction that we are loved. 帐号 网站 帐号 QQ 648005280 GitHub Sakbin 洛谷 Sakbin Florr.io Noooooob"},{"title":"categories","date":"2023-10-07T04:57:20.000Z","updated":"2023-10-08T06:10:49.265Z","comments":true,"path":"categories/index.html","permalink":"https://sakb1n.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-10-07T04:57:42.000Z","updated":"2023-10-07T04:57:42.641Z","comments":true,"path":"tags/index.html","permalink":"https://sakb1n.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Recollection--DFS","slug":"Recollection-DFS","date":"2023-11-25T13:28:21.000Z","updated":"2023-11-27T15:51:39.096Z","comments":true,"path":"2023/11/25/Recollection-DFS/","link":"","permalink":"https://sakb1n.github.io/2023/11/25/Recollection-DFS/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近在学javaweb, 把自己博客给忘得差不多了，于是水篇文章证明我还活着() DFS(深度优先搜索)概述&nbsp;&nbsp;&nbsp;&nbsp;深度优先搜索 (Depth-first-search) 是一种图的算法, 以深度作为方向进行搜索,找到所需要的答案, 直到所有方案搜索完为止，其本质依然是暴力。 &nbsp;&nbsp;&nbsp;&nbsp;走入迷宫, 向一条路径一直走下去直到走到死路为止, 再回返到最近的一个路口走另一条没有走过的路，依次类推…&nbsp;&nbsp;&nbsp;&nbsp;实现dfs的核心是标记与回溯。","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近在学javaweb, 把自己博客给忘得差不多了，于是水篇文章证明我还活着() DFS(深度优先搜索)概述&nbsp;&nbsp;&nbsp;&nbsp;深度优先搜索 (Depth-first-search) 是一种图的算法, 以深度作为方向进行搜索,找到所需要的答案, 直到所有方案搜索完为止，其本质依然是暴力。 &nbsp;&nbsp;&nbsp;&nbsp;走入迷宫, 向一条路径一直走下去直到走到死路为止, 再回返到最近的一个路口走另一条没有走过的路，依次类推…&nbsp;&nbsp;&nbsp;&nbsp;实现dfs的核心是标记与回溯。 模版 void dfs(int x)&#123; if(满足停止搜索条件)&#123; ... //处理 return; &#125; for (int i = 0; i &lt; length; i++)&#123; if (没有搜过该点)&#123; vis[x] = 1; //标记搜过 dfs(x + 1); //递归 vis[x] = 0; //取消标记(回溯) &#125; &#125; &#125; dfs变化多样,不一定就要照着模版写。 题目尝试 C语言新手, 请多多指教。 CF6A Triangle &nbsp;&nbsp;&nbsp;&nbsp;这是一道入门题, 数据少也不卡时间, 可以直接通过暴力枚举得到结果简单方便, 但还是用dfs来练练手() &nbsp;&nbsp;&nbsp;&nbsp;我们可以先将所有木棍从小到大排序,当我们任意取出3根木棍时，这3根木棍的长度一定是有序的,判断三角形时只需要将1、2号木棍与3号木棍长度进行比较即可。 AC代码: #include&lt;stdio.h&gt; #include&lt;bits/stdc++.h&gt; using namespace std; //直接调用C++的sort排序，懒得写排序了。 //arr进行数据读入，arr1放入需判断的三根木棍, con代表状态。 int arr[4], arr1[4], i, con = 0; void dfs(int cur, int w)//cur代表已读入木棍数，该值等于3则开始判断三角形情况。 &#123; if (cur == 3) &#123; //大于为三角形，等于为退化三角形 if(arr1[0] + arr1[1] &gt; arr1[2]) &#123; con = 1; &#125; else if (con == 0 &amp;&amp; arr1[0] + arr1[1] == arr1[2]) //为什么要判断con==0呢 &#123; con = 2; &#125; &#125; else &#123; /* w表示当前搜索到的位置 我们从头开始理,最开始主程序调用dfs时: 1.w = 0, cur = 0, 会进入到这里，j = 0开始循环, arr1放入0号元素, 递归; 2.w = 1, cur = 1, 依然进入到这里, j = 1开始循环, arr1放入1号元素, 递归; 3.w = 2, cur = 2, 依然进入到这里, j = 2开始循环, arr1放入2号元素, 递归; 4.cur = 3, 判断条件，这里结束后将返回到第3步; 5.第3步此时位于j = 2的循环中，dfs结束后，j++后变为3, arr1将不再放入2号元素而是放入3号元素，递归; 6.cur = 3, 判断条件，这里结束后将返回到第3步; 7.第3步到达循环末尾，再回到第2步,第2步j++后变为2,取3号元素，以此类推... 8.你应该能理解为什么要写循环了。 */ for (int j = w; j &lt; 4; j++) &#123; arr1[cur] = arr[j]; //放入arr1数组 dfs(cur + 1, j + 1); //当前数量+1并递归搜索 &#125; &#125; &#125; int main(void) &#123; for (i = 0; i &lt; 4; i++) &#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; sort(arr, arr + 4); //快排 dfs(0,0); //dfs开始搜索 if (con == 1) &#123; printf(&quot;TRIANGLE&quot;); &#125; else if (con == 0) &#123; printf(&quot;IMPOSSIBLE&quot;); &#125; else &#123; printf(&quot;SEGMENT&quot;); &#125; &#125; CF629A Far Relative’s Birthday Cake &nbsp;&nbsp;&nbsp;&nbsp;解释解释到底说了什么：只要在一行或一列上找到一对CC,就得到一点幸福指数，求总幸福指数。 &nbsp;&nbsp;&nbsp;&nbsp;我们使用dfs进行搜索时带上一个数组arr1,用它来标记是否搜索过该元素,递归完成后取消标记,这就是标记与回溯。 AC代码: #include&lt;stdio.h&gt; const int MAX = 110; int n, arr[MAX][MAX] = &#123;0&#125;, arr1[MAX][MAX], count = 0, i, j; void dfs(int a, int b)&#123; //判断条件:x轴上的b小于n或y轴上的a小于n if ((a == i &amp;&amp; b &lt; n) || (b == j &amp;&amp; a &lt; n)) &#123; if (arr[a][b] == 1 &amp;&amp; arr1[a][b] != 1) &#123; //标记解 count++; &#125; //往下和右递归调用 dfs(a+1, b); dfs(a,b+1); &#125; &#125; int main(void) &#123; //读入,将str数组转化为arr数组 scanf(&quot;%d\\n&quot;, &amp;n); for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; n; j++) &#123; char temp; scanf(&quot;%c&quot;, &amp;temp); if (temp == &#39;C&#39;) &#123; arr[i][j] = 1; &#125; else if (temp == &#39;.&#39;)&#123; arr[i][j] = 0; &#125; &#125; if (i != n - 1) &#123; scanf(&quot;\\n&quot;); &#125; &#125; //只是把dfs的循环拿出来用了，原理一致。 for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; n; j++) &#123; if (arr[i][j] == 1) &#123; //标记与回溯 arr1[i][j] = 1; dfs(i, j); arr1[i][j] = 0; &#125; &#125; &#125; printf(&quot;%d&quot;, count); &#125; P1706 全排列问题 &nbsp;&nbsp;&nbsp;&nbsp;经典题,与上题思想一致,使用dfs深度搜索,用另一个数组去标记是否搜索过该数。 &nbsp;&nbsp;&nbsp;&nbsp;与第一道题不同, 我们所搜索的元素只可能在当前位置之后, 所以直接从当前位置循环, 而此题的排列没有任何顺序可言,我们从数组中遍历没有被标记的元素来作为下一个应该排的位置,所以区别还是挺大的() AC代码: #include&lt;stdio.h&gt; int a[10], v[10], n; void dfs(int t)&#123; if (t == n + 1) &#123; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot; %d&quot;, a[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(v[i] != 1) &#123; v[i] = 1; a[t] = i; dfs(t + 1); v[i] = 0; &#125; &#125; &#125; int main(void) &#123; scanf(&quot;%d&quot;, &amp;n); dfs(1); &#125; P1451 求细胞数量 &nbsp;&nbsp;&nbsp;&nbsp;连通块问题,只要连通的区域统统都算1个,直接dfs,将要搜索的设为1,dfs搜索到的区域统统变为0,注意递归时是朝东南西北四个方向进行搜索, 当触碰到边界时停止搜索。 AC代码: #include&lt;stdio.h&gt; const int MAX = 110; int m, n; int arr[MAX][MAX]; int count = 0; //方向数组,分别对应东南西北。 int dx[4] = &#123;0,0,1,-1&#125;; int dy[4] = &#123;1,-1,0,0&#125;; void dfs(int a, int b) &#123; arr[a][b] = 0; for (int i = 0; i &lt; 4; i++) &#123; a += dx[i]; b += dy[i]; //判断搜索条件 if (a &lt;= m &amp;&amp; a &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; arr[a][b] == 1) &#123; dfs(a, b); &#125; a -= dx[i]; b -= dy[i]; &#125; &#125; int main(void) &#123; scanf(&quot;%d%d\\n&quot;,&amp;m,&amp;n); char temp; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf(&quot;%c&quot;, &amp;temp); if (temp &lt;= &#39;9&#39; &amp;&amp; temp &gt; &#39;0&#39;) &#123; arr[i][j] = 1; &#125; else &#123; arr[i][j] = 0; &#125; &#125; if (i != m) &#123; scanf(&quot;\\n&quot;); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (arr[i][j] == 1) &#123; dfs(i, j); //得到其一解 ++count; &#125; &#125; &#125; printf(&quot;%d&quot;, count); &#125; P1506 拯救oibh总部 &nbsp;&nbsp;&nbsp;&nbsp;如果你依然想套用上一题并信心满满的提交时,你会收到全WA的惊喜(我也一样233) &nbsp;&nbsp;&nbsp;&nbsp;其实我们可以在最外围搜一圈,凡是被洪水淹没的地段都设为1,最后循环查找没被淹没的地方(值为0的地方)就行了() AC代码: #include&lt;stdio.h&gt; const int MAX = 510; int arr[MAX][MAX], m, n, count = 0; //方向数组 int ax[4] = &#123;0, 0, 1, -1&#125;; int ay[4] = &#123;1, -1, 0, 0&#125;; void dfs(int x, int y) &#123; int x1, y1; arr[x][y] = 1; for (int i = 0; i &lt; 4; i++) &#123; x1 = x + ax[i]; y1 = y + ay[i]; if (x1 &gt;= 0 &amp;&amp; x1 &lt; n &amp;&amp; y1 &gt;=0 &amp;&amp; y1 &lt; m &amp;&amp; arr[x1][y1] == 0) &#123; dfs(x1, y1); &#125; &#125; &#125; int main(void) &#123; //读入 scanf(&quot;%d%d\\n&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; char temp; scanf(&quot;%c&quot;, &amp;temp); if (temp == &#39;0&#39;) &#123; arr[i][j] = 0; &#125; else&#123; arr[i][j] = 1; &#125; &#125; if (i != n - 1) &#123; scanf(&quot;\\n&quot;); &#125; &#125; //在最外面一圈进行搜索 for (int i = 0; i &lt; m; i++) &#123; if (arr[0][i] == 0) &#123; dfs(0, i); &#125; if (arr[n - 1][i] == 0) &#123; dfs(n - 1, i); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (arr[i][0] == 0) &#123; dfs(i, 0); &#125; if (arr[i][m - 1] == 0) &#123; dfs(i, m - 1); &#125; &#125; //统计没有被淹没的地段 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (arr[i][j] == 0) &#123; count++; &#125; &#125; &#125; printf(&quot;%d&quot;, count); &#125; P1036 [NOIP2002 普及组] 选数 &nbsp;&nbsp;&nbsp;&nbsp;此题跟其他dfs题如出一辙,可以说照着模版写就是了,唯一可能卡的点是判断是否为质数: int prime(int sum) &#123; for (int i = 2; i * i &lt;= sum; i++) &#123; if (sum % i == 0) &#123; return 0; &#125; &#125; return 1; &#125; dfs部分不作展示。 [USACO10OCT] Lake Counting S &nbsp;&nbsp;&nbsp;&nbsp;也是一般dfs思路,唯一不同的地方在于为八个方向,只需要将方向数组修改就行了。 //东、东南、南、西南、西、西北、北、东北 int ax[9] = &#123;0, 0, 1, 1, 1, 0, -1, -1, -1&#125;; int ay[9] = &#123;0, 1, 1, 0, -1, -1, -1, 0, 1&#125;; dfs部分不作展示。 [USACO1.5] 八皇后 Checker Challenge &nbsp;&nbsp;&nbsp;&nbsp;喜欢我八皇后吗,说实话,真的没一点思路。 &nbsp;&nbsp;&nbsp;&nbsp;在这个棋盘上,行列对角线上只能存在一个棋子,我写了点。 AC代码: #include&lt;stdio.h&gt; #include&lt;math.h&gt; //分别对应行,主对角线,副对角线,答案数组。 int col[14], d1[30], d2[50], ans[14]; int n, w = 0; void dfs(int x) &#123; if (x &gt; n) &#123; //题只要求输出前3种情况,所以w&lt;3,随后只让解的个数增加 if (w &lt; 3) &#123; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d &quot;, ans[i]); &#125; printf(&quot;\\n&quot;); &#125; w++; &#125; else &#123; for (int k = 1; k &lt;= n; k++) &#123; //平行的主对角线满足该特征:它们的行与列之差固定,但可能为负值,故再加上一个n。 int z = x + k - 1; //平行的副对角线满足该特征:它们的行与列之和固定。 int t = x - k + n; if (!col[k] &amp;&amp; !d1[z] &amp;&amp; !d2[t]) &#123; ans[x] = k;col[k] = 1;d1[z] = 1;d2[t] = 1; dfs(x + 1); col[k] = 0;d1[z] = 0;d2[t] = 0; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(&quot;%d&quot;, &amp;n); dfs(1); printf(&quot;%d&quot;, w); &#125; P1189 SEARCH &nbsp;&nbsp;&nbsp;&nbsp;这个题的意思是给你一个初始地与N个方向,N个方向都要按顺序使用,寻找到它最终的落脚点,这题DFS和BFS都可以用 &nbsp;&nbsp;&nbsp;&nbsp;参考：dingcx:P1189 SEARCH&nbsp;&nbsp;&nbsp;&nbsp;考虑直接使用dfs会超时,我们选择优化,因为在dfs搜索过程中会出现多条路都通向一个节点的情况,我们在标记数组中加入方向长度减少这种情况,就进行优化,详细请读一读上面这篇文章~ AC代码: #include&lt;stdio.h&gt; const int MAX = 55; const int MAXN = 1010; int m, n, arr[MAX][MAX], arr1[MAXN][MAX][MAX], stx, sty, N, dir[MAXN]; int f[5][2] = &#123;0,0,0,1,1,0,0,-1,-1,0&#125;; void dfs(int len, int x, int y) &#123; if (arr1[len][x][y] == 1) &#123; return; &#125; else &#123; int x1 = x, y1 = y; arr1[len][x][y] = 1; if (len == 0) &#123; return; &#125; while (1) &#123; x1 += f[dir[len]][0]; y1 += f[dir[len]][1]; if (arr[x1][y1] == 1 || x1 &lt; 0 || x1 &gt;= m || y1 &lt; 0 || y1 &gt;= n) &#123; break; &#125; dfs(len - 1, x1, y1); &#125; &#125; &#125; int main(void) &#123; scanf(&quot;%d%d\\n&quot;, &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; char temp; scanf(&quot;%c&quot;, &amp;temp); if (temp == &#39;X&#39;) &#123; arr[i][j] = 1; &#125; else if (temp == &#39;.&#39;) &#123; arr[i][j] = 0; &#125; else&#123; stx = i; sty = j; arr[i][j] = 0; &#125; &#125; if (i != m - 1) &#123; scanf(&quot;\\n&quot;); &#125; &#125; scanf(&quot;%d\\n&quot;, &amp;N); for (int i = 1; i &lt;= N; i++) &#123; char str[10]; scanf(&quot;%s&quot;, str); if (str[0] == &#39;E&#39;) &#123; dir[N + 1 - i] = 1; &#125; else if (str[0] == &#39;S&#39;) &#123; dir[N + 1 - i] = 2; &#125; else if (str[0] == &#39;W&#39;) &#123; dir[N + 1 - i] = 3; &#125; else if (str[0] == &#39;N&#39;) &#123; dir[N + 1 - i] = 4; &#125; &#125; dfs(N, stx, sty); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (arr1[0][i][j] == 1) &#123; printf(&quot;*&quot;); &#125; else if (arr[i][j] == 0) &#123; printf(&quot;.&quot;); &#125; else&#123; printf(&quot;X&quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; &#125; 春空舞う花びらは，過ぎ去った奇跡じゃなく，巡った季節を超えても輝いて，二人の未来を彩るよ。","categories":[{"name":"算法","slug":"算法","permalink":"https://sakb1n.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法,杂谈,学习","slug":"算法-杂谈-学习","permalink":"https://sakb1n.github.io/tags/%E7%AE%97%E6%B3%95-%E6%9D%82%E8%B0%88-%E5%AD%A6%E4%B9%A0/"}]},{"title":"CSS学习","slug":"CSS学习","date":"2023-10-26T03:27:14.000Z","updated":"2023-10-31T03:44:14.829Z","comments":true,"path":"2023/10/26/CSS学习/","link":"","permalink":"https://sakb1n.github.io/2023/10/26/CSS%E5%AD%A6%E4%B9%A0/","excerpt":"CSS第一步CSS起步​ 1.link:&lt;link rel = &quot;stylesheet&quot; href=&quot;styles.css&quot;/&gt;​ 2.列表移除符号:list-style-type:none;​ 3.使用类名规范样式：CSS里写 .XXX​ 4.元素选择器可以与类名一起出现​ 5.包含选择符","text":"CSS第一步CSS起步​ 1.link:&lt;link rel = &quot;stylesheet&quot; href=&quot;styles.css&quot;/&gt;​ 2.列表移除符号:list-style-type:none;​ 3.使用类名规范样式：CSS里写 .XXX​ 4.元素选择器可以与类名一起出现​ 5.包含选择符 ​ 例： li em &#123; color: rebeccapurple; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将选择&lt;li&gt;内部的任何&lt;em&gt;元素（&lt;li&gt;的后代） ​ 相邻选择符 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置出现在标题后面并且与标题具有相同层级的段落样式， h1 + p &#123; font-size: 200%; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.根据标签状态确定样式 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 CSS对不同状态进行修饰 a:link &#123; //未访问链接 color: pink; &#125; a:visited &#123; //已访问链接 color: green; &#125; a:hover &#123; //鼠标悬停时 text-decoration: none; //移除下划线 &#125; CSS的组成​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS 应用于文档:外部(最常用)、内部(在head部分加入style)、内联（尽可能避免） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS用&#x2F;* *&#x2F;进行注释 选择器优先级​ 也叫层叠。 后面样式会替换较早样式 类选择器&gt;元素选择器 属性和值​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; font-size 设置字体大小 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width 设置元素宽度(默认设置内容区域的宽度) ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-color 设置元素背景色 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color 设置文本颜色 **`border`** 设置边界属性 可设置： border-width（设置边框宽度） border-style border-color /* width | style | color */ border: medium dashed green; 函数​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calc() 进行计算 .box &#123; width: calc(90% - 30px); &#125; transform函数，允许旋转，缩放，倾斜或平移指定元素，如rotate() .box &#123; transform: rotate(0.8turn); &#125; CSS如何运行浏览加载网页 载入 HTML 文件。 HTML 文件转化成DOM(文件在计算机内存中的表现形式) 拉取该 HTML 相关的大部分资源，(图片、视频和 CSS 样式)。JavaScript 则会稍后进行处理 拉取并解析，根据选择器的不同类型分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。 网页展示在屏幕上（这一步被称为着色）。 DOM​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 DOM 对应一个树形结构，标记语言中的每一个元素、属性、文字对应结构树中的一个节点。 CSS基础CSS选择器选择器列表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多个使用相同样式的 CSS 选择器，则可以被混编为一个“选择器列表” h1 &#123; color: blue; &#125; .special &#123; color: blue; &#125; 可以被合并为 h1, .special &#123; color: blue; &#125; 选择器种类类型、类与ID选择器h1 &#123; //类型选择器 &#125; .box &#123; //类选择器 &#125; #unique &#123; //id选择器 &#125; 标签属性选择器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一个元素上的某个标签的属性的存在以选择元素的不同方式 a[title] &#123; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一个有特定值的标签属性是否存在来选择 a[href=&quot;https://example.com&quot;]&#123; &#125; 伪类与伪元素​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伪类：用于样式化一个元素的特定状态 a:hover &#123; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以包含伪元素，选择元素的某个部分 p::first-line &#123; //选择一个元素的第一行 &#125; 运算符​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其他选择器组合起来，更复杂的选择元素 article &gt; p &#123; //选择&lt;article&gt;元素的初代子元素 &#125; 类型、类和ID选择器全局选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个*，选择了文档中的所有内容。 * &#123; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全局选择器能让选择器更易读，如： article :first-child &#123; //选取&lt;article&gt;元素中第一子元素 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易写成article:first-child，于是可以改成article *:first-child 类选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用时只需要在指定元素里加入class&#x3D;“ ”即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;避免复用，可以在类选择器前加入特定元素使其改变特定元素，如span.highlight, h1.highlight等。 多个类被应用的时候指向一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不太理解这个东西 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.notebox、.notebox.warning、.notebox.danger 知道可以这样用就行了() ID选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id选择器开头为#，用法与类选择器一致。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，一个ID只会用到一次。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在ID前面加上类型选择器 #one &#123; //id选择器 background-color: yellow; &#125; h1#heading &#123; //在id选择器前加上类型选择器 color: rebeccapurple; &#125; 属性选择器存否和值选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于一个元素自身是否存在或 各式不同的按属性值的匹配 来选取元素 选择器 示例 描述 [attr] a[title] 匹配带有一个名为attr的属性的元素 [attr&#x3D;value] 匹配带有一个名为attr的属性的元素 匹配带有一个名为attr的属性的元素，其值正为value [attr~&#x3D;value] p[class~&#x3D;”special”] 匹配带有一个名为attr的属性的元素，其值正为value，或者其值有一个或者更多，而至少有一个和value匹配。 [*attr|&#x3D;*value] div[lang|&#x3D;”zh”] 匹配带有一个名为attr的属性的元素，其值可正为value，或者开始为value，后面紧随着一个连字符。(?) 子字符串匹配选择器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有box-warning和box-error类，想把开头为“box-”字符串的每个物件都匹配上的话，你可以用[class^=&quot;box-&quot;]来把它们两个都选中。 ​ 选择器 示例 描述 [attr^&#x3D;value] li[class^&#x3D;”box-“] 匹配带有一个名为attr的属性的元素，其值开头为value子字符串。 [attr$&#x3D;value] li[class$&#x3D;”-box”] 匹配带有一个名为attr的属性的元素，其值结尾为value子字符串 [attr*&#x3D;value] li[class*&#x3D;”box”] 匹配带有一个名为attr的属性的元素，其值的字符串中的任何地方，至少出现了一次value子字符串。 大小写敏感​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要在大小写不敏感的情况下匹配属性值，在闭合括号之前，使用i值。 li[class^=&quot;a&quot; i] &#123; color: red; &#125; 伪类和伪元素​ 用于选择处于特定状态的元素。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:first-child能选中第一个子元素。 用户行为伪类​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只会在用户以某种方式和文档交互的时候应用。用户行为伪类有时叫做动态伪类。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前用过的a:hover, a:visited 都算。 伪元素是神魔​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像在标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。 ::pseudo-element-name ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想选中一段的第一行，使用伪元素可以只选中第一行 article p::first-line &#123; font-size: 120%; font-weight: bold; &#125; 把伪类和伪元素组合起来（太难了）​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让第一段的第一行加粗，需要把:first-child和::first-line选择器放到一起 article p:first-child::first-line &#123; font-size: 120%; font-weight: bold; &#125; 生成带有::before 和::after 的内容（个人觉得没必要）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考伪类与伪元素：伪类和伪元素 - 学习 Web 开发 | MDN (mozilla.org) 关系选择器后代选择器body article p 子代关系选择器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。 article &gt; p //只选中作为&lt;article&gt;的直接子元素的&lt;p&gt;元素 ​ ul &gt; li &#123; //如果你移去指定子代选择器的`&gt;`的话，你最后得到的是后代选择器，所有的`&lt;li&gt;`会有 //个红色的边框。 border-top: 5px solid red; &#125; &lt;ul&gt; &lt;li&gt;Unordered item&lt;/li&gt; &lt;li&gt;Unordered item &lt;ol&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; 邻接兄弟选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来选中恰好处于另一个在继承关系上同级的元素旁边的物件 p + img //选中所有紧随&lt;p&gt;元素之后的&lt;img&gt;元素 通用兄弟选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选中一个元素的兄弟元素但不直接相邻 p ~ img //选中所有的&lt;p&gt;元素后任何地方的&lt;img&gt;元素 层叠与继承CSS ：层叠样式表 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当两条同级别的规则应用到一个元素时，写在后面的会被使用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器根据优先级决定当不同选择器对应相同的元素需要使用哪个规则。 元素选择器不具体，会选择页面上该类型的所有元素，优先级会低一些。 类选择器稍微具体，会选择该页面中有特定 class 属性值的元素，优先级会高一点。 继承 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些设置在父元素上的CSS属性是可以被子元素继承的，有些则不能。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS为控制继承提供了五个特殊的通用属性值，每个CSS属性都接收这些值。 ​ inherit ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置该属性会使子元素属性和父元素相同。“开启继承”。 ​ initial ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将应用于选定元素的属性值设置为该属性的初始值。 ​ revert (en-US) ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。 ​ revert-layer (en-US) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将应用于选定元素的属性值重置为在上一个层叠层中建立的值。 ​ unset ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样 ​ ​ 重设所有属性值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all可以同时将继承值中的一个应用于所有属性（inherit、initial、unset或revert） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器如何决定该应用那个CSS规则： ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.资源顺序：超过一条规则，而且都是相同的权重，那么最后面的规则会应用。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.优先级：有些规则在最后出现，但是却应用了前面的规则。这是因为前面的有更高的优先级。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类选择器的权重大于元素选择器 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不会覆盖所有规则，只覆盖相同的属性 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级的计算：ID * 100 + 类（类、属性、伪类） * 10 + 元素（元素、伪元素） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用选择器（*）、组合符（+、&gt;、~、’ ‘）和调整优先级的选择器（:where()）不会影响优先级。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;否定（:not()）和任意匹配（:is()）伪类对优先级没有影响，但它们的参数则会带来影响。参数中，对优先级算法有贡献的参数的优先级的最大值将作为该伪类选择器的优先级。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内联样式：style属性内的样式声明，优先于所有普通的样式。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!important覆盖所有优先级计算。强烈建议除了非常情况不要使用它。 层叠层​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我看不懂，多学点知识后再来这一节吧 盒模型​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h1、p默认情况都是块级盒子 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a、span、em、strong默认inline ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置为inline时，不会产生换行, width、height属性不起作用。垂直方向的内边距、外边距以及边框会被应用但不会把inline状态的盒子推开，而水平方向会推开。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给盒子设置width和height时实际设置的是context box. ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际大小不包括margin,会计算border、padding、content ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有替代盒模型，反正我不咋用 ​ .box &#123; box-sizing: border-box; &#125; ​ 外边距 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以为正也可以为负。设置负值会导致和其他内容重叠。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外边距折叠：外边距相接的元素将合并为一个外边距，即最大的单个外边距的大小。 边框 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用标准盒模型，边框的大小将添加宽度和高度。使用替代盒模型，边框的大小会使内容框更小。 内边距 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能设置负值 盒子模型和内联盒子​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些属性也可以应用于内联盒子，例如span ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对一个span元素应用各种属性，高度、宽度被忽略，而边距、边框仍然生效，也不会改变与其他元素的关系。 背景与边框&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-color,background-image没必要多说了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-size调整背景图像大小 cover：浏览器将使图像足够大，完全覆盖盒子区域，同时仍然保持其宽高比。在这种情况下，图像的部分区域可能会跳出盒子外。 contain：浏览器会将图像调整到适合框内的尺寸。在这种情况下，如果图像的长宽比与盒子的长宽比不同，你可能会在图像的两边或顶部和底部出现空隙。 背景图像定位 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-position 属性允许你选择背景图片出现在它所应用的盒子上的位置 ​ background-position: top center; //水平、垂直定位 background-position: 20px 10%; //两种方式可以混用 background-position: top 20px right 10px; 定位在距顶部 20px 和右侧 10px 处 渐变背景 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你说的对，但这是什么？ 多个背景图像​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单个属性值中指定多个 background-image 值，用逗号分隔每个值。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能会出现背景图片相互重叠的情况，最后列出的背景图片位于最下层。 background-image: url(image1.png), url(image2.png), url(image3.png), url(image4.png); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的属性具有不同数量的值时，较小数量的值会循环 background-image: url(image1.png), url(image2.png), url(image3.png), url(image4.png); background-position: 10px 20px, top right; //image1为第一个值，image2为第二个值，此后循环 背景附加​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-attachment:指定内容滚动时的滚动方式 scroll：随着页面的滚动而滚动 fixed：使元素的背景固定在视口上，不会滚动。 local：将背景固定在它所设置的元素上，所以当你滚动该元素时，背景也随之滚动。 使用background简写属性、背景的无障碍考虑​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我觉得没什么必要的其实说 .box &#123; background: linear-gradient(105deg, rgba(255,255,255,.2) 39%, rgba(51,56,57,1) 96%) center center / 400px 200px no-repeat, url(big-star.png) center no-repeat, rebeccapurple; &#125; 边框 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的东西就不写了。 圆角​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用border-radius属性设置： .box &#123; border-radius: 10px; //四个角的半径 border-top-right-radius: 1em 10%; //水平、垂直半径 &#125; 处理不同方向的文本​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;书写模式是指文本的排列方向是横向还是纵向的,使用writing-mode进行设置 h1 &#123; writing-mode: vertical-rl; //垂直方向设置从右往左 vertical-lr //垂直方向设置从左往右 horizontal-tb //水平方向设置从上至下 &#125; 逻辑属性和逻辑值​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处于纵向书写模式时，希望盒子可以向横向模式下一样得到拓宽。为了更容易实现这样的转变，用逻辑（logical）和相对变化（flow relative）代替了像宽width和高height一样的物理属性。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;横向书写模式下，映射到width的属性被称作内联尺寸（inline-size）。而映射height的属性被称为块级尺寸（block-size）。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉应该不会常用 溢出的内容​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;溢出是在盒子无法容纳下太多的内容的时候发生的，CSS不会隐藏溢出的内容。 overflow属性​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个控制元素溢出的方式。默认为visible。 ​ hidden:会隐藏掉溢出部分。 ​ scroll:将会为溢出部分设置x轴和y轴的滚动条，避免消失。 可以为单个方向设置，如overflow-y: scroll 可以让浏览器决定是否显示滚动条：overflow:auto CSS的值和单位数字、长度、百分比长度​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝对长度不受页面限制。 单位 名称 等价换算 cm 厘米 1cm &#x3D; 37.8px &#x3D; 25.2&#x2F;64in mm 毫米 1mm &#x3D; 1&#x2F;10 of 1cm px 像素 1px &#x3D; 1&#x2F;96 of 1in ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对长度受页面限制。 单位 相对于 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。 em和rem​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;em依据的是父元素的字体大小，而rem依据的是根元素的字体大小。 百分比​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元素字体的百分比依据的是其父元素大小，但不是所有都接受百分比。 颜色 关键字，如antiquewhite, blueviolet, greenyellow等 十六进制RGB值，如#02798b,#c55da1等 rgb()，如rgb(2 121 139), rgb(197 93 161)等 hsl(), 接受色调(0~360)、饱和度、亮度, 如hsl(188, 97%, 28%), hsl(321, 47%, 57%) 等 位置​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;position&gt;表示一组2D坐标，用于定位一个元素，如同这样。 background-position: left 80px; 在CSS中调整大小固有尺寸​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固有尺寸由其包含的内容决定。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图像的长和宽便是固有尺寸，当把图片放进网页时没有使用img或css进行尺寸设置，便会展示固有尺寸。 外部尺寸​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当给元素指定具体尺寸时，这便成为外部尺寸，例如给div上height和width。 min-和max-尺寸​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以设置一个元素的最大尺寸或最小尺寸。 .box &#123; border: 5px solid darkblue; min-height: 150px; width: 200px; &#125; 视口单位​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1vh为视口高度的1%，1vw为视口宽度的1%。 .box &#123; border: 5px solid darkblue; width: 10vw; height: 30vh; font-size: 10vh; &#125; 图像、媒体和表单元素图像处理溢出问题 使用max-width : 100% 保证其一直不会宽度溢出 使用object-fit属性，将图像调整到完全能够盖住一个盒子的大小。 object-fit: cover; //维持图像的原始比例，但多余部分会被裁剪 object-fit: contain; //缩放到足以完整放到盒子里的大小，但不会完全盖住 object-fit: fill; //充满盒子但不会维持比例 form元素​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没学表单，直接搬MDN上的实例了。 &lt;form&gt; &lt;div&gt;&lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot;&gt;&lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/div&gt; &lt;/form&gt; /*CSS设置*/ input[type=&quot;text&quot;], input[type=&quot;email&quot;] &#123; border: 2px solid #000; margin: 0 0 1em 0; padding: 10px; width: 100%; &#125; input[type=&quot;submit&quot;] &#123; border: 3px solid #333; background-color: #999; border-radius: 5px; padding: 10px 2em; font-weight: bold; color: #fff; &#125; input[type=&quot;submit&quot;]:hover, input[type=&quot;submit&quot;]:focus &#123; background-color: #333; &#125; 样式化表格​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节的代码写进文件好吧。 调试CSS与组织CSS​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工具调试，没有多写的必要，引用他的一句话： 任何代码问题都可能令人沮丧，尤其是 CSS 问题，因为你通常无法获得错误消息用于网络搜索来帮助你找到解决方案。如果你感到沮丧，请暂时离开该问题一会儿—散步，喝一杯，与同事聊天，或者做一些其他事情。有时，当你停止思考问题时，解决方案就会神奇地出现，即使没有出现，在感到清爽的时候解决起问题来要容易很多。 样式化文本基本文本和字体样式​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文本内容像内联元素，除非到达了行的尽头，否则不会换行，强制换行使用&lt;br&gt;元素。 包含在元素中的文本是作为一个单一的实体，不能将文字其中一部分选中或添加样式，必须适用元素来包装它们，用span或者strong，或者使用伪元素，像::first(选中元素文本的第一个字母)，::first-line(选中元素文本的第一行)，::selection(当前光标双击选中的文本) 字体属性 color:接受任何合法的CSS单位 font-family:设定字体，使用字体栈可以使用多种字体选择 p &#123; font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif; &#125; font-size:设置大小,font-size属性是由该元素的父元素继承的，浏览器的font-size默认为16px font-style:打开或关闭文本italic normal:不打开斜体 italic:若该字体的斜体版本可用，打开斜体，否则利用oblique状态来模拟italics oblique:使用普通文本的斜体 font-weight:文字粗细 normal, bold: 普通或者加粗 lighter, bolder: 设置为比其父元素更细或更粗一步，值在100~900之间 text-transform:字体转换 none:防止任何转型 uppercase:转为大写 lowercase:转为小写 capitalize:转单词首字母为大写 full-width:转为全角 text-decoration:设置文本装饰 none:取消已存在的文本装饰 overline:上划线 underline:下划线 line-through:穿过文本的线 文字阴影text-shadow: 4px 4px 5px red; /* 1.阴影与原始文本的水平偏移(必须) 2.阴影与原始文本的垂直偏移(必须) 3.模糊半径，默认为0 4.阴影基础颜色，默认黑色 */ 文本布局 text-align:控制对齐模式 left: 左对齐文本。 right: 右对齐文本。 center: 居中文字 justify: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。 line-height:设置行高 line-height: 1.5; letter-spacing:字母与字母的间距 word-spacing:单词与单词的间距 为列表添加样式列表属性 list-style-type:设置列表符号的类型 ol &#123; /*设置大号罗马数字*/ list-style-type: upper-roman; &#125; 效果： list-style-position:设置符号是出现在列表项内还是出现在其外，默认为outside。 list-style-image:对列表符号使用自定义图片，但有局限，最好使用background系列属性。 ul &#123; list-style-image: url(star.svg); &#125; /*修改*/ ul &#123; padding-left: 2rem; list-style-type: none; &#125; ul li &#123; padding-left: 2rem; background-image: url(star.svg); background-position: 0 0; /*将出现在每个列表项的最左上侧*/ background-size: 1.6rem 1.6rem; background-repeat: no-repeat; &#125; 管理列表计数/*将从4开始计数*/ &lt;ol start=&quot;4&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;/ol&gt; /*将从4反向计数*/ &lt;ol start=&quot;4&quot; reversed&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;/ol&gt; /*设置指定值*/ &lt;ol&gt; &lt;li value=&quot;2&quot;&gt;a&lt;/li&gt; &lt;li value=&quot;4&quot;&gt;b&lt;/li&gt; &lt;li value=&quot;6&quot;&gt;c&lt;/li&gt; &lt;li value=&quot;8&quot;&gt;d&lt;/li&gt; &lt;/ol&gt; 样式化链接链接状态​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接的状态可以用对应的伪类来实现。 /*按照该顺序写，否则有些伪类无法应用*/ a &#123; &#125; a:link &#123; &#125; a:visited &#123; &#125; a:focus &#123; &#125; a:hover &#123; &#125; a:active &#123; &#125; 在链接中包含图标check out &lt;a href=&quot;http://www.extremescience.com/weather.htm&quot; &gt;weather on Extreme Science&lt;/a&gt; /*选中拥有href属性，且属性包含”http“的a元素*/ a[href*=&quot;http&quot;] &#123; background: url(&quot;external-link-52.png&quot;) no-repeat 100% 0; background-size: 16px 16px; padding-right: 19px; &#125; 样式化链接为按钮&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Pizza&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Music&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Wombats&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Finland&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; body, html &#123; margin: 0; font-family: sans-serif; &#125; ul &#123; padding: 0; width: 100%; &#125; li &#123; /*设置为行内元素*/ display: inline; &#125; a &#123; outline: none; text-decoration: none; display: inline-block; width: 19.5%; margin-right: 0.625%; text-align: center; line-height: 3; color: black; &#125; li:last-child a &#123; margin-right: 0; &#125; a:link, a:visited, a:focus &#123; background: yellow; &#125; a:hover &#123; background: orange; &#125; a:active &#123; background: red; color: white; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"CSS,学习","slug":"CSS-学习","permalink":"https://sakb1n.github.io/tags/CSS-%E5%AD%A6%E4%B9%A0/"}]},{"title":"DOM学习","slug":"DOM学习","date":"2023-10-25T09:26:43.000Z","updated":"2023-10-26T01:34:58.921Z","comments":true,"path":"2023/10/25/DOM学习/","link":"","permalink":"https://sakb1n.github.io/2023/10/25/DOM%E5%AD%A6%E4%B9%A0/","excerpt":"DOM基础DOM概述​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM(文档对象模型)是一个网络文档的编程接口，DOM将文档表示为节点和对象，因此编程语言可以和页面交互。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页是既可以在浏览器窗口中显示，又可以作为HTML源代码的文档，用DOM使它可以被操作。","text":"DOM基础DOM概述​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM(文档对象模型)是一个网络文档的编程接口，DOM将文档表示为节点和对象，因此编程语言可以和页面交互。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页是既可以在浏览器窗口中显示，又可以作为HTML源代码的文档，用DOM使它可以被操作。 const paragraphs = document.querySelectorAll(&quot;p&quot;); //paragraphs[0], paragraphs[1]... alert(paragraphs[0].nodeName); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM是使用多个API构建的，核心DOM定义了描述任何文档和其中对象的实体，其他API对其进行扩展。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM不是一门编程语言，而是用于建立网站的API。所以DOM不一定非要JavaScript才能实现，Python也行。 访问DOM​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用document或window对象来操作文档本身 //创造一个新的h1元素，向元素添加文本，再将其添加到文档的树中 &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;script&gt; // 当文档加载时，运行这段函数 window.onload = () =&gt; &#123; // 在空 HTML 页面中创建一系列元素 const heading = document.createElement(&quot;h1&quot;); const headingText = document.createTextNode(&quot;Big Head!&quot;); heading.appendChild(headingText); document.body.appendChild(heading); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 基本的数据类型​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常把DOM中的节点成为元素，但严格来说不是每个节点都是一个元素。 数据类型 描述 Document 当一个成员返回 document 对象时，这个对象就是rootdocument 对象本身。参见文章 DOM document 参考 Node 位于文档中的每个对象都是某种类型的节点。一个对象可以是一个元素节点，也可以是一个文本节点或属性节点 Element 基于Node，指的是一个元素或由DOM API成员返回的element类型的节点 NodeList 由元素组成的数组 Attr attribute 通过成员函数返回时，是一个为属性暴露出专门接口的对象引用 NamedNodeMap 和数组类似，但是条目是由名称或索引访问的 DOM中的核心接口 document.querySelector() document.querySelectorAll() document.createElement() Element.innerHTML Element.setAttribute() Element.getAttribute() EventTarget.addEventListener() HTMLElement.style Node.appendChild() window.onload window.scrollTo() 示例设置文本内容&lt;div class=&quot;container&quot;&gt; &lt;textarea class=&quot;story&quot;&gt;&lt;/textarea&gt; &lt;button id=&quot;set-text&quot; type=&quot;button&quot;&gt;设置文本内容&lt;/button&gt; &lt;button id=&quot;clear-text&quot; type=&quot;button&quot;&gt;清除文本内容&lt;/button&gt; &lt;/div&gt; .container &#123; display: flex; gap: 0.5rem; flex-direction: column; &#125; button &#123; width: 200px; &#125; const story = document.body.querySelector(&quot;.story&quot;); const setText = document.body.querySelector(&quot;#set-text&quot;); setText.addEventListener(&quot;click&quot;, () =&gt; &#123; story.textContent = &quot;It was a dark and stormy night...&quot;; &#125;); const clearText = document.body.querySelector(&quot;#clear-text&quot;); clearText.addEventListener(&quot;click&quot;, () =&gt; &#123; story.textContent = &quot;&quot;; &#125;); 添加子元素&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;parent&quot;&gt;父元素&lt;/div&gt; &lt;button id=&quot;add-child&quot; type=&quot;button&quot;&gt;添加子元素&lt;/button&gt; &lt;button id=&quot;remove-child&quot; type=&quot;button&quot;&gt;移除子元素&lt;/button&gt; &lt;/div&gt; .container &#123; display: flex; gap: 0.5rem; flex-direction: column; &#125; button &#123; width: 100px; &#125; div.parent &#123; border: 1px solid black; padding: 5px; width: 100px; height: 100px; &#125; div.child &#123; border: 1px solid red; margin: 10px; padding: 5px; width: 80px; height: 60px; box-sizing: border-box; &#125; const parent = document.body.querySelector(&quot;.parent&quot;); const addChild = document.body.querySelector(&quot;#add-child&quot;); addChild.addEventListener(&quot;click&quot;, () =&gt; &#123; // 只在文本节点“父节点”没有子节点时添加一个子节点 if (parent.childNodes.length &gt; 1) &#123; return; &#125; const child = document.createElement(&quot;div&quot;); child.classList.add(&quot;child&quot;); child.textContent = &quot;子节点&quot;; parent.appendChild(child); &#125;); const removeChild = document.body.querySelector(&quot;#remove-child&quot;); removeChild.addEventListener(&quot;click&quot;, () =&gt; &#123; const child = document.body.querySelector(&quot;.child&quot;); parent.removeChild(child); &#125;); 实例方法document.querySelector概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回文档中与指定选择器或选择器组匹配的第一个Element对象，找不到返回null。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配：使用深度优先先序遍历，从文档第一个元素开始按子节点的顺序遍历。 语法element = document.querySelector(selectors); /* selectors: 包含一个或多个要匹配的选择器的DOM字符串，必须为CSS选择器，否则引发SYNTAX_ERR异常。 SYNTAX_ERR:指定selectors的语法无效 CSS伪类不会返回任何元素 */ 示例//查找第一个匹配.myclass属性的元素 let e1 = document.querySelector(&quot;.myclass&quot;); //查找一个元素，该元素是被一个class = &quot;user-panel main&quot;属性的div包裹的name = &quot;login&quot;的input let e2 = document.querySelector(&quot;div.user-panel.main input[name = &#39;login&#39;]&quot;); document.querySelectorAll()概要 此方法基于ParentNode mixin的querySelectorAll()实现。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与指定的选择器组匹配的文档中的元素列表，返回NodeList(可以为空)。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦返回了NodeList，就可以像数组一样使用。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配：深度优先先序遍历文档节点。 语法querySelectorAll(selectors) /* selectors: 必须为CSS选择器的字符串，否则引发SyntaxError异常。 selectors中包含CSS伪元素会始终返回空值。 SyntaxError:指定的选择器不合法会抛出该错误。 */ 示例//获取所有p元素 let e = document.querySelectorAll(&quot;p&quot;); //获取所有class为note和alert的div元素 let e1 = document.querySelectorAll(&quot;div.note&quot;, &quot;div.alert&quot;); //获得一个p元素的列表，直接父元素是一个class = &quot;highlighted&quot;的div，位于ID为&quot;test&quot;的容器中 let container = document.querySelector(&quot;#test&quot;); let matches = container.querySelectorAll(&quot;div.highlighted &gt; p&quot;); //获得文档中属性名为“data-src”的iframe元素列表 let matches = document.querySelectorAll(&quot;iframe[data-stc]&quot;); //获得ID为userlist的列表中包含值为1的data-active属性的元素 let container = document.querySelector(&quot;#userlist&quot;); let matcher = container.querySelector(&quot;li[data-active = &#39;1&#39;]&quot;); document.createElement概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建一个由标签名称tagName指定的HTML元素，如果无法识别该tagName会生成一个未知HTML元素HTMLUnknownElement。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会返回新建的元素。 语法var element = document.createElement(tagName[, options]); /* tagName:指定要创建元素类型的字符串 */ 示例//新建一个新的div并且插入到ID为div1的元素前 document.body.onload = addElement; function addElement()&#123; //创造一个新的div元素 let newDiv = document.createElement(&quot;div&quot;); //添加内容 let newtext = document.createTextNode(&quot;Hello World!&quot;); //添加文本节点到这个div元素 newDiv.appendChlid(newtext); //获取div1 let curDiv = document.getElementById(&quot;div1&quot;); //添加到div1的元素前 document.body.insertBefore(newDiv, curDiv); &#125; element.innerHTML概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置或获取HTML语法表示的元素的后代。 语法const content = element.innerHTML; element.innerHTML = htmlString; /* 设置元素的innerHTML将会删除所有该元素的后代并以htmlString替代。 SyntaxError:HTML没有正确标记时，设置innerHTML将抛出语法错误。 NoModificationAllowedError:当父元素是Document时设置innerHTML将抛出语法错误。 */ 示例&lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;strong&gt;Log:&lt;/strong&gt;&lt;/div&gt; &lt;div class=&quot;log&quot;&gt;&lt;/div&gt; &lt;/div&gt; .box&#123; width: 600px; height: 300px; border: 1px solid black; padding: 2px 4px; overflow-y: scroll; overflow-x: auto; &#125; .log&#123; margin-top: 8px; font-family: monospace; &#125; let s = document.querySelector(&quot;.box&quot;); s.addEventListener(&quot;click&quot;, logEvent); s.addEventListener(&quot;mousedown&quot;, logEvent); s.addEventListener(&quot;mouseup&quot;, logEvent); s.addEventListener(&quot;mouseenter&quot;, logEvent); s.addEventListener(&quot;mouseleave&quot;, logEvent); function logEvent()&#123; let msg = &quot;Event &lt;strong&gt;&quot; + event.type + &quot;&lt;/strong&gt; at &lt;em&gt;&quot; + event.clientX + &quot;,&quot; + event.clientY + &quot;&lt;/em&gt;&quot;; log(msg); &#125; function log(msg)&#123; let a = document.querySelector(&quot;.log&quot;); let time = new Date(); let timestr = time.toLocaleTimeString(); a.innerHTML += timestr + &#39;:&#39; + msg + &quot;&lt;br /&gt;&quot;; &#125; log(&quot;Logging mouse events inside this container...&quot;); element.setAttribute概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置指定元素上的某个属性值，若该属性存在则更新该值，否则使用指定的名称和值添加一个新的属性，返回undefined。 语法element.setAttribute(name, value) /* name:表示属性名称的字符串 value:属性的值 */ 示例//为HTML的button设置属性 let b = document.querySelector(&quot;button&quot;); b.setAttribute(&quot;name&quot;, &quot;helloButton&quot;); b.setAttribute(&quot;disabled&quot;, &quot;&quot;); element.getAttribute概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回元素上一个指定的属性值，若指定的属性不存在，返回null 或&quot;&quot;。 语法let attribute = element.getAttribute(attributeName); /* attributeName:你想获取属性值的属性名称。 */ 示例let div1 = document.getElementById(&quot;div1&quot;); let align = div1.getAttribute(&quot;align&quot;); alert(align); EventTarget.addEventListener概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的监听器注册到EventTarget上，该对象触发指定的事件时，相应的回调函数会被执行，无返回值。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventTarget可以是Element、Document、Window和任何支持事件的对象。 使用 addEventListener()的优点： 它允许为一个事件添加多个监听器。特别是对库、JavaScript 模块和其他需要兼容第三方库&#x2F;插件的代码来说，这一功能很有用。 相比于 onXYZ 属性绑定来说，它提供了一种更精细的手段来控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。 它对任何事件都有效，而不仅仅是 HTML 或 SVG 元素。 原理​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将EventListener的函数或对象添加到调用它的EventTarget 的事件侦听器列表中，若已被添加则不会重复该操作。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个EventListener在处理事件时被注册到EventTarget上时，不会被立即触发。 ​ 如果先前向事件侦听器列表中添加过一个匿名函数，并且在之后的代码中调用 addEventListener 来添加一个功能完全相同的匿名函数，那么之后的这个匿名函数也会被添加到列表中。 ​ 实际上，即使使用完全相同的代码来定义一个匿名函数，这两个函数仍然存在区别，在循环中也是如此。在使用该方法的情况下，匿名函数的重复定义会带来许多麻烦。 语法addEventLister(type, listener, [options], [useCapture]); /* type:监听类型 listener：一个实现了EventListener接口的对象，或函数 options：capture(事件捕获), once(最多只调用一次),passive(不会调用preventDefault), signal(abort()方法被调用时，监听器被移除) useCapture:是否要先于它下面的EventTarget调用该Listener(不太懂这个...) */ 示例&lt;table id=&quot;outside&quot;&gt; &lt;tr&gt; &lt;td id=&quot;t1&quot;&gt;one&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td id=&quot;t2&quot;&gt;two&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; /*1.添加一个简单的监听器*/ // 为 table 添加事件监听器 const el = document.getElementById(&quot;outside&quot;); el.addEventListener(&quot;click&quot;, modifyText, false); // 改变 t2 内容的函数 function modifyText() &#123; const t2 = document.getElementById(&quot;t2&quot;); const isNodeThree = t2.firstChild.nodeValue === &quot;three&quot;; t2.firstChild.nodeValue = isNodeThree ? &quot;two&quot; : &quot;three&quot;; &#125; /*2.添加一个可被移除的监听器*/ // 为 table 添加可被移除的事件监听器 const controller = new AbortController(); const el = document.getElementById(&quot;outside&quot;); el.addEventListener(&quot;click&quot;, modifyText, &#123; signal: controller.signal &#125;); // 改变 t2 内容的函数 function modifyText() &#123; const t2 = document.getElementById(&quot;t2&quot;); if (t2.firstChild.nodeValue === &quot;three&quot;) &#123; t2.firstChild.nodeValue = &quot;two&quot;; &#125; else &#123; t2.firstChild.nodeValue = &quot;three&quot;; controller.abort(); // 当值变为 &quot;three&quot; 后，移除监听器 &#125; &#125; /*3.带有匿名函数的监听器*/ // 改变 t2 内容的函数 function modifyText(new_text) &#123; const t2 = document.getElementById(&quot;t2&quot;); t2.firstChild.nodeValue = new_text; &#125; // 用匿名函数为 table 添加事件监听器 const el = document.getElementById(&quot;outside&quot;); el.addEventListener( &quot;click&quot;, function () &#123; modifyText(&quot;four&quot;); &#125;, false, ); /*4.带有箭头函数的监听器*/ // 改变 t2 内容的函数 function modifyText(new_text) &#123; var t2 = document.getElementById(&quot;t2&quot;); t2.firstChild.nodeValue = new_text; &#125; // 用箭头函数为 table 添加事件监听器 const el = document.getElementById(&quot;outside&quot;); el.addEventListener( &quot;click&quot;, () =&gt; &#123; modifyText(&quot;four&quot;); &#125;, false, ); Node.appendChlid概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个节点附加到指定父节点的子节点列表末尾处。若该节点已经存在，则将其移动到新的位置，返回追加后的子节点。 语法element.appendChild(aChild) /* aChild:要追加给父节点的节点。 */ 示例//创造一个新的段落元素p，然后将其添加到body的最尾部 let p = document.createElement(&quot;p&quot;); document.body.appendChild(p); window.onload概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load事件在整个页面及所有依赖资源都已完全加载时触发。 语法addEventListener(&quot;load&quot;, (event) =&gt; &#123;&#125;); onload = (event) =&gt; &#123;&#125;; 示例windows.addEventListener(&quot;load&quot;, (event) =&gt;&#123; console.log(&quot;page is fully loaded&quot;); &#125;); windows.onload = (event) =&gt; &#123; console.log(&quot;page is fully loaded&quot;); &#125;; window.scrollTo概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动到文档中的某个坐标。 语法window.scrollTo(x-coord, y-coord); window.scrollTo(options); /* x-coord:文档的横轴坐标=left y-coord:文档的纵轴坐标=top options:包含三个属性的对象 */ 示例window.scrollTo(0, 1000); //设置滚动行为为平滑的滚动 window.scrollTo(&#123; top:1000, behavior:&quot;smooth&quot; &#125;);","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DOM,学习","slug":"DOM-学习","permalink":"https://sakb1n.github.io/tags/DOM-%E5%AD%A6%E4%B9%A0/"}]},{"title":"javaScript基础学习ver1.2","slug":"javascript基础学习ver1-0","date":"2023-10-19T04:38:49.000Z","updated":"2023-10-22T16:27:21.832Z","comments":true,"path":"2023/10/19/javascript基础学习ver1-0/","link":"","permalink":"https://sakb1n.github.io/2023/10/19/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0ver1-0/","excerpt":"2023.10.22: 更新了js对象内容(ver1.2)2023.10.21: 优化了排版，更新至ver1.12023.10.19：更新js ver1.0 JavaScript学习（MDN）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。","text":"2023.10.22: 更新了js对象内容(ver1.2)2023.10.21: 优化了排版，更新至ver1.12023.10.19：更新js ver1.0 JavaScript学习（MDN）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。 JavaScript第一步什么是javaScript？js简要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javascript是轻量级解释型语言，使用即时编译：会编译为二进制的格式。 js使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用内部js(在&lt;/head&gt;标签结束前插入&lt;script&gt;元素) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者直接外联（推荐): &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不建议内联（太乱了） 案例：使用addEventListener&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用querySelectorAll()函数选择按钮，使用addEventListener()为每个按钮分配一个处理器。 const buttons = document.querySelectorAll(&quot;button&quot;); for (let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].addEventListener(&quot;click&quot;, createParagraph); &#125; 脚本调用策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML是按其出现在页面中的次序调用的，若js加载在欲操作的元素之前会发生错误。 1.内部： document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; // … &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：这个事件监听器能监听浏览器的DOMContentLoaded事件，标志着HTML文档体完全加载和解析，而在该代码需在事件触发后才进行，从而避免了错误。 2.外部： &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在&lt;script&gt;最后加入defer解决问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：defer告知浏览器在遇到&lt;script&gt;元素时继续下载HTML内容。 async 和 defer 的区别 使用async 脚本时不会阻塞页面渲染，而是直接下载然后运行。但是，一旦下载完成，脚本就会执行，从而阻止页面渲染。脚本的运行次序无法控制。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，async 是最理想的选择。 使用 defer 属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完毕之前，脚本不会运行，如果脚本依赖于 DOM 的存在（例如，脚本修改了页面上的一个或多个元素），这一点非常有用。 例: &lt;script async src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;js/script2.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;js/script3.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三者的调用顺序是不确定的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async 应该在有大量后台脚本需要加载，并且只想尽快加载到位的情况下使用 &lt;script defer src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;js/script2.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;js/script3.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这将会按顺序以此加载。 注释 // 注释 /* 注释 */ javaScript初体验&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉没什么要写的，很多都是在java中学过的了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章更多是在讲第一个程序，贴个链接：[JavaScript 初体验](JavaScript 初体验 - 学习 Web 开发 | MDN (mozilla.org)) 事件​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;侦听事件的结构称为事件监听器(Event Listener）, 响应事件触发而运行的代码块称为事件处理器(Event Handler)。 for of循环const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]; for (const fruit of fruits) &#123; console.log(fruit); &#125; 结果： &#39;apples&#39;,&#39;bananas&#39;,&#39;cherries&#39; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for of在这里干了什么：获取fruits的第一个元素赋值给fruit，运行代码块，再重复这两个操作一直到fruits的末尾。 变量验证变量存在​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用变量的方式验证变量是否存在： myName; myAge; //若没数值会返回undefined，若不存在会产生报错信息 初始化变量var myName = &quot;Chris&quot;; var myAge = 37; 更新变量myName = &quot;Bob&quot;; myAge = 40; var和let的区别 let 是在现代版本中的 JavaScript 创建的一个新的关键字，用于创建与 var 工作方式有些不同的变量，解决了过程中的问题。 D1: myName = &quot;Chris&quot;; function logName() &#123; console.log(myName); &#125; logName(); var myName; //变量提升 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let将不再允许该操作，并产生错误。 D2: var myName = &quot;Chris&quot;; var myName = &quot;Bob&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let不能多次声明相同名称的变量。 注：Internet Explorer 直到第 11 版才支持 let ! 变量类型 Number String Boolean Array Object 注：js的变量为动态类型 数字与操作符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof：返回数据类型 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**: 幂， 5 ** 5 &#x3D;3125 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x3D;&#x3D;&#x3D;：严格等于，要求数据类型相等 字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js的字符串用单双引号都可以,但不能在字符串中包含相同的引号。 转义字符let bigmouth = &#39;I\\&#39;ve got no right to take my place...&#39;; // 使用\\&#39;转义 数字与字符串​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与字符串相互转换，用Number() 和 toString()方法。 let myNum = Number(myString); //转换为数值 let myString = myNum.toString(); //转换为字符串 字符串方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length方法返回长度： browserType.length; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexOf方法查找子字符串： browserType.indexOf(&quot;zilla&quot;); //找不到返回-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice方法提取字符串： browserType.slice(0, 3); //范围不包含第二个参数 browserType.slice(3); //返回自第三个字符后的字符串 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toLowerCase、toUpperCase大小写转换： let radData = &quot;mY&quot;; radData.toLowerCase(); //“my” radData.toUpperCase(); //&quot;MY&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace进行替换： let browserType = mozilia; browserType.replace(&quot;moz&quot;, &quot;van&quot;); //vanilia 数组创建数组let shopping = [&quot;bread&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot;]; let random = [&quot;tree&quot;, 795, [0, 1, 2]]; //不一定同一种类 访问数组shopping[0] = &quot;tahini&quot;; shopping; // shopping will now return [ &quot;tahini&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot; ] 获取数组长度shopping.length; 字符串和数组的转换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split方法: let myData = &quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;; let myArray = myData.split(&quot;,&quot;); myArray; //Manchester London Liverpool Birmingham Leeds Carlisle&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join方法: let myNewString = myArray.join(&quot;,&quot;); myNewString; //Manchester,London,Liverpool,Birmingham,Leeds,Carlisle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toString方法： myArray.toString(); 添加或删除数组项let myArray = [ &quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;, ]; myArray.push(&quot;Cardiff&quot;, &quot;Bradford&quot;); //末尾添加Cardiff、Bradford myArray.pop() //删除最后一个元素 myArray.unshift(&quot;Edinburgh&quot;) //首部添加Edinburgh myArray.shift() //删除第一个元素 JavaScript基础条件语句if (condition) &#123; &#125; else &#123; &#125; 例子: &lt;label for=&quot;weather&quot;&gt;选择今天的天气：&lt;/label&gt; &lt;select id=&quot;weather&quot;&gt; &lt;option value=&quot;&quot;&gt;--作出选择--&lt;/option&gt; &lt;option value=&quot;sunny&quot;&gt;晴天&lt;/option&gt; &lt;option value=&quot;rainy&quot;&gt;雨天&lt;/option&gt; &lt;option value=&quot;snowing&quot;&gt;雪天&lt;/option&gt; &lt;option value=&quot;overcast&quot;&gt;阴天&lt;/option&gt; &lt;/select&gt; &lt;p&gt;&lt;/p&gt; const select = document.querySelector(&quot;select&quot;); const para = document.querySelector(&quot;p&quot;); select.addEventListener(&quot;change&quot;, setWeather); function setWeather() &#123; const choice = select.value; if (choice === &quot;sunny&quot;) &#123; //进行判断 para.textContent = &quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;; &#125; else if (choice === &quot;rainy&quot;) &#123; para.textContent = &quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;; &#125; else if (choice === &quot;snowing&quot;) &#123; para.textContent = &quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;; &#125; else if (choice === &quot;overcast&quot;) &#123; para.textContent = &quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;; &#125; else &#123; para.textContent = &quot;&quot;; &#125; &#125; 循环语句​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同java，不再写笔记了。 函数自定义函数function myFunction() &#123; alert(&quot;hello world!&quot;); &#125; myFunction(); 匿名函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也称函数表达式，没有函数名的函数，经常与事件处理程序一起使用。 function() &#123; alert(&quot;hello world!&quot;); &#125; 例: var Button = document.querySelector(&quot;button&quot;); Button.onclick = function() &#123; alert(&quot;hello World!&quot;); &#125; 又如: var test = function () &#123; alert(&quot;hello world!&quot;); &#125;; test(); 事件介绍 事件是发生在你正在编程的系统中的事情——当事件发生时，系统产生（或“触发”）某种信号，并提供一种机制，当事件发生时，可以自动采取某种行动（即运行一些代码）。事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了对一个事件做出反应，你要给它附加一个事件处理器 实例：处理点击事件​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt;元素将在用户点击按钮时触发一个事件（定义了一个addEventListener函数） &lt;button&gt;改变颜色&lt;/button&gt; const btn = document.querySelector(&quot;button&quot;);//引用 function random(number) &#123; return Math.floor(Math.random() * (number + 1)); &#125; //click可以监听点击事件 btn.addEventListener(&quot;click&quot;, () =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅仅可以监听点击事件，addEventListener还可以: focus:聚焦（按Tab） blur:失焦(再次按下Tab) dblclick:双击按键 mouseover：鼠标指针在按钮上悬停 mouseout：鼠标指针移出按钮 移除监听器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用removeEventListener()方法 btn.removeEventListener(&quot;click&quot;, changeBackground); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以传递AbortSignal到addEventListener()，在拥有AbortSignal的控制器上调用abort()来删除。 const controller = new AbortController(); btn.addEventListener(&quot;click&quot;,() =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;, &#123; signal: controller.signal &#125; // 向该处理器传递 AbortSignal ); 然后 controller.abort(); // 移除所有与该控制器相关的事件处理器 在单个事件上添加多个监听器myElement.addEventListener(&quot;click&quot;, functionA); myElement.addEventListener(&quot;click&quot;, functionB); 其他事件监听器机制​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件处理器属性：可以触发事件的对象通常有on+事件名称的属性，例如 onclick。 ​ 所以也可以这样写： btn.onclick = () =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;; ​ 或者btn.onclick = functionA; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件处理器属性不能添加多个处理程序。 ​ 内联事件处理器 &lt;button onclick=&quot;bgChange()&quot;&gt;按下我&lt;/button&gt; function bgChange() &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125; 许多常见的服务器配置将禁止内联 JavaScript。 你永远不应该使用 HTML 事件处理器属性——那些已经过时了，使用它们是不好的做法。 事件对象​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在事件处理函数内部可能会看到一个固定指定名称的参数，例如 event、evt 或 e，这就是事件对象。 //e.target指的是按钮本身。事件对象 e 的 target 属性始终是事件刚刚发生的元素的引用 const btn = document.querySelector(&quot;button&quot;); function bgChange(e) &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; e.target.style.backgroundColor = rndCol; console.log(e); &#125; btn.addEventListener(&quot;click&quot;, bgChange); ​ 事件对象的额外属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keydown 事件在用户按下一个键时发生。它的事件对象是 KeyboardEvent，它是一个专门的 Event 对象，有一个 key 属性，告诉你哪个键被按下。 例： &lt;input id=&quot;textBox&quot; type=&quot;text&quot; /&gt; &lt;div id=&quot;output&quot;&gt;&lt;/div&gt; const textBox = document.querySelector(&quot;#textBox&quot;); const output = document.querySelector(&quot;#output&quot;); textBox.addEventListener(&quot;keydown&quot;, (event) =&gt; &#123; output.textContent = `You pressed &quot;$&#123;event.key&#125;&quot;.`; &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行后，每当你在输入框内敲下字母，将会显示你刚敲下的内容。 阻止默认行为&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码创造表单，要求填入名和姓，并有提交按钮。 &lt;form&gt; &lt;div&gt; &lt;label for=&quot;fname&quot;&gt;First name: &lt;/label&gt; &lt;input id=&quot;fname&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;lname&quot;&gt;Last name: &lt;/label&gt; &lt;input id=&quot;lname&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在submit事件中实行简单检查，如果文本字段为空，调用preventDefault()停止提交并报告错误信息，否则继续提交。 const form = document.querySelector(&quot;form&quot;); const fname = document.getElementById(&quot;fname&quot;); const lname = document.getElementById(&quot;lname&quot;); const para = document.querySelector(&quot;p&quot;); form.addEventListener(&quot;submit&quot;, (e) =&gt; &#123; if (fname.value === &quot;&quot; || lname.value === &quot;&quot;) &#123; e.preventDefault(); para.textContent = &quot;You need to fill in both names!&quot;; &#125; &#125;); 事件冒泡&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;button&gt;点我！&lt;/button&gt; &lt;/div&gt; &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt; &lt;/body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素上附加事件处理器，也会触发单击事件： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); container.addEventListener(&quot;click&quot;, handleClick); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素与按钮上同时附加事件处理器，都会触发： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); const button = document.querySelector(&quot;button&quot;); document.body.addEventListener(&quot;click&quot;, handleClick); container.addEventListener(&quot;click&quot;, handleClick); button.addEventListener(&quot;click&quot;, handleClick); /*Result: 你在BUTTON元素上进行了点击 你在DIV元素上进行了点击 你在BODY元素上进行了点击 */ 实例：视频播放器 单击显示”视频按钮“时，显示包含视频的盒子但不开始播放 单击视频时播放 单击盒子内视频以外的任何区域时隐藏盒子 &lt;button&gt;显示视频&lt;/button&gt; &lt;div class=&quot;hidden&quot;&gt; &lt;video&gt; &lt;source src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;p&gt; 你的浏览器不支持 HTML 视频，这里有视频的&lt;a href=&quot;rabbit320.mp4&quot;&gt;替代链接&lt;/a&gt;。 &lt;/p&gt; &lt;/video&gt; &lt;/div&gt; const btn = document.querySelector(&quot;button&quot;); const box = document.querySelector(&quot;div&quot;); const video = document.querySelector(&quot;video&quot;); btn.addEventListener(&quot;click&quot;, () =&gt; box.classList.remove(&quot;hidden&quot;)); video.addEventListener(&quot;click&quot;, () =&gt; video.play()); box.addEventListener(&quot;click&quot;, () =&gt; box.classList.add(&quot;hidden&quot;)); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当点击按钮后，因为div包含着video，盒子和视频都会同时显示，当点击视频时，会同时运行两个事件处理器，所以视频播放但盒子又消失了。 使用stopPropagation()修复问题​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event对象有一个stopPropagation()函数，可以在当一个事件处理器调用时防止事件向其他元素传递。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将video的addEventListener修改即可解决问题: video.addEventListener(&quot;click&quot;, (event) =&gt; &#123; event.stopPropagation(); video.play(); &#125;); 事件捕获 先在最小嵌套元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件捕获默认禁用，需要在addEventListener()中的capture选项中启用 接事件冒泡中的代码： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); const button = document.querySelector(&quot;button&quot;); //设置事件捕获 document.body.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;); container.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;); button.addEventListener(&quot;click&quot;, handleClick); /* Result: 你在BODY元素上进行了点击 你在DIV元素上进行了点击 你在BUTTON元素上进行了点击 */ 事件委托​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在父元素上设置监听器，让发生在它们身上的事件冒泡到父元素上。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户点击一个按钮时页面的区域设置成随机颜色 &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;/div&gt; //设置区域尺寸 .tile &#123; height: 100px; width: 25%; float: left; &#125; function random(number) &#123; return Math.floor(Math.random() * number); &#125; function bgChange() &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; return rndCol; &#125; const container = document.querySelector(&quot;#container&quot;); container.addEventListener(&quot;click&quot;, (event) =&gt;&#123; event.target.style.backgroundColor = bgChange(); &#125;); javaScript对象介绍java对象基础构造对象以及表示法/*构造一个空对象*/ const person = &#123;&#125;; /*用对象字面量创造对象*/ const person = &#123; name: [&quot;Bob&quot;, &quot;Smith&quot;], age: 32, bio() &#123; console.log(`$&#123;this.name[0]&#125; $&#123;this.name[1]&#125; 现在 $&#123;this.age&#125; 岁了。`); &#125;, introduceSelf() &#123; console.log(`你好！我是 $&#123;this.name[0]&#125;。`); &#125;, &#125;; /* 调用对象方法和属性 1.点表示法 */ person.name; person.name[0]; person.age; person.bio(); // &quot;Bob Smith 现在 32 岁了。&quot; person.introduceSelf(); // &quot;你好！我是 Bob。&quot; /* 2,括号表示法 */ person[&quot;age&quot;]; person[&quot;name&quot;][&quot;first&quot;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多数情况下用点表示法，但某些情况下你必须用括号表示法。 /*当对象属性名称保存在变量中，只能用括号表示法*/ const person = &#123; name: [&quot;Bob&quot;, &quot;Smith&quot;]; age:32; &#125;; function logProperty(propertyName)&#123; console.log(person[propertyName]); &#125; logProperty(&quot;name&quot;); //[&quot;Bob&quot;, &quot;Smith&quot;] logProperty(&quot;age&quot;); // 32 子命令空间/*用一个对象来做另一个对象成员的值*/ const person = &#123; name:&#123; first:&quot;Bob&quot;, last:&quot;Smith&quot;, &#125; &#125;; //访问 person.name.first; person.name.last; 设置对象成员&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;括号表示法可以动态创建成员名字，而点表示法不行。 /*设置对象成员*/ person.age = 45; person[&quot;name&quot;][&quot;last&quot;] = &quot;Cratchit&quot;; /*创建对象成员*/ person[&quot;eyes&quot;] = &quot;hazel&quot;; person.farewell = function()&#123; console.log(&quot;再见！&quot;); &#125;; person[&quot;eyes&quot;]; person.farewell(); 构造函数/*创造person的构造函数*/ function Person(name)&#123; this.name = name; this.introduceSelf = function( console.log(`你好！我是$(this.name)。`); ); &#125; /*调用构造函数*/ const salva = new Person(&quot;Salva&quot;); salva.name; salva.introduceSelf(); // &quot;你好！我是 Salva。&quot; 对象原型原型链const myObject = &#123; city: &quot;Madrid&quot;, greet()&#123; console.log(`来自$(this.city)的问候`); &#125;, &#125;; myObject.greet(); //来自 Madrid 的问候 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用myObject.时,出现以下信息 __defineGetter__ __defineSetter__ __lookupGetter__ __lookupSetter__ __proto__ city constructor greet hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf //调用其中的toString myObject.toString(); //&quot;[object Object]&quot; javaScript中所有对象都有一个内置属性，称作原型，原型对象也会有自己的原型，逐渐构成了原型链，原型链终止于拥有null作为其原型的对象上。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当访问一个对象的属性时，如果在其本身找不到该属性，就会在原型中搜索，仍然找不到则继续搜索原型的原型，直到链的末端（返回undefined）。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype是最基础的原型，所有对象默认都拥有它， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的原型是null，故其位于原型链的终点。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个对象的原型不一定就是Object.prototype const myDate = new Date(); let object = myDate; do &#123; object = Object.getPrototypeOf(object); console.log(object); &#125; while (object); // Date.prototype // Object &#123; &#125; // null 属性遮蔽 如果在对象中定义属性，而在对象原型中也定义了一个同名属性会发生什么？ const myDate = new Date(1995, 11, 17); console.log(myDate.getYear()); // 95 myDate.getYear = function () &#123; console.log(&quot;别的东西！&quot;); &#125;; myDate.getYear(); // &#39;别的东西！&#39; /*调用 getYear时，会先在myDate中寻找。这叫做属性遮蔽 */ 设置原型/*方式一：使用Object.create()*/ const personPrototype = &#123; greet() &#123; console.log(&quot;hello!&quot;); &#125;, &#125;; //创造一个以personPrototype为原型的新对象 const carl = Object.create(personPrototype); //原型为对象提供了greet方法 carl.greet(); /*方式二：使用构造函数*/ //创造personPrototype对象，该对象具有方法greet。 const personPrototype = &#123; greet() &#123; console.log(`你好，我的名字是 $&#123;this.name&#125;！`); &#125;, &#125;; //创造Person的构造函数 function Person(name) &#123; this.name = name; &#125; //将personPrototype中的方法绑定到Person的prototype属性上 Object.assign(Person.prototype, personPrototype); // 或 // Person.prototype.greet = personPrototype.greet; //调用 const reuben = new Person(&quot;Reuben&quot;); reuben.greet(); // 你好，我的名字是 Reuben！ 自有属性​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接在对象中定义的属性，被称为自有属性。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用静态方法 Object.hasOwn()检查一个属性是否是自有属性。 const irma = new Person(&quot;Irma&quot;); console.log(Object.hasOwn(irma, &quot;name&quot;)); // true console.log(Object.hasOwn(irma, &quot;greet&quot;)); // false 面向对象编程基本概念​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java方面知识，不再赘述。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javaScript中的原型与对象很像java中的类与对象，但两者依旧有区别。 javaScript中的类基本使用//用class声明一个类 class Person&#123; name; //构造函数 constructor(name)&#123; this.name = name; &#125; introduceSelf()&#123; console.log(`Hi! I&#39;m $&#123;this.name&#125;`); &#125; &#125; //创建并使用 const giles = new Person(&quot;Giles&quot;); giles.introduceSelf(); // Hi! I&#39;m Giles 省略构造函数/*不需要初始化时，默认构造函数将自动生成*/ class Animal &#123; sleep() &#123; console.log(&quot;zzzzzzz&quot;); &#125; &#125; const spot = new Animal(); spot.sleep(); //&#39;zzzzzzz&#39; 继承class Professor extends Person&#123; teaches; constructor(name, teaches)&#123; super(name); this.teaches = teaches; &#125; introduceSelf() &#123; console.log( `My name is $&#123;this.name&#125;, and I will be your $&#123;this.teaches&#125; professor.`, )&#125;; grade(paper) &#123; const grade = Math.floor(Math.random() * (5 - 1) + 1); console.log(grade); &#125; &#125; //使用 const walsh = new Professor(&quot;Walsh&quot;, &quot;Psychology&quot;); walsh.introduceSelf(); // &#39;My name is Walsh, and I will be your Psychology professor&#39; walsh.grade(&quot;my paper&quot;); // some random grade 封装class Student extends Person &#123; //#year是私有数据属性,&#39;用#&#39;表示。 #year; constructor(name, year) &#123; super(name); this.#year = year; &#125; introduceSelf() &#123; console.log(`Hi! I&#39;m $&#123;this.name&#125;, and I&#39;m in year $&#123;this.#year&#125;.`); &#125; canStudyArchery() &#123; return this.#year &gt; 1; &#125; &#125; //在类的外部尝试访问#year将会出错 const summers = new Student(&quot;Summers&quot;, 2); summers.#year; // SyntaxError 私有方法//与私有属性一样 class Example &#123; somePublicMethod() &#123; this.#somePrivateMethod(); &#125; #somePrivateMethod() &#123; console.log(&quot;You called me?&quot;); &#125; &#125; const myExample = new Example(); myExample.somePublicMethod(); // &#39;You called me?&#39; myExample.#somePrivateMethod(); // SyntaxError 使用JSONJSON简介 javaScript对象表示法（JSON）是用于将结构化数据表示为 JavaScript 对象的标准格式，通常用于在网站上表示和传输数据。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON可以作为一个对象或者字符串存在，前者用于解读JSON中的数据，后者用于通过网络传输JSON数据。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串转换为原生对象称为反序列化，原生对象转换为字符串称为序列化。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON存储在.json中。 ​ JSON结构​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON类似于对象字面量。 &#123; &quot;squadName&quot;: &quot;Super hero squad&quot;, &quot;homeTown&quot;: &quot;Metro City&quot;, &quot;formed&quot;: 2016, &quot;secretBase&quot;: &quot;Super tower&quot;, &quot;active&quot;: true, &quot;members&quot;: [ &#123; &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] &#125;, &#123; &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Eternal Flame&quot;, &quot;age&quot;: 1000000, &quot;secretIdentity&quot;: &quot;Unknown&quot;, &quot;powers&quot;: [ &quot;Immortality&quot;, &quot;Heat Immunity&quot;, &quot;Inferno&quot;, &quot;Teleportation&quot;, &quot;Interdimensional travel&quot; ] &#125; ] &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串加载入js程序中，并解析到名叫superHeroes变量中，可以用该变量访问数据。 superHeroes.hometown; superHeroes[&quot;active&quot;]; //访问members数组的第二个元素，其中的powers数组的第三个元素 superHeroes[&quot;members&quot;][1][&quot;powers&quot;][2]; JSON数组​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组与JSON可以相互转换，比如这样写依然有效。 [ &#123; &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] &#125;, &#123; &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] &#125; ] //调用 [0][&quot;powers&quot;][0]; JSON注意事项 是纯数据格式，只有属性，没有方法。 要求在字符串和属性名称周围用双引号。 JSON文件很容易出错，可以用JSONLint验证JSON。 JSON中只有带引号的字符串可以用作属性。","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"笔记,学习,js","slug":"笔记-学习-js","permalink":"https://sakb1n.github.io/tags/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0-js/"}]},{"title":"sql学习ver1.0","slug":"sql学习ver1-0","date":"2023-10-16T13:06:44.000Z","updated":"2023-10-19T04:38:04.759Z","comments":true,"path":"2023/10/16/sql学习ver1-0/","link":"","permalink":"https://sakb1n.github.io/2023/10/16/sql%E5%AD%A6%E4%B9%A0ver1-0/","excerpt":"2023.10.19：文章周末更新，会把排版优化一下~2023.10.16：更新sql ver1.0 数据库概念操作者用SQL语言向数据库管理系统(DBMS)发出指令，系统在数据库(DB)里进行操作。","text":"2023.10.19：文章周末更新，会把排版优化一下~2023.10.16：更新sql ver1.0 数据库概念操作者用SQL语言向数据库管理系统(DBMS)发出指令，系统在数据库(DB)里进行操作。 数据库存储特点 数据放进表（按行存储），表放进数据库 数据库有多个表，每个表只有一个名字 表中的每一列（也称字段）类似于java中对象的属性，每一行类似于java中的对象 配置文件my.ini 文件位置：C:\\ProgramData\\MySQL\\MySQL Server 8.0 SQL启动与停止方式一：计算机 ——– 管理 ——-服务 方式二：命令行(管理员) net start/stop mysql端口 SQL登陆与退出方式一：MySQL Command Line Client登陆(仅限于root) 方式二：命令行(管理员) mysql [-h主机名 -P端口号] -u用户名 -p密码 (仅限本地可以省略) 退出：exit或ctrl+c SQL常见命令show databases; //查看数据库 use 库名; //打开指定库 show tables //查看表 desc 表名 //查看表结构 查看版本： select version(); mysql --version SQL语法规范 不区分大小写 用分号结尾 可以换行 单行注释#或– + 空格 多行注释&#x2F;* *&#x2F; 查询基础查询SELECT 列表 FROM 表名； 注意：1.查询的可以是字段、变量、表达式或函数； ​ 2.返回的是虚拟表格。 ​ 3.SELECT * 会返回所有字段。 ​ 4.如果查询的列与SQL关键字冲突时，用反引号(&#96;&#96;)包裹。 ​ 5.SELECT可以查询常量值（意义何在…） 去重直接在字段前加上DISTINCT MySQL里的+号没有连接符的作用，只有运算符的作用 若一方是字符型，会自动隐式转换为数值型，失败会当做0 一方为NULL，最终值也为NULL 若要拼接字段，使用CONCAT(str1, str2, …)，如果其中有NULL值最终也会变为NULL，使用ISNULL(字段，赋值) 来判断。 条件查询SELECT 列表 FROM 表名 WHERE 条件； 按条件表达式筛选（&gt; &lt; &#x3D; !&#x3D;或&lt;&gt; &gt;&#x3D; &lt;&#x3D;） 按逻辑表达式筛选（&amp; || ! and or not） 模糊查询（like between and in isnull） ESCAPE ‘ ‘ 指定转义字符 用IN模糊查询时不能用通配符。 条件等于NULL值时 不能用&#x3D;，用专门的IS NULL。 安全等于(&lt;&#x3D;&gt;) 可以判断NULL值。 排序查询SELECT 列表 FROM 表名 WHERE 条件 ORDER BY 排序列表 ASC|DESC； ORDER BY 一般是放在查询语句的最后。 常用函数LENGTH() 求长 CONCAT() 连接字段 UPPER() 大写化 LOWER() 小写化 SUBSTR(str1, index1, index2) 返回在str1 index1~index2 位置上的子字符串（索引从1开始） INSTR(str1, str2) 返回在str2中第一次出现str1的索引,未查到返回0 TRIM(str1, str2) 在str2的头和尾上去除str1，未填str1默认为空格 L(R)PAD(str1, str2，length) 用str1在str2的左(右)边填充直到length长度 REPLACE(str1, str2, str3) 将str1中的str2全部替换为str3 数学函数ROUND(x, y) //四舍五入,对x保留y位小数 CEIL(x) //向上取整 FLOOR(x) //向下取整 RTUNCATE(x, y) //截断，对y + 1位后的小数进行截断 MOD(x, y) //x对y取余 日期函数NOW() //返回当前系统日期+时间 CURDATE() //返回当前系统日期 CURTIME() //返回当前时间 YEAR(time)、MONTH(time)... //可以获取指定时间的年、月等...(MONTHNAME可获得英文月份) STR_TO_DATE() //将日期格式的字符转换成指定格式的日期 例：STR_TO_DATE(&#39;1998-3-2&#39;, &#39;%Y-%c-%D&#39;); DATE_FORMAT //将日期转换为字符 例：DATE_FORMAT(NOW(), &#39;%y年%m月%d日&#39;) 其他函数VERSION() //版本号 DATABASE() //查看当前库 USER() //查看当前用户 流程控制函数IF的使用： IF(exp1, exp2, exp3) 例： IF(10 &lt; 5, &#39;大&#39;， ‘小&#39;) CASE的使用： 1.CASE 要判断的字段或表达式 WHEN 常量1 THEN 要显示的值或语句; WHEN 常量2 THEN 要显示的值或语句; WHEN 常量3 THEN 要显示的值或语句; ... ELSE 要显示的值或语句； END 2.CASE WHEN 条件1 THEN 要显示的值或语句; WHEN 条件2 THEN 要显示的值或语句; WHEN 条件3 THEN 要显示的值或语句; ... ELSE 要显示的值或语句； END","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习,mysql","slug":"学习-mysql","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0-mysql/"}]},{"title":"近期计划","slug":"近期计划","date":"2023-10-09T15:42:26.000Z","updated":"2023-10-25T06:38:40.351Z","comments":true,"path":"2023/10/09/近期计划/","link":"","permalink":"https://sakb1n.github.io/2023/10/09/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/","excerpt":"","text":"今年剩下的梦想： (难度从低到高) 买一张SSD 买一台显示器(在攒钱ing) 把sql和web学会(慢慢来吧) 拿到学校奖学金 进回声实验室(概率太低了，我觉得几乎不可能) 完成一项就会划掉一项，年末审视自己，能把前两项做好我觉得已经很满足了哦，至于后面的三项，能走到哪里就走到哪里吧（我终究是个普通人罢了）","categories":[],"tags":[]},{"title":"从零开始的博客搭建生活-003","slug":"从零开始的博客搭建生活-003","date":"2023-10-04T16:15:24.000Z","updated":"2023-10-07T04:54:05.213Z","comments":true,"path":"2023/10/05/从零开始的博客搭建生活-003/","link":"","permalink":"https://sakb1n.github.io/2023/10/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-003/","excerpt":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 今天写的是对博客各种功能的学习。预计这个系列在下一集就会完结www。","text":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 今天写的是对博客各种功能的学习。预计这个系列在下一集就会完结www。 文章编写新建文章:hexo new 文件名 执行该命令后会在根目录的source_posts生成文章。 新建草稿:hexo new draft 文件名 执行后同上，会在_drafts下生成草稿，草稿不会被更新在博客中。 通过上面这两个命令，相信已经知道Hexo文章的生成了，而文章的撰写需要学会Markdown语法，这部分内容会放在Extra章节中。 模版在主目录的scaffolds文件夹中，存放有: ├── draft.md //草稿模板├── page.md //页面模板├── post.md //文章模板 打开post.md，可以看到: ---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 向其中加入”categories：”,这样就添加了分类标签，此后生成文章后，文章头部将自带categories字段。 网页基础设置主目录的_config.yml在主目录的_config.yml下，可以对网站基础进行设置。 title:标题 subtitle:子标题 description:主页介绍 keywords:关键字 author:作者 language:语言(建议改为zh-CN) timezone:时区 在#site底下可以改url，这是博客上线后的地址，会在分享时用到。url:http://example.com 主题的_config.yml在themes&#x2F;你的主题&#x2F;_config.yml下，也有一部分能设置的东西。 注：以主题作者的文档为准！","categories":[{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]},{"title":"从零开始的博客搭建生活-002","slug":"从零开始的博客搭建生活-002","date":"2023-10-03T15:31:04.000Z","updated":"2023-10-07T04:53:20.293Z","comments":true,"path":"2023/10/03/从零开始的博客搭建生活-002/","link":"","permalink":"https://sakb1n.github.io/2023/10/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-002/","excerpt":"前文指引：从零开始的博客搭建生活-001","text":"前文指引：从零开始的博客搭建生活-001 在第一篇文章中省略的正式上线流程，还是有点路程的（） 首先你要有一个github账户，easy。 github pages配置，easy。 git配置SSH公钥（第一次用git），小麻烦。 webstorm链接远程，easy。 用一下hexo g ，就这样我们网站就能正式上线了啊哈哈，但是通过github来访问难以记忆，第二篇要写的东西，就是域名。 有了域名，我们访问网站就会更加方便，只需记住名字就行，当然这是付费项目。 我在阿里云花钱买了个.top域名，.com一年23块我买不起，这个一年9块还是比较便宜的注意：购买域名需要实名认证，一般当天就通过了 接下来便是解析域名 (我耗费时间最长的地方，出现了各种莫名其妙的问题)：在域名解析里添加记录 参考 照搬了多个教程最后决定添加的2条记录,除了第一条的记录值要改为名字.github.io.（末尾一定要有这个点）外，其他都按照图上写。 最后在github pages上添加自己的域名即可。(在这里，依旧没有解决一个叫”DNS valid for primary”的问题，我翻了很多网站都没找到合适的解决方案，虽然不影响使用，但这个问题在未来会追加解决的！) 稍作一会，你便可以直接通过域名看到自己的网站咯wow 至于为什么没有买云服务器搭配呢，原因很简单，我没钱买ECS云服务器，一个计算型c5算上公网带宽一个月起码200元花销，真的很贵。~~（什么，你说新生计划？抱歉，已经被我拿去做mc服务器用掉了）~~~ 域名就写这么多，在下一篇中，将对个人博客进行进一步的美化！ 从零开始的博客搭建生活-002 Finished！","categories":[{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]},{"title":"从零开始的博客搭建生活-001","slug":"从零开始的博客搭建生活-001","date":"2023-10-01T15:40:23.000Z","updated":"2023-10-07T04:53:53.198Z","comments":true,"path":"2023/10/01/从零开始的博客搭建生活-001/","link":"","permalink":"https://sakb1n.github.io/2023/10/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-001/","excerpt":"这是一个预谋已久的计划准备搭建一个属于自己的个人博客，至于原因，就是闲来无事在上面写点文章。该系列会持续更新，这是第一篇，大概会更新4~5集，讲讲我这个新手从零开始的艰辛路程（）","text":"这是一个预谋已久的计划准备搭建一个属于自己的个人博客，至于原因，就是闲来无事在上面写点文章。该系列会持续更新，这是第一篇，大概会更新4~5集，讲讲我这个新手从零开始的艰辛路程（） 文章链接：https://blog.csdn.net/m0_51269961/article/details/122575897快速搭建个人博客——保姆级教程 首先下载所需要的软件(如果要收钱的话你懂得) Webstorm (或Vscode, 但JetBrains全家桶可以用校园账户免费领) Hexo (网站博客框架，也可以用WordPress) Node.js (Hexo前置) git (工具) 需要注意的是，Node.js的安装可能需要自行配置环境变量，否则可能根本就运行不了指令，网上有一大堆教程。 Hexo安装：在桌面上git bash就行npm install -g hexo-cli插件：npm install hexo-renderer-pug hexo-renderer-stylus --save 初始化：建议自己创建新文件夹，在文件夹里面右键git bashhexo init hexo的一些常用文件： public: 网站最终呈现形态 node_modules: 插件 _config.yml: 配置文件 scaffolds: 模版文件夹 themes: 存放主题文件 source: 存放用户资源 在webstorm中打开终端，输入：hexo s 提示打开网站就成功了，进入网站将是hexo最开始的形态（用ctrl+c来关闭本地网站） 但我们需要让网站更漂亮的话，该怎么办呢？答案就是使用官方提供的theme主题。 地址：https://hexo.io/themes/我所选用的是ParticleX 克隆：git clone https://github.com/theme-particlex/hexo-theme-particlex.git particlex --depth=1 会多出以下文件: 在hexo根目录下修改_config.yml(不是themes里面的那个！) 里的theme属性，改为theme: particlex(值中间要留有空格)再hexo s,进入后主题更改，至此网站基础搭建成功！ 网站构建三件套：hexo clean //执行此命令后继续下一条 hexo g //生成博客目录hexo s //本地预览 而如何用github来对外展现自己的网站呢？在最开始的那个链接中详细指导了网站部署，很快就能学会！ 从零开始的博客搭建生活-001, Finished!","categories":[{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://sakb1n.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"算法,杂谈,学习","slug":"算法-杂谈-学习","permalink":"https://sakb1n.github.io/tags/%E7%AE%97%E6%B3%95-%E6%9D%82%E8%B0%88-%E5%AD%A6%E4%B9%A0/"},{"name":"CSS,学习","slug":"CSS-学习","permalink":"https://sakb1n.github.io/tags/CSS-%E5%AD%A6%E4%B9%A0/"},{"name":"DOM,学习","slug":"DOM-学习","permalink":"https://sakb1n.github.io/tags/DOM-%E5%AD%A6%E4%B9%A0/"},{"name":"笔记,学习,js","slug":"笔记-学习-js","permalink":"https://sakb1n.github.io/tags/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0-js/"},{"name":"学习,mysql","slug":"学习-mysql","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0-mysql/"},{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]}