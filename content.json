{"meta":{"title":"Bin's blog","subtitle":"","description":"小彬彬的博客","author":"Binbin","url":"https://sakb1n.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2023-10-01T13:00:23.000Z","updated":"2024-03-05T05:27:57.465Z","comments":true,"path":"about/index.html","permalink":"https://sakb1n.github.io/about/index.html","excerpt":"","text":"这是我的简介 The supreme happiness of life is the conviction that we are loved. 帐号 平台 帐号 QQ 648005280(大),1613453474(小) GitHub Sakbin 洛谷 Sakbin Florr.io Noooooob var userId = \"9096099519\"; var userServer = \"netease\"; var userType = \"playlist\"; const params = new URLSearchParams(window.location.search); var _param = { getCustomPlayList: function () { const musicPage = document.getElementById(\"music-page\"); const playlistType = params.get(\"type\") || \"playlist\"; if (params.get(\"id\") && params.get(\"server\")) { var id = params.get(\"id\"); var server = params.get(\"server\"); musicPage.innerHTML = ``; } else { musicPage.innerHTML = ``; } } }; _param.getCustomPlayList(); const vh = window.innerHeight * 1; document.documentElement.style.setProperty('--vh', `${vh}px`); window.addEventListener('resize', () => { let vh = window.innerHeight * 1; document.documentElement.style.setProperty('--vh', `${vh}px`); });"},{"title":"tags","date":"2023-10-07T04:57:42.000Z","updated":"2024-03-04T13:07:58.270Z","comments":true,"path":"tags/index.html","permalink":"https://sakb1n.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-10-07T04:57:20.000Z","updated":"2024-03-04T13:07:31.975Z","comments":true,"path":"categories/index.html","permalink":"https://sakb1n.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Oracle","slug":"Oracle","date":"2024-11-14T04:54:59.000Z","updated":"2024-11-15T05:11:47.862Z","comments":true,"path":"2024/11/14/Oracle/","link":"","permalink":"https://sakb1n.github.io/2024/11/14/Oracle/","excerpt":"","text":"Oracle默认用户 SYS:权限最大的管理员账号 SYSTEM:仅次于SYS,用于创建和管理数据库中的表与视图 SYSMAN：企业管理的超级管理员账号 DBSNMP：智能代理用户, 用于监控和管理数据库相关性能 SYSDBA：执行数据库启动关闭、备份恢复等操作 SYSOPER：可以启动关闭数据库 sqlplus system/abcdef@orcl //以system用户登录数据库 sqlplus sys/abcdef@orcl as sysdba //以sys用户登录数据库 connect simhr/abcdef //在sqlplus里进行账号切换 Oracle体系结构oracle的物理存储结构主要分为：数据、日志、控制、初始化参数文件.逻辑存储将存储空间依次划分为表空间、段、盘区与数据块。 一个数据库从逻辑结构上划分多个表空间,一个表空间继续划分为多个段,一个段又被划分为多个盘区,一个盘区又被划分为多个数据块。表空间是数据库中最大的逻辑存储结构, 盘区是最小的磁盘空间分配单元, 数据块是Oracle最小的数据读写单元. oracle方案对象方案对象：表、视图、索引、触发器、同义词、序列、函数、过程、包…非方案对象：表空间、用户、角色、回退段、目录… Tables //创建表 CREATE TABLE T_DEPT(deptno NUMBER(2), dname VARCHAR2(14), loc VARCHAR2(13)); //查询表结构 DESCRIBE T_USER; //修改表 ALTER TABLE T_DEPT ADD (job VARCHAR2(9)); ALTER TABLE T_DEPT MODIFY (dname VARCHAR2(15)); ALTER TABLE T_DEPT SET UNUSED COLUMN JOB; DROP UNUSED COLUMNS; //删除表, 不能回退 DROP TABLE T_DEPT CASCADE CONSTRAINTS; //改名 RENAME T_DEPT TO T_DEPARTMENT; //截断表 TRUNCATE TABLE T_DEPT; //增加注释 COMMENT ON TABLE T_DEPT IS &#39;DEPT INFORMATION&#39;; oracle中可以为表中的字段定义PRIMARY KEY、NOT NULL、UNIQUE、FOREIGN KEY、CHECK共5中约束. //定义约束 CREATE TABLE emp( empno NUMBER(4), ename VARCHAR2(10), deptno NUMBER(7,2) NOT NULL, CONSTRAINT emp_empno_pk PRIMARY KEY(EMPNO), CONSTRAINT emp_dpeno_fk FOREIGN KEY(deptno) REFERENCES dept(deptno) CONSTRAINT emp_deptno_ck CHECK(DEPTNO BETWEEN 10 AND 99)); //管理约束 ALTER TABLE emp ADD CONSTRAINT emp_mgr_fk FOREIGN KEY(mgr) REFERENCES emp(empno); ALTER TABLE emp DROP CONSTRAINT emp_mgr_fk; ALTER TABLE dept DROP PRIMARY KEY CASCADE; ALTER TABLE emp ENABLE CONSTRAINT emp_mgr_fk; Views //创建视图 CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view [(alias[, alias]...)] AS subquery [WITH CHECK OPTION [CONSTRAINT constraint]] [WITH READ ONLY] CREATE VIEW usersView AS SELECT * from T_USERS WITH CHECK OPTION CONSTRAINT empvu20_ck; CREATE OR REPLACE VIEW emp_view AS SELECT empno EMP_NUMBER, ename, sal, loc FROM emp, dept WHERE emp.deptno = dept.deptno AND dept.deptno = 10; //查询视图 SELECT ename from emp_view WHERE empno = 9876; //删除视图 DROP VIEW emp_view Sequences 序列号为ORACLE整数, 最多38个数字, 一般指出序列名字、上升下降、序列号之间间距与其他信息. CREATE SEQUENCE project_team_seq START WITH 1000 //起始值 INCREMENT BY 1 //步长 MINVALUE 1 //最小值 MAXVALUE 10000 //最大值 CYCLE //循环 CACHE 1000 //缓存 NOCYCLE NOORDER; SELECT project_team_seq.NEXTVAL FROM DUAL; //向序列中取下一个值,第一次取值必须要先取到NEXTVAL值才会有CURRVAL值 SELECT project_team_seq.CURRVAL FROM DUAL; //向序列中取当前值 Synonyms 为任何表、视图、快照、序列、过程、函数或包的别名. 有私有与公有两种同义词. CREATE SYNONYM SLAG FOR SCOTT.SALRADE; //私有 CREATE PUBLIC SYNONYM P_SLAG FOR SCOTT.SALGRADE; //共有 Roles CREATE USER user_name //用户名 IDENTIFIED BY password //密码 [DEFAULT TABLESPACE tablespace_name] //初始表空间 [TEMPORARY TABLESPACE tablespace_name] //临时初始表空间 [QUOTA quota_number [K | M] | UNLIMITED ON tablespace_name] //允许使用的最大字节数 [PROFILE profile_name] //概要文件名字 [PASSWORD expire] //设置口令为过期状态 [ACCOUNT lock| unlock] //账号锁定 CREATE USER simhr IDENTIFIED BY abcdef DEFAULT TABLESPACE users QUOTA 10M ON users PASSWORD EXPIRE ACCOUNT lock; GRANT CREATE SESSION TO user; //授予数据库建立会话/登录的系统权限 GRANT CREATE table TO user; GRANT CONNECT TO user; DML 如果算术表达式中包含NULL值，则表达式的值也为NULL. //插入 INSERT INTO dept(deptno, dname, loc) VALUES (50, &#39;DEVELOPMENT&#39;, &#39;DETROIT&#39;); INSERT INTO emp(deptno, hiredate) VALUES (5, SYSDATE); INSERT INTO su(id, name, address) SELECT N_USER_ID, VC_LOGIN_NAME, VC_PASSWORD FROM T_USERS; //插入多行 //更新 UPDATE emp SET (job, deptno) = (SELECT job, deptno FROM emp WHERE empno = 7499) WHERE empno = 7698; //查询 SELECT ename &quot;Name&quot;, sal * 12 &quot;Annual Salary&quot; FROM emp; //别名 SELECT ename || &#39; &#39; || &#39;is a&#39; || &#39; &#39;|| job AS &quot;Employee Details&quot; FROM emp; //连接符 SELECT ename from emp WHERE sal BETWEEN 1000 AND 1500; SELECT ename from emp WHERE ename LIKE &#39;_A%&#39;; // _匹配任意单一字符, %匹配0个或多个字符. SELECT ename from emp WHERE ename LIKE &#39;_A\\%&#39; ESCAPE &#39;\\&#39;; //转义特殊符号 常用函数 LPAD(X,Y,Z) //在X的左边加入Y个Z RPAD(X,Y,Z) //在X的右边加入Y个Z LOWER(X) UPPER(X) INITCAP(X) //第一个字母大写,剩下的都小写 LENGTH(X) SUBSTR(X,Y,Z) //从字符串X的第Y个字符开始,取出Z个字符 INSTR(X,Y) //将Y插入到X的位置 CONCAT(X,Y) //连接字符串 SELECT TO_CHAR(SYSDATE,&#39;YYYY-MM-DD HH24:MI:SS&#39;) FROM DUAL; //Oracle默认日期格式DD-MON-YY MONTHS_BETWEEN(date1, date2) //两个日期相差月数 NVL(expr1, expr2) //如果expr1为null,返回expr2值,否则返回expr1值. NVL2(expr1, expr2, expr3) //如果expr1为null,返回expr3值,否则返回expr2值. CASE expr WHEN comparison_expr1 THEN return_expr1 [WHEN comparison_expr2 THEN return_expr2 WHEN comparison_exprn THEN return_exprn ELSE else_expr] END DECODE(col|expression, search1, result1 [, search2, result2,...,] [, default]) CASE job WHEN &#39;ANALYST&#39; THEN 1.10 * sal WHEN &#39;CLERK&#39; THEN 1.15 * sal WHEN &#39;SALESMAN&#39; THEN 1.20 * sal ELSE sal END DECODE(job,&#39;ANALYST&#39;, 1.10 * sal, &#39;CLERK&#39;, 1.15 * sal, &#39;SALESMAN&#39;, 1.20 * sal, sal); PL&#x2F;SQL //匿名块 DECLARE v_number NUMBER(20); BEGIN v_number := 100 / 0; EXCEPTION WHEN ZERO_DIVIDE THEN DBMS_OUTPUT.PUT_LINE(&#39;DIVIDED BY ZERO&#39;); END; //记录类型 DECLARE TYPE record_type_emp IS RECORD( name VARCHAR2(10), job VARCHAR2(9), salary NUMBER(10)); record record_type_emp; BEGIN SELECT ename,job,salary INTO record FROM scott.emp WHERE empno=7369; dbms_output.put_line(&#39;ename:&#39; || emp_record.name||&#39; job:&#39;||emp_record.job||&#39; sal:&#39;|| emp_record.salary); END; //记录表类型 DECLARE TYPE dept_table_type IS TABLE OF VARCHAR(14) INDEX BY BINARY_INTEGER; table dept_table_type; BEGIN FOR i IN 1..4 LOOP SELECT dname INTO dept_table_type(i) FROM scott.dept WHERE deptno = 10 * i; dbms_output.put_line(&#39;dname:&#39;|| dept_table(i)); END LOOP; END; //在PL/SQL中使用INSERT DECLARE v_deptno dept.deptno%TYPE; v_dname dept.dname%TYPE; BEGIN v_deptno := &amp;no; v_dname := &#39;$name&#39;; INSERT INTO dept(deptno, dname) VALUES (v_deptno,v_dname); END; //循环 DECLARE v_number NUMBER(2); i NUMBER(2); j NUMBER(2); BEGIN v_number := 6; i := 0; LOOP i := i + 1; FOR j IN 1..i LOOP DBMS_OUTPUT.PUT(&#39;*&#39;); END LOOP; DBMS_OUTPUT.PUT_LINE(&#39;&#39;); EXIT WHEN i = v_number; END LOOP; END; //系统自定义异常 DECLARE e_amount_remaining EXCEPTION; BEGIN RAISE e_amount_remaining; EXCEPTION WHEN e_amount_remaining THEN :g_message := &#39;There is still an amount in stock.&#39;; END; //触发器 CREATE OR REPLACE TRIGGER audit_emp_values AFTER DELETE OR INSERT OR UPDATE ON emp FOR EACH ROW BEGIN INSERT INTO audit_emp_table (user_name, timestamp,empno, old_ename, new_ename, old_job,new_job, old_sal, new_sal) VALUES (USER, SYSDATE, :OLD.empno,:OLD.ename, :NEW.ename, :OLD.job,:NEW.job, :OLD.sal, :NEW.sal ); END; //存储过程 CREATE OR REPLACE PROCEDURE insert_emp (no emp.empno%TYPE, name emp.ename%TYPE, Job emp.job%TYPE, mgr emp.mgr%TYPE, hiredate emp.hiredate%TYPE , salary emp.sal%TYPE , comm emp.comm%TYPE , deptno emp.deptno%TYPE ) IS BEGIN INSERT INTO emp VALUES(no,name,job,mgr,hiredate,salary,comm,deptno); END; CREATE OR REPLACE PROCEDURE swap (x IN OUT NUMBER ,y IN OUT NUMBER) IS z NUMBER; BEGIN z:=x; x:=y; y:=z; END; //函数 CREATE OR REPLACE FUNCTION get_sal(p_id IN emp.empno%TYPE) RETURN NUMBER IS v_salary emp.sal%TYPE :=0; BEGIN SELECT sal INTO v_salary FROM emp WHERE empno = p_id; RETURN v_salary; END get_sal;","categories":[],"tags":[]},{"title":"从零开始的博客搭建生活-006","slug":"从零开始的博客搭建生活-006","date":"2024-10-17T14:35:10.000Z","updated":"2024-10-17T15:13:50.295Z","comments":true,"path":"2024/10/17/从零开始的博客搭建生活-006/","link":"","permalink":"https://sakb1n.github.io/2024/10/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-006/","excerpt":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 从零开始的博客搭建生活-003 从零开始的博客搭建生活-004 从零开始的博客搭建生活-005","text":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 从零开始的博客搭建生活-003 从零开始的博客搭建生活-004 从零开始的博客搭建生活-005 由于最近gitalk老是出问题, 导致无法正常评论, 所以考虑了一下将其换为giscus. Giscus是什么？&nbsp;&nbsp; &nbsp; giscus 是一个基于 GitHub Discussions 的评论插件。它的特点是简单易用，无需注册，支持多种主题，支持多语言，支持自定义配置。所有评论都存储在你的 GitHub Discussions 中，不会丢失，方便管理。 &nbsp;&nbsp; &nbsp; 官网链接: https://giscus.app/zh-CN 配置Giscus&nbsp;&nbsp; &nbsp;选择 giscus 连接到的仓库。请确保： 该仓库是公开的，否则访客将无法查看 discussion。 giscus app 已安装，否则访客将无法评论和回应。 Discussions 功能已在你的仓库中启用。 &nbsp;&nbsp; &nbsp; 请记得将需要使用的仓库进行公开, 然后进入giscus app安装, 并且在仓库中开启Discussion功能.&nbsp;&nbsp; &nbsp; 具体位置: Settings-General-Features-Discussions. &nbsp;&nbsp; &nbsp; 完成后开始配置giscus, 我们使用title进行映射, discussion分类选择announcements, 启用reaction与懒加载, 随后可以获得一串类似于这样的代码() &lt;script src=&quot;https://giscus.app/client.js&quot; data-repo=&quot;[在此输入仓库]&quot; data-repo-id=&quot;[在此输入仓库 ID]&quot; data-category=&quot;[在此输入分类名]&quot; data-category-id=&quot;[在此输入分类 ID]&quot; data-mapping=&quot;title&quot; data-strict=&quot;0&quot; data-reactions-enabled=&quot;1&quot; data-emit-metadata=&quot;0&quot; data-input-position=&quot;bottom&quot; data-theme=&quot;preferred_color_scheme&quot; data-lang=&quot;zh-CN&quot; data-loading=&quot;lazy&quot; crossorigin=&quot;anonymous&quot; async&gt; &lt;/script&gt; &nbsp;&nbsp; &nbsp; 由于我使用的particlex已经整合了giscus功能, 只需要在其配置文件里将以上代码复制进去就行了()&nbsp;&nbsp; &nbsp; 成功!!! 将gitalk评论迁移到giscus上&nbsp;&nbsp; &nbsp; 尽管配置好了giscus, 但之前gitalk上的评论也需要迁移到giscus上, 该怎么办呢? &nbsp;&nbsp; &nbsp; 其实很简单, 由于gitalk使用的是issues, 而giscus使用的discussions, 我们只需要将issues转换为discussions就行了. &nbsp;&nbsp; &nbsp; 不过请记得将之前的gitalk标签给删掉, 不然可能会无法匹配到讨论区()","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"}]},{"title":"二次元败家时刻(持续更新ing)","slug":"二次元败家时刻","date":"2024-05-26T14:46:58.000Z","updated":"2024-10-17T15:17:40.951Z","comments":true,"path":"2024/05/26/二次元败家时刻/","link":"","permalink":"https://sakb1n.github.io/2024/05/26/%E4%BA%8C%E6%AC%A1%E5%85%83%E8%B4%A5%E5%AE%B6%E6%97%B6%E5%88%BB/","excerpt":"如题, 二次元败家时刻. 把从高考结束后买的东西全列了一遍, 感觉自己太沙乱了呃呃呃 白玉镇楼","text":"如题, 二次元败家时刻. 把从高考结束后买的东西全列了一遍, 感觉自己太沙乱了呃呃呃 白玉镇楼 桜小路ルナ挂画 第一次买周边, 狠狠地被割了韭菜, 花了300r’◡’. 不过好歹也是买到了老婆. さくら、もゆ。-as the Night’s,Reincarnation- 现在想来算值得, 当时F社的东西还没有现在价格这么离谱. 但这个SD套装现在是真的买不到了, 甚至中古的都没有. 最喜欢十夜、千和与小黑了wwwwwww さくらの云＊スカアレットの恋 挂画是在日拍上偶然收到的, 顺带收了两个徽章, 钥匙扣貌似是在日亚收的. 我非常喜欢所长() 非常意难平的结局, 为什么就非要这么写呢冬茜(*꒦ິ⌓꒦ີ) このアルバムだって，もう何度見返したのかもわからない。こうしてたまに新たな姿が見られるのが……何よりの楽しみでもあった. Hatsune Miku傻fufu可爱捏 kz大神的Re:Dial专辑, 大概是10年前的东西了, 这个专辑里的歌我都喜欢, 欢迎大家去听. 近月少女的礼仪 这是高中存了一年半存下来的东西. 最贵的一集, 不透露具体金额了, 反正是4位数. 不仅是我最喜欢的作品, 桜小路ルナ直到现在也是我的白月光. Blue Archive 网上买了个国产手机壳和鼠标垫, 线下only展随便买了点就算了. 喜欢的有很多, 但一直都不出新皮和剧情. 从Hina限定后没有那么多的兴趣再上BA了, 无限期退坑中. 哪天白洲梓有新皮了就会回来的() あまいろショコラータ Switch 最近巧克甜恋switch上架买的, 内容为4张色纸+1挂画+马克杯+帆布画, 价格有点小贵. 我很喜欢小千, 但我不是萝莉控. 等第二部上架后肯定还要买的( 星空のメモリア最近刚推完的作品. F社老作, 虽然不合理点太多, 但个人还是喜欢最后真女主线的处理的, 本体梦线实在是太短了. 难怪F社人气投票的时候, 乙津梦能够力压其他人夺得冠军啊, 我都找不到不喜欢的理由… 星空のメモリア HD有幸在日亚上淘到了全新的货, 这是自己做的最正确的一次决定. 白玉COMITIA148终于有了一次机会去获得我最爱的画师的亲笔签名. 白玉小收集 白玉C104 白玉十周年画集可以说我运气太好了, 有校友传给我了这本一直想要的画集, 垃圾屋的二手竟然要1000多r才能买到… 详细请见: https://tieba.baidu.com/p/9217693354 未完待续","categories":[],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://sakb1n.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"}]},{"title":"从零开始的博客搭建生活-005","slug":"从零开始的博客搭建生活-005","date":"2024-03-04T15:48:29.000Z","updated":"2024-03-05T05:21:41.287Z","comments":true,"path":"2024/03/04/从零开始的博客搭建生活-005/","link":"","permalink":"https://sakb1n.github.io/2024/03/04/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-005/","excerpt":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 从零开始的博客搭建生活-003 从零开始的博客搭建生活-004","text":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 从零开始的博客搭建生活-003 从零开始的博客搭建生活-004 这一节主要是小细节方面的优化, 为了改善体验, 进行了以下方面的改进. 参考文献&nbsp;&nbsp; &nbsp; 搭建图床&nbsp;&nbsp; &nbsp; Hexo压缩静态文件&nbsp;&nbsp; &nbsp; Cloudflare国内访问慢的原因和解决方法 图床&nbsp;&nbsp; &nbsp;上传图片太麻烦了,而且会极大影响用户的体验, 所以考虑建造一个图床用于存放图片. &nbsp;&nbsp; &nbsp;使用PicGo + GitHub完成任务. 1.安装PicGo&nbsp;&nbsp; &nbsp;仓库地址: PicGo &nbsp;&nbsp; &nbsp;选择合适的版本安装, 完成后打开即可. 2.建立GitHub仓库&nbsp;&nbsp; &nbsp; 在你的GitHub账号上新建一个仓库, 该仓库需要设置为Public并且添加README. 3.创建Token&nbsp;&nbsp; &nbsp; 链接 &nbsp;&nbsp; &nbsp; 登录进去后选择Tokens(classic), 将Expiration设置为”No expiration”, 将Select scopes下方的repo勾选上, 创建Token并记下它. 4.配置PicGo&nbsp;&nbsp; &nbsp;点击PicGo中的”图床设置”—“GitHub”&nbsp;&nbsp; &nbsp;后两项为选填 5.完毕&nbsp;&nbsp; &nbsp; 图床搭建完成, 将图片通过PicGo上传后即可使用, 以下便是一张由我上传的图() &nbsp;&nbsp; &nbsp; 梅华和千绘莉真可爱嗯哼哼!!! 静态文件压缩 用以优化访问速度. 1.安装 npm add hexo-html-minifier hexo-clean-css hexo-uglify 2.配置&nbsp;&nbsp; &nbsp; 在Hexo主目录下的_config.yml添加 uglify: mangle: true output: compress: exclude: - &quot;*.min.js&quot; clean_css: exclude: - &quot;*.min.css&quot; html_minifier: collapseBooleanAttributes: true collapseWhitespace: true ignoreCustomComments: [!!js/regexp /^\\s*more/] removeComments: true removeEmptyAttributes: true removeScriptTypeAttributes: true removeStyleLinkTypeAttributes: true minifyJS: true minifyCSS: true 大功告成！ CloudflareSpeedTest&nbsp;&nbsp; &nbsp;仓库地址:CloudflareSpeedTest &nbsp;&nbsp; &nbsp;使用其测速即可查到延迟最低的服务器IP, 随后在域名解析中添加A记录-*-IP地址即可, 亲测有效. 如果生命只有最后一天 我想获得真正的自由 即便 只有短短的一步 如果生命只有最后一天 我想摸摸张熟悉的脸 哪怕 是在无尽的梦里 如果生命只有最后一天 我想看到幸福的未来 即便 只是短暂的一瞬","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Binbin's Diary-vol1","slug":"生活记录-vol1","date":"2024-01-10T13:17:25.000Z","updated":"2024-05-26T14:40:50.610Z","comments":true,"path":"2024/01/10/生活记录-vol1/","link":"","permalink":"https://sakb1n.github.io/2024/01/10/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95-vol1/","excerpt":"本篇图片约40张, 打开可能非常缓慢, 请考虑挂梯子! 学期即将结束, 回忆一下整个大二上那些存在的温柔的记忆吧, 或许都是些零零散散的碎片, 但我还是想发出来好好再看看. ꉂ(ˊᗜˋ*)","text":"本篇图片约40张, 打开可能非常缓慢, 请考虑挂梯子! 学期即将结束, 回忆一下整个大二上那些存在的温柔的记忆吧, 或许都是些零零散散的碎片, 但我还是想发出来好好再看看. ꉂ(ˊᗜˋ*) 2023.8.31 终于又开始了新的学期生活了, 校园的故事将再次开启啦啦啦. 好吧, 这个学期注定不太好过, 作为转专业学生的我, 还要将大一上没有学习的课程全部补修过来, 数据结构、网页交互式、Web应用真让人头痛呐wwwwww 2023.9 跟室友一起去了锦里和武侯祠看看, 但景区里的人实在太太太太多了, 我反而还有一点不习惯. 我们三人去主机店玩了玩双人成行, 双人成行果然还是要跟别人一起玩才好玩. 顺便我也体验了下美末() FOREST 通关, 但这个游戏真是经常能吓到我, 下次只要带惊悚词条的游戏我都要慎重考虑一下哼. 开了一个mc原版服务器与朋友玩玩, 但就用的阿里云免费白嫖的服务器(), 中间还有神秘人进来把我服炸了(差点remake), 好在最后还是顺利结束了. 上课路上遇见的小猫猫, 挺可爱的喵喵, 但我还是不敢去摸捏 国庆将至, 该带她回去见家长吗 犹豫了很久还是没带回去, 我真害怕你一去不复返啊啊啊啊啊！(指被我妹抱走) 2023.10在这一段时间里, 主要进行的是学习了, 趁着时间充足慢慢把HTML+CSS+JavaScript学完了, 也为接下来的JavaWeb的学习提前做好铺垫(我比较感兴趣)可惜我一直没有把jquery搞明白()MDN, 网页学习唯一指定真神!从这里开始, 萌生了自己写博客的想法, 感谢自己搭了这么一个梯子.当时还顺便搭了个nonebot2玩玩, 可惜go-cqhttp现在已经寄了呜呜呜去四川师范大学见见高中同学, 川师的校门好大, 周围也好繁华, 真是令人羡慕啊.数据库学习, 当时想着简单, 但真正的噩梦才正式开始…理论学习真痛苦, 一点都看不懂.jpg卡了我很久的一道题, 找了半天, 结果发现是自己误写了一小点东西…拿到校友送的徽章了, 车车人泪目 2023.11应该是最忙的一个月, 在这个月里自学将jdbc、servlet、jsp、maven、mybatis全部搞定了, 还看了一点vue, 难是真的难, 中间我还几度想放弃掉web学习, 好在最后都有一股无形的力量让我站了起来继续前进, 还是顺利度过了难关.跟着数据库老师坐公费车来到著名985–电子科技大学去听课, 电科校园很安静, 很漂亮, 很美好, 跟我梦想中的校园好相配. 如果哪一天能考上这里我会笑的多开心呐(做梦罢了)讲座后送的一个USB, 但是是便宜货()第一次完成一道绿题(然后就没怎么管过洛谷了, 我真是fw) 2023.12休闲的月份. 成信银杏大道. 我的ptt终于到12.60了!!! 又买二次元的东西, 二次元真害人! 熟悉我的人知道我超级喜欢白洲梓小姐() 年度歌单全是音游曲, 音游玩家真的是... 2023最后一天, 来成都理工大学见一位很久很久都没有见过的朋友了. 成理的大真的是超乎我的想象, 我还头一次听说大学里包括了一个小区! 真令人惊讶啊. 终于感受到双流一大学和双一流大学的差距了() 后来我们一起去吃了饭, 看了电影, 这是让我非常非常开心的一天. 但就是不知道, 下一次我还能有机会再见到朋友吗. 2024.1在重新开始的道路上.新年快乐!复健Web, 感觉忘了不少, 主要还是要应付考试. 2024.1.9做了我有史以来最胆大但又一直最想做的事情, 反正都要快20岁了, 只要心中的想法与思考 传达出去了就好了吧.从现在开始, 我要把全部精力投入到学习中去了. 买了一本高等代数作为寒假学习用, 祝愿自己在数学学习的道路上不要遇到太多挫折和困难吧() 回顾大二上的生活, 还是稍微有那么一点摆的, 但这种生活还是很让我满意的.希望未来的日子能一帆风顺下去. 我们一直身处在同一片天空之下. 桜色の都会でいま在这座樱色渲染的都会时を 止めて 踊りだす静止了时间 随樱起舞追忆のステージを在追忆的舞台上走りぬける しなやかさで以优美的舞步迎接终曲命を纺ぐその声那创造生命的清脆声音响け 世界 揺さぶるほどに不停迴响 摇动了世界始まりの日を 二人で歌おう两人一同歌唱 初始的那一天","categories":[{"name":"生活","slug":"生活","permalink":"https://sakb1n.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://sakb1n.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"从零开始的博客搭建生活-004","slug":"从零开始的博客搭建生活-004","date":"2024-01-10T11:18:00.000Z","updated":"2024-03-05T05:34:17.525Z","comments":true,"path":"2024/01/10/从零开始的博客搭建生活-004/","link":"","permalink":"https://sakb1n.github.io/2024/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-004/","excerpt":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 从零开始的博客搭建生活-003","text":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 从零开始的博客搭建生活-003 提要关于评论区, 有很多方案可以进行选择, 例如Waline、Twikoo、Giscus等系统, 但感觉有点麻烦了, 比如Waline需要使用vercel等工具, 我不想搞复杂了, 我们使用最方便的Gitalk来进行演示吧. 先来申请GitHub Application吧地址: https://github.com/settings/applications/newApplication name: 应用名Homepage URL: 博客主域名Application description: 描述(选填)Authorization callback URL: 填博客主域名 填写后点击Register application, 成功创建. 请记住clientID与clientSecret这两项内容, 之后请准备一个仓库为下文的repo做准备. 开启Gitalk一般在所用主题的配置文件中标注有该选项, 以下是我所用主题的配置.enable: 开启功能clientID、clientSecret: 与GitHub Application一致repo: 所使用仓库名owner、admin: 填自己的名字proxy: CORS代理, 选填 之后就可以使用Gitalk了! 常见问题未找到相关的issue评论，请联系xxx初始化创建只需登录Github账户即可解决. Error: Not Found.没有找到repo, 请查一查仓库配置信息是否正确. Error: Validation Failed.文章对应的URL过长, GitHub规定该值不超过50. 请寻找自己所用主题有关comments部分的源代码.将id该行的值加上decodeURL函数, 将id长度变短, 问题得到解决. 感谢浏览.","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"}]},{"title":"WEB应用开发","slug":"WEB应用开发","date":"2024-01-06T10:08:05.000Z","updated":"2024-03-04T16:32:49.259Z","comments":true,"path":"2024/01/06/WEB应用开发/","link":"","permalink":"https://sakb1n.github.io/2024/01/06/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","excerpt":"速通WEB考试重点,祝大家都能顺利通过（）","text":"速通WEB考试重点,祝大家都能顺利通过（） 1.Web应用开发流程 需求分析: 确定项目的业务需求, 明确用户的功能和交互需求, 定义项目的范围、功能和特性, 确定开发团队的目标. 项目规划: 制定项目计划, 包括开发阶段、测试阶段、上线时间等. UI&#x2F;UX设计: 进行用户界面（UI）和用户体验（UX）的设计, 设计页面布局、颜色和交互流程. 前端开发: 使用HTML、CSS、JavaScript等技术实现UI设计, 前端框架（如React、Vue、Angular）的选择和使用. 后端开发： 选择后端技术栈(如Java、Python、Node.js), 开发后端业务逻辑. 数据库开发: 设计数据库表结构, 确定数据存储方式. 使用数据库管理系统（如MySQL、PostgreSQL、MongoDB）进行开发. 集成测试: 对前端、后端和数据库进行集成测试, 确保系统各部分协同工作,并检查系统是否满足需求. 系统测试: 对整个系统进行全面测试, 包括功能测试、性能测试、安全测试等. 部署: 部署到服务器, 配置服务器环境,设置域名、SSL证书等, 配置反向代理(如Nginx、Apache). 维护和优化: 定期进行系统维护,如数据库备份、日志清理等.根据用户反馈和系统监控数据,进行系统优化和升级. C&#x2F;S架构: 开发客户端&#x2F;服务端软件、部署服务端程序、部署客户端程序、安装客户端软件.B&#x2F;S架构: 开发服务器端代码、部署到Web服务器. C&#x2F;S偏向用户体验, B&#x2F;S偏向功能服务实现, 两者并没有优劣之分. 2.静态网页的显示可以不依赖于Web服务器 正确. 3.表格布局比DIV+CSS布局的兼容性更好 正确. 由于采用的是HTML标签 &lt;table&gt;,各种浏览器都能准确解析该标签, DIV+CSS还没有实现所有浏览器的统一兼容. 4.表格布局比DIV+CSS布局更灵活多样 错误. 请多相信CSS的能力! 5.表单标记通过method属性设置后台的处理程序 正确. method可以取”GET”和”POST”值. 6.表单的主要作用是发布信息 错误. 表单的主要作用是收集和提交信息. 7.表单中的输入组件都是通过&lt;input&gt;标记定义的 错误. 其实不仅限于&lt;input&gt;, &lt;textarea&gt;&lt;select&gt;等都能标记定义. 8.表单中的密码框的输入回显字符只能是” * “ 错误. 通常是圆点或者星号. 9.表单中一组单选按钮的name属性要相同 正确. radio是以name属性进行分组的. 10.表单中一组复选按钮的name属性不需要相同 正确. checkbox的name属性不用于分组. 11.表单中的列表默认只显示1个选项 正确. 12.表单中的列表只能选择1个选项 错误. 使用multiple属性可以多个. 13. 通过CSS的应用可以同时更新多个网页的样式 正确. 14.CSS可以在网页中定义也可以在CSS文件中定义 正确. 15.表单关键元素和相关设置MDN form元素 form标签用于向Web服务器提交信息.主要属性:&nbsp;&nbsp; &nbsp; name: 表单名称&nbsp;&nbsp; &nbsp; action: 表单提交的URL&nbsp;&nbsp; &nbsp; method: HTTP方式提交表单 &lt;form action=&quot;/submit&quot; method=&quot;post&quot;&gt; &lt;!-- 表单中的其他元素 --&gt; &lt;/form&gt; 16.JavaScript变量名是区分大小写的 正确. 17.JavaScript主要用于接受服务器端的响应 错误. 不仅仅接受服务器端的响应, 还有用户与页面的交互. 18.JavaScript变量的类型根据变量赋值来确定 正确. 弱类型语言. 19.JavaScript变量使用var声明时必须赋初值 错误. 完全可以不赋初值, 默认undefined. 20.JavaScript实现表单提交参数验证 来源于PPT. &lt;button onclick=&quot;check();&quot;/&gt; &lt;script language=&quot;JavaScript&quot;&gt; function check()&#123; if(frm.userName.value==&quot;&quot;)&#123; alert(&quot;userName excepted!&quot;); frm.userName.focus(); return; &#125; frm.submit(); &#125; &lt;/script&gt; &lt;submit onclick=&quot;return check();&quot;/&gt; &lt;script language=&quot;JavaScript&quot;&gt; function check()&#123; if(frm.userName.value==&quot;&quot;)&#123; alert(&quot;userName excepted!&quot;); frm.userName.focus(); return false; &#125; return true; &#125; &lt;/script&gt; 21.正则表达式MDN 正则表达式 22.JSON是一种轻量级的数据交换格式 正确. 23.JSON和XML比较JSON体积更小 正确. JSON有更简洁的语法结构. 24.JSON数据前端显示MDN JSON &nbsp;&nbsp; &nbsp;JSON是一种语法.&nbsp;&nbsp; &nbsp;JSON不是JavaScript, JavaScript不是JSON.&nbsp;&nbsp; &nbsp;JSON方法: //JSON.parse():解析JSON字符串, 转换为JavaScript值(JSON字符串不允许用逗号结尾) const json = &#39;&#123;&quot;result&quot;:true, &quot;count&quot;:40&#125;&#39;; const obj = JSON.parse(json); console.log(obj.count); // Expected output: 42 console.log(obj.result); // Expected output: true //JSON.stringify(): 将JavaScript值转换为JSON字符串 console.log(JSON.stringify(&#123; x: 5, y: 6 &#125;)); // Expected output: &#39;&#123;&quot;x&quot;:5,&quot;y&quot;:6&#125;&#39; console.log( JSON.stringify([new Number(3), new String(&#39;false&#39;), new Boolean(false)]), );// Expected output: &#39;[3,&quot;false&quot;,false]&#39; //undefined、任意的函数以及 symbol 值, 在序列化过程中会被转换成 null. console.log(JSON.stringify(&#123; x: [10, undefined, function () &#123;&#125;, Symbol(&#39;&#39;)] &#125;));// Expected output: &#39;&#123;&quot;x&quot;:[10,null,null,null]&#125;&#39; //以 symbol 为属性键的属性都会被完全忽略掉 JSON.stringify(&#123; [Symbol.for(&quot;foo&quot;)]: &quot;foo&quot; &#125;, [Symbol.for(&quot;foo&quot;)]);// &#39;&#123;&#125;&#39; 课上示例： &lt;script type=&quot;text/javascript&quot;&gt; var testData; testData=[ &#123;&quot;code&quot;:&quot;00001&quot;,&quot;name&quot;:&quot;王亮&quot;,&quot;sex&quot;:0,&quot;grade&quot;:2015,&quot;major&quot;:&quot;软件工程&quot;&#125;, &#123;&quot;code&quot;:&quot;00002&quot;,&quot;name&quot;:&quot;李树国 &quot;,&quot;sex&quot;:0,&quot;grade&quot;:2015,&quot;major&quot;:&quot;软件工程&quot;&#125;, &#123;&quot;code&quot;:&quot;00003&quot;,&quot;name&quot;:&quot;赵欣&quot;,&quot;sex&quot;:1,&quot;grade&quot;:2015,&quot;major&quot;:&quot;空间信息&quot;&#125; ]; function WriteStList(data)&#123; var studentList=data; var strHtml=&quot;&quot;; strHtml+=&quot;&lt;table width=\\&quot;100%\\&quot; border=\\&quot;0\\&quot; cellpadding=\\&quot;0\\&quot; cellspacing=\\&quot;0\\&quot; align=\\&quot;center\\&quot;&gt; &quot;; for(var i=0;i&lt;studentList.length;i++)&#123; strHtml+=&quot;&lt;tr class=\\&quot;td_&quot;+(i%2+1)+&quot;\\&quot;&gt;&quot;; strHtml+=&quot;&lt;td width=\\&quot;15%\\&quot;&gt;&quot;+studentList[i][&quot;code&quot;]+&quot;&lt;/td&gt;&quot;; strHtml+=&quot;&lt;td width=\\&quot;15%\\&quot;&gt;&quot;+studentList[i][&quot;name&quot;]+&quot;&lt;/td&gt;&quot;; strHtml+=&quot;&lt;td width=\\&quot;15%\\&quot;&gt;&quot;+(studentList[i][&quot;sex&quot;]==0?&quot;男&quot;:&quot;女&quot;)+&quot;&lt;/td&gt;&quot;; strHtml+=&quot;&lt;td width=\\&quot;15%\\&quot;&gt;&quot;+studentList[i][&quot;grade&quot;]+&quot;&lt;/td&gt;&quot;; strHtml+=&quot;&lt;td width=\\&quot;15%\\&quot;&gt;&quot;+studentList[i][&quot;major&quot;]+&quot;&lt;/td&gt;&quot;; strHtml+=&quot;&lt;td&gt;&lt;a href=\\&quot;student_edit.html\\&quot;&gt;编辑&lt;/a&gt;&quot;; strHtml+=&quot;&lt;a href=\\&quot;JavaScript:alert(&#39;准备删除学号为&quot;+studentList[i][&quot;code&quot;]+&quot;的学生信息&#39;)\\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; strHtml+=&quot;&lt;/table&gt;&quot;; document.getElementById(&quot;studentsSpan&quot;).innerHTML =strHtml; &#125; &lt;/script&gt; 25.JSP开发中最常用的两种设计模式1.JSP+JavaBean&nbsp;&nbsp; &nbsp; 用户通过客户端请求WEB服务器, 服务端接收请求后调用JSP页面, JSP中调用JavaBean, JavaBean中连接和操作数据库实现业务逻辑后将结果返回到JSP页面, WEB服务器读取JSP中的内容并将最终结果返回到客户端中进行显示. 2.MVC模式&nbsp;&nbsp; &nbsp; 即模型-视图-控制器.&nbsp;&nbsp; &nbsp; 模型: 用于存储数据的对象(一个或多个JavaBean对象). 视图:显示模型中的数据(一个或多个JSP页面). 控制器:业务逻辑操作(一个或多个servlet对象). 26.JSP技术的MVC模式描述 &nbsp;&nbsp; &nbsp; 用户通过浏览器发送请求到servlet, servlet将调用JavaBean完成数据的操作处理与封装并调用相应的JSP页面, JSP页面将调用JavaBean获取需要的数据, 最终将结果返回到客户端浏览器上进行显示. 27.JSP页面中的Java脚本标记包括哪三种元素 JSP表达式: &lt;%&#x3D; %&gt;声明标识: &lt;%! %&gt;脚本程序: &lt;% %&gt; 28.JSP页面中&lt;%! %&gt;标记的用途 声明变量或代码. 29.JSP内置对象 request: 请求对象response: 响应对象out: JSP输出流对象session: 会话对象application: ServletContext对象config: ServletConfig对象page: 指向当前jsp的对象pageContext: jsp上下文对象exception: 异常对象 30.JSP第一次访问过后，将生成一个exe文件 错误. 转换为一个servlet文件, servlet文件编译为class文件后再执行.JSP页面转换为java类, 该类继承了HttpJspBase类, 而HttpJspBase类继承了HttpServlet类, 故一个JSP可以理解为一个Servlet. 31.转发和重定向的区别 转发可以通过request对象直接传递到目标页面, 而重定向需要使用更大范围的Session等方式进行传递.转发是服务器内部行为, 过程中, 浏览器URL是不会发生变化的; 而重定向过程中, 浏览器会根据新的URL发送请求. 32.JavaBean的特点, 一次编写, 任何地方执行, 任何地方重用 JavaBean用于封装对象, 要提供get、set方法. public class MyClass &#123; private String propertyName; public String getPropertyName() &#123; return propertyName; &#125; public void setPropertyName(String propertyName) &#123; this.propertyName = propertyName; &#125; &#125; 33.根据用途JavaBean分类 通用工具JavaBean: 实现基本功能(字符转换、类型转换等)值JavaBean: 封装实体业务处理JavaBean: 处理数据 34.不可视化JavaBean的属性主要有哪些 get、set、构造方法之类. 35.JavaBean编写规范 实现java.io.Serializable接口 是一个公共类 存在无参数的构造函数 提供set、get方法 36.JDBC访问数据库过程 加载驱动程序 -&gt; 建立数据库连接 -&gt; 执行sql语句 -&gt; 处理结果 -&gt; 关闭连接 String diverClass= &quot;com.mysql.jdbc.Driver&quot;; String dbUrl= &quot;jdbc:mysql://localhost:3306/db_database08&quot;; //1、建立数据库连接 Class.forName(diverClass); // 1.1加载驱动程序 Connection con= DriverManager.getConnection (dbUrl, “root&quot;, “rootpassword&quot;); //1.2创建链接 //2、执行SQL语句(不建议用statement了) Statement sql=con.createStatement(); //2.1创建sql语句执行对象 ResultSet rs=sql.executeQuery(&quot;select * from tb_user”); //2.2执行sql //3、处理SQL语句执行结果 while(rs.next())&#123; 获取记录中每个字段的数据 &#125;//遍历结果集对象 //4、关闭数据库连接 rs.close(); sql.close(); con.close(); 37.JDBC常用接口及其描述&nbsp;&nbsp; &nbsp; Driver: 驱动程序接口, 用于加载驱动. Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 加载类时自动注册mysql驱动 &nbsp;&nbsp; &nbsp; DriverManager: 管理用户与数据库连接, 一般使用getConnection方法. DriverManager.getConnection(String url, String user, String password) // 连接数据库 &nbsp;&nbsp; &nbsp; Connection: 数据库连接接口, 有close方法. Connection conn = DriverManager.getConnection(url, user, password); &nbsp;&nbsp; &nbsp; Statement: 执行静态Sql语句, 返回结果集ResultSet, 不推荐(存在sql注入问题) &nbsp;&nbsp; &nbsp; PreparedStatement: 执行动态Sql语句, 需要填充占位符”?”. String sql = &quot;select * from users WHERE name = ?&quot;; // sql语句 PreparedStatement ps = conn.prepareStatement(sql)l //预编译 ps.setObject(1, &quot;bin&quot;); //填充占位符, 注意是从1开始编号 ResultSet rs = ps.executeQuery(); //执行sql语句 &nbsp;&nbsp; &nbsp; CallableStatement: 调用存储过程, 继承于PreparedStatement. &nbsp;&nbsp; &nbsp; ResultSet: 类似于sql中的一个表, 可以获得表行列的数据.&nbsp;&nbsp; &nbsp; ResultSet维护了一个指向当前数据行的游标, 可以通过next()方法移动到下一行并判断该行是否有效.相当于Iterator的hasNext()与next()的结合. public static &lt;T&gt; List&lt;T&gt; newselect1(Class&lt;T&gt; clazz, String sql, Object ...args)&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i + 1, args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); int count = rsmd.getColumnCount(); ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while(rs.next())&#123; T t = clazz.newInstance(); for (int i = 0; i &lt; count; i++)&#123; Object columnValue = rs.getObject(i + 1); String columnName = rsmd.getColumnLabel(i + 1); Field field = t.getClass().getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnValue); &#125; list.add(t); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; JDBCUtils.closeResource(conn, ps, rs); &#125; &#125; 38.PreparedStatement接口的特点 PreparedStatement是Statement的子接口, 它的重要特点是预编译, 性能提升的同时还可以防止SQL注入的问题. 39.Resultset接口 同37. 40.DBManager类获得数据库连接, 执行sql查询操作流程 同37.使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动, 但在调用Driver接口时, 自动执行静态代码块, 所以不需要额外编写, 只需加载类即可. 41.业务逻辑Bean(获取数据库数据封装到值型JavaBean)流程&nbsp;&nbsp; &nbsp; 1.定义JavaBean public class User &#123; private int id; private String username; private String email; // 省略 getter 和 setter 方法 &#125; &nbsp;&nbsp; &nbsp; 2.创建业务逻辑Bean import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class UserBean &#123; // 获取数据库连接 private Connection getConnection() throws SQLException &#123; // 实现获取数据库连接的逻辑，可以使用连接池等方式 // 返回数据库连接对象 &#125; // 查询所有用户信息 public List&lt;User&gt; getAllUsers() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); try (Connection connection = getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(&quot;SELECT * FROM user&quot;); ResultSet resultSet = preparedStatement.executeQuery()) &#123; while (resultSet.next()) &#123; User user = new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setUsername(resultSet.getString(&quot;username&quot;)); user.setEmail(resultSet.getString(&quot;email&quot;)); userList.add(user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); // 实际中应该进行异常处理 &#125; return userList; &#125; &#125; 42.Servlet的生命周期 1.用户通过客户端浏览器请求服务器，服务器加载Servlet，并创建一个Servlet实例. 2.容器调用Servlet的init()方法构造. 3.容器调用service()方法，并将HttpServletRequest和HttpServletResponse对象传递给该方法，在service()方法中处理用户请求. 4.在Servlet中请求处理结束后，将结果返回给容器. 5.容器将结果返回给客户端进行显示. 6.当Web服务器关闭时，调用destroy()方法销毁Servlet实例. 43.web.xml中servlet配置的XML标记&lt;servlet&gt; //定义servlet &lt;servlet-name&gt;EmpServlet&lt;/servlet-name&gt; //servlet名称 &lt;servlet-class&gt;cuit.emp.EmpServlet&lt;/servlet-class&gt; //servlet类 &lt;/servlet&gt; &lt;servlet-mapping&gt; //定义servlet映射 &lt;servlet-name&gt;EmpServlet &lt;/servlet-name&gt; //servlet名称 &lt;url-pattern&gt; /servlet/EmpServlet &lt;/url-pattern&gt; //servlet地址 &lt;/servlet-mapping&gt; 44.Ajax代码异步请求方式传统派： let s = document.getElementById(&quot;btn&quot;); s.onclick = function()&#123; let xhr = new XMLHttpRequest(); //创建Ajax对象 xhr.open(&quot;GET&quot;, url, true); //设置属性 xhr.send(); //提交请求 xhr.onreadystatechange = function()&#123; //接受返回内容 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; &#125; &#125; &#125; 维新派: $.get(&quot;deal.jsp&quot;, &#123;name:&quot;无语&quot;,branch:&quot;java&quot;&#125; ); $.post(&quot;deal.jsp&quot;, &#123;title:&quot;祝福&quot;,content:&quot;祝愿天下的所有母亲平安、健康…&quot;&#125;, function(data)&#123; alert(data); &#125; ); 45.服务器端servlet相应处理请求流程(获取表单参数、校验和提交、生成响应) &nbsp;&nbsp; &nbsp; 用户在客户端浏览器中发送请求至WEB服务器, WEB服务器调用实例servlet的service方法创建一个request和response对象, servlet从request中读取信息, 处理数据后将其写入response中封装, 由WEB服务器传回数据给客户端浏览器. 46.Ajax请求获取列表形式的JSON数据document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123; var xhr = new XMLHttpRequest(); // 创建 XMLHttpRequest 对象 xhr.open(&quot;GET&quot;, &quot;your_backend_endpoint&quot;, true); // 配置请求 xhr.responseType = &quot;json&quot;; // 设置响应类型为 JSON xhr.onload = function () &#123; if (xhr.status === 200) &#123; // 请求成功，处理返回的 JSON 数据 var userList = xhr.response; renderUserList(userList); &#125; else &#123; console.error(&quot;Failed to fetch user data. Status code: &quot; + xhr.status); // 请求失败，处理错误 &#125; &#125;; xhr.onerror = function () &#123; // 处理网络错误时的回调函数 console.error(&quot;Network error occurred&quot;); &#125;; xhr.send(); //发送请求 &#125;); function renderUserList(userList) &#123; var userListElement = document.getElementById(&quot;userList&quot;); userListElement.innerHTML = &quot;&quot;; // 遍历用户列表并添加到 HTML 中 userList.forEach(function (user) &#123; var listItem = document.createElement(&quot;li&quot;); listItem.textContent = &quot;ID: &quot; + user.id + &quot;, Name: &quot; + user.name + &quot;, Email: &quot; + user.email; userListElement.appendChild(listItem); &#125;); &#125; 47.Spring MVC是对Servlet的再封装 正确. Spring MVC通过对Servlet进行封装,提供了更高级别的抽象,使得Web应用程序的开发更加简便和灵活. 48.Spring MVC的工作原理 1．客户端请求提交到DispatcherServlet. 2．由DispatcherServlet控制器寻找一个或多个HandlerMapping,找到处理请求的Controller. 3．DispatcherServlet将请求提交到Controller. 4．Controller调用业务逻辑处理后，返回ModelAndView. 5．DispatcherServlet寻找一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图. 6．视图负责将结果显示到客户端. 49.Spring容器管理的bean默认是单实例的 正确. 应用程序启动时, Spring容器都会创建并初始化Bean, 每次请求该Bean时, 都会返回相同的实例. 50.Spring配置文件名是固定的 错误. 可以更改,最好固定. 51.Spring用标签定义对象时, 标签中必须申明id 错误. 不声明id时, Spring自动生成一个唯一的标识符. 52.Spring获取容器创建的对象的方法 ApplicationContext接口 和 注解. 53.Spring AOP的一个切入点可能横切多个业务组件。 正确. 54.Spring容器实现了I0C和AOP机制, 这些机制可以简化Bean对象创建和Bean对象之间的解耦。 正确. 55.@Autowired用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作，默认按照Bean的名称进行装配 正确. 56.Hibernate和MyBatis均是全自动映射的框架 错误. Mybatis是半自动映射框架. 57.Hibernate和MyBatis都可以自动生成SQL 错误. Mybatis不能. 58.应用在Web应用中的数据库系统有哪些 MySQL、PostgreSQL、Oracle、Redis、Microsoft SQL Server等. 59.使用MyBatis框架,一般需要先建立与数据库表对应的实体类。 正确. 60.MyBatis和Hibernate是目前流行的ORM框架. 正确. 61.MyBatis 的程序里最终使用的对象 数据库表对应的 Java 对象(实体类、POJO). 62.MyBatis工作流程或主要步骤 1．读取MyBatis配置文件mybatis-config.xml, 该文件配置了MyBatis的运行环境等信息.2．加载SQL映射文件, 文件中配置了操作数据库的SQL语句, 需要在mybatis-config.xml中加载, 可以加载多个映射文件.3．构建会话工厂SqlSessionFactory.4．创建SqlSession对象, 该对象中包含执行SQL语句的所有方法.5．使用Executor接口来操作数据库, 根据SqlSession传递的参数动态地生成需要执行的SQL语句,同时负责查询缓存的维护.6．在Executor接口的执行方法中有MappedStatement类型参数, 该参数是对映射信息的封装, 用于存储要映射的SQL语句的id、参数等信息.7．输入参数映射. 输入参数类型可以是Map、List等集合类型,也可以是基本数据类型和POJO类型, 输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程.8．输出结果映射. 输出结果类型可以是Map、List等集合类型,也可以是基本数据类型和POJO类型, 输出结果映射过程类似于JDBC对结果集的解析过程. 63.MyBatis映射文件中的常用元素及其作用select &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE id = #&#123;id&#125; &lt;/select&gt; insert &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; INSERT INTO users (username, password) VALUES (#&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt; update &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; UPDATE users SET username = #&#123;username&#125;, password = #&#123;password&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; delete &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; DELETE FROM users WHERE id = #&#123;id&#125; &lt;/delete&gt; resultMap &lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt; &lt;/resultMap&gt; 64.MyBatis中动态SQL的常用元素及其作用if元素: 判断 &lt;select id=&quot;getUsers&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users &lt;where&gt; &lt;if test=&quot;username != null&quot;&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; AND email = #&#123;email&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; choose、when、otherwise: switch &lt;select id=&quot;getUsers&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;username != null&quot;&gt; AND username = #&#123;username&#125; &lt;/when&gt; &lt;when test=&quot;email != null&quot;&gt; AND email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; AND status = &#39;ACTIVE&#39; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; trim、set: 修剪 &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; UPDATE users &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125; &lt;/update&gt; foreach: 迭代 &lt;select id=&quot;getUsersByIdList&quot; parameterType=&quot;list&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE id IN &lt;foreach collection=&quot;idList&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; blind: 定义变量 &lt;select id=&quot;getUsersByNameAndAge&quot; parameterType=&quot;map&quot; resultType=&quot;User&quot;&gt; &lt;bind name=&quot;nameCondition&quot; value=&quot;&#39;%&#39; + name + &#39;%&#39;&quot;/&gt; SELECT * FROM users WHERE name LIKE #&#123;nameCondition&#125; AND age = #&#123;age&#125; &lt;/select&gt; 65.Spring中的通知按照在目标类方法的连接点位置,分为5种通知 环绕通知: 在目标方法执行前和执行后实施增强.前置通知: 在目标方法执行前实施增强.后置返回通知: 在目标方法成功执行后实施增强.最终通知: 不管是否发生异常, 在目标方法执行后实施增强.异常通知: 在方法抛出异常后实施增强. 66.Hibernate和MyBatis和JDBC各自特点和优势 JDBC: 简单直接,适用于小型项目或者需要直接控制数据库操作的场景, 基于标准化, 可以与任何支持JDBC的数据库进行交互.Hibernate: ORM框架, 不需要编写SQL语句.Mybatis: 使用连接池管理, 提供了更多的抽象和方便的映射, 基于XML配置的持久化框架,将Java对象映射到数据库中的SQL语句. 67.JSP、Servlet、SpringMVC各自优势 JSP: 使用标记语言, 在HTML中嵌入Java代码, 易于上手; 将Java代码与HTML结合, 实现前端和后端的紧密集合, 开发网页相对简单; 通常用于表示视图层, 与Servlet结合使用.Servlet: 控制强大, 可以处理请求、响应、会话管理等功能; 编写Java代码处理HTTP请求和响应, 具有强大的灵活性; 适用于处理业务逻辑, 实现底层逻辑控制.SpringMVC: 模块化和松耦合, 通过使用MVC架构, 将应用程序分为模型、视图和控制器, 实现了更好的松耦合; 支持AOP, 允许开发人员通过切面处理横切关注点; 拥有强大的配置, 允许使用注解或XML配置定义映射、拦截器等; 与SpringBoot等整合, 提供了更全面的解决方案. 68.Spring框架的优势和特点 轻量级和非侵入性: Spring是一个轻量级的框架,不需要大量的配置信息,使得开发更加简单;不需要继承特定的类或实现特定的接口,可以与其他框架和应用程序集成.依赖注入: 提供了依赖注入机制,通过IoC容器管理对象的依赖关系,降低了组件之间的耦合度, 对象的创建和组装由Spring容器负责,提高了代码的可维护性和可测试性.面向切面编程: 支持AOP,允许通过切面在应用程序中横切关注点,如事务管理、日志记录等. 可以将横切关注点从核心业务逻辑中分离,提高了代码的模块化和可重用性.模块化设计: Spring采用了模块化的设计,各个模块提供不同的功能,如数据访问、事务管理、消息传递. 可以选择性地使用这些模块，根据项目需求进行集成.数据访问抽象层： 提供了一致的数据访问抽象层,支持多种数据访问技术,如JDBC、Hibernate、JPA等.简化了数据访问代码的编写，提高了灵活性.事务管理: 支持声明式事务管理,通过注解或XML配置,简化了事务的控制. 提供了编程式事务管理的方式,允许更细粒度的控制事务.灵活配置： 支持多种配置方式,包括XML配置、注解配置、Java配置等.","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"年末总结与未来计划","slug":"近期计划","date":"2023-12-23T15:50:26.000Z","updated":"2024-01-10T11:17:21.098Z","comments":true,"path":"2023/12/23/近期计划/","link":"","permalink":"https://sakb1n.github.io/2023/12/23/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/","excerpt":"","text":"今年总结： 买一张SSD 买一台显示器(在攒钱ing) 把sql学会(慢慢来吧) 拿到学校奖学金 今年心愿已经基本完成. 如果顺利的话, 寒假将开始学习Spring系列, 同时下一篇博客也将在明年1月更新, 不出意外的话大概这就是今年的最后一篇博客吧。 提前, 祝, 大家, 新年快乐! 希望各位在未来的道路上继续向前吧！","categories":[],"tags":[]},{"title":"markdown","slug":"markdown","date":"2023-12-23T15:45:31.000Z","updated":"2024-03-04T16:32:23.219Z","comments":true,"path":"2023/12/23/markdown/","link":"","permalink":"https://sakb1n.github.io/2023/12/23/markdown/","excerpt":"MarkdownMarkdown非常适合写博客,这里介绍markdown","text":"MarkdownMarkdown非常适合写博客,这里介绍markdown 字体*这是五个字* 斜体 _这是五个字_ 斜体 **这是五个字** 加粗 ***这是五个字*** 倾斜加粗 ~~这是五个字~~ 下划线 斜体这也是斜体加粗斜体加粗下划线 标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 一级标题二级标题三级标题四级标题链接插入图片: ![图片名](&quot;路径&quot;) 插入链接: [这是一个链接](http://www.example.com/) 路径可以为本地路径也可以为网络路径 可爱的白洲梓同学 这是白洲梓同学的资料哦~; 杂项代码块: ```内容``` 引用: &gt; 无序列表 *, + 或 - 号都可以 有序列表 1. 这是代码块 这是引用 这是无序列表 这是有序列表 关于博客常用部分介绍到这里, 有关表格等部分, 请自行百度. 明年再见喵~","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Recollection--DFS","slug":"Recollection-DFS","date":"2023-11-25T13:28:21.000Z","updated":"2024-03-04T16:32:31.787Z","comments":true,"path":"2023/11/25/Recollection-DFS/","link":"","permalink":"https://sakb1n.github.io/2023/11/25/Recollection-DFS/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近在学javaweb, 把自己博客给忘得差不多了，于是水篇文章证明我还活着() DFS(深度优先搜索)概述&nbsp;&nbsp;&nbsp;&nbsp;深度优先搜索 (Depth-first-search) 是一种图的算法, 以深度作为方向进行搜索,找到所需要的答案, 直到所有方案搜索完为止，其本质依然是暴力。 &nbsp;&nbsp;&nbsp;&nbsp;走入迷宫, 向一条路径一直走下去直到走到死路为止, 再回返到最近的一个路口走另一条没有走过的路，依次类推…&nbsp;&nbsp;&nbsp;&nbsp;实现dfs的核心是标记与回溯。","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近在学javaweb, 把自己博客给忘得差不多了，于是水篇文章证明我还活着() DFS(深度优先搜索)概述&nbsp;&nbsp;&nbsp;&nbsp;深度优先搜索 (Depth-first-search) 是一种图的算法, 以深度作为方向进行搜索,找到所需要的答案, 直到所有方案搜索完为止，其本质依然是暴力。 &nbsp;&nbsp;&nbsp;&nbsp;走入迷宫, 向一条路径一直走下去直到走到死路为止, 再回返到最近的一个路口走另一条没有走过的路，依次类推…&nbsp;&nbsp;&nbsp;&nbsp;实现dfs的核心是标记与回溯。 模版 void dfs(int x)&#123; if(满足停止搜索条件)&#123; ... //处理 return; &#125; for (int i = 0; i &lt; length; i++)&#123; if (没有搜过该点)&#123; vis[x] = 1; //标记搜过 dfs(x + 1); //递归 vis[x] = 0; //取消标记(回溯) &#125; &#125; &#125; dfs变化多样,不一定就要照着模版写。 题目尝试 C语言新手, 请多多指教。 CF6A Triangle &nbsp;&nbsp;&nbsp;&nbsp;这是一道入门题, 数据少也不卡时间, 可以直接通过暴力枚举得到结果简单方便, 但还是用dfs来练练手() &nbsp;&nbsp;&nbsp;&nbsp;我们可以先将所有木棍从小到大排序,当我们任意取出3根木棍时，这3根木棍的长度一定是有序的,判断三角形时只需要将1、2号木棍与3号木棍长度进行比较即可。 AC代码: #include&lt;stdio.h&gt; #include&lt;bits/stdc++.h&gt; using namespace std; //直接调用C++的sort排序，懒得写排序了。 //arr进行数据读入，arr1放入需判断的三根木棍, con代表状态。 int arr[4], arr1[4], i, con = 0; void dfs(int cur, int w)//cur代表已读入木棍数，该值等于3则开始判断三角形情况。 &#123; if (cur == 3) &#123; //大于为三角形，等于为退化三角形 if(arr1[0] + arr1[1] &gt; arr1[2]) &#123; con = 1; &#125; else if (con == 0 &amp;&amp; arr1[0] + arr1[1] == arr1[2]) //为什么要判断con==0呢 &#123; con = 2; &#125; &#125; else &#123; /* w表示当前搜索到的位置 我们从头开始理,最开始主程序调用dfs时: 1.w = 0, cur = 0, 会进入到这里，j = 0开始循环, arr1放入0号元素, 递归; 2.w = 1, cur = 1, 依然进入到这里, j = 1开始循环, arr1放入1号元素, 递归; 3.w = 2, cur = 2, 依然进入到这里, j = 2开始循环, arr1放入2号元素, 递归; 4.cur = 3, 判断条件，这里结束后将返回到第3步; 5.第3步此时位于j = 2的循环中，dfs结束后，j++后变为3, arr1将不再放入2号元素而是放入3号元素，递归; 6.cur = 3, 判断条件，这里结束后将返回到第3步; 7.第3步到达循环末尾，再回到第2步,第2步j++后变为2,取3号元素，以此类推... 8.你应该能理解为什么要写循环了。 */ for (int j = w; j &lt; 4; j++) &#123; arr1[cur] = arr[j]; //放入arr1数组 dfs(cur + 1, j + 1); //当前数量+1并递归搜索 &#125; &#125; &#125; int main(void) &#123; for (i = 0; i &lt; 4; i++) &#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; sort(arr, arr + 4); //快排 dfs(0,0); //dfs开始搜索 if (con == 1) &#123; printf(&quot;TRIANGLE&quot;); &#125; else if (con == 0) &#123; printf(&quot;IMPOSSIBLE&quot;); &#125; else &#123; printf(&quot;SEGMENT&quot;); &#125; &#125; CF629A Far Relative’s Birthday Cake &nbsp;&nbsp;&nbsp;&nbsp;解释解释到底说了什么：只要在一行或一列上找到一对CC,就得到一点幸福指数，求总幸福指数。 &nbsp;&nbsp;&nbsp;&nbsp;我们使用dfs进行搜索时带上一个数组arr1,用它来标记是否搜索过该元素,递归完成后取消标记,这就是标记与回溯。 AC代码: #include&lt;stdio.h&gt; const int MAX = 110; int n, arr[MAX][MAX] = &#123;0&#125;, arr1[MAX][MAX], count = 0, i, j; void dfs(int a, int b)&#123; //判断条件:x轴上的b小于n或y轴上的a小于n if ((a == i &amp;&amp; b &lt; n) || (b == j &amp;&amp; a &lt; n)) &#123; if (arr[a][b] == 1 &amp;&amp; arr1[a][b] != 1) &#123; //标记解 count++; &#125; //往下和右递归调用 dfs(a+1, b); dfs(a,b+1); &#125; &#125; int main(void) &#123; //读入,将str数组转化为arr数组 scanf(&quot;%d\\n&quot;, &amp;n); for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; n; j++) &#123; char temp; scanf(&quot;%c&quot;, &amp;temp); if (temp == &#39;C&#39;) &#123; arr[i][j] = 1; &#125; else if (temp == &#39;.&#39;)&#123; arr[i][j] = 0; &#125; &#125; if (i != n - 1) &#123; scanf(&quot;\\n&quot;); &#125; &#125; //只是把dfs的循环拿出来用了，原理一致。 for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; n; j++) &#123; if (arr[i][j] == 1) &#123; //标记与回溯 arr1[i][j] = 1; dfs(i, j); arr1[i][j] = 0; &#125; &#125; &#125; printf(&quot;%d&quot;, count); &#125; P1706 全排列问题 &nbsp;&nbsp;&nbsp;&nbsp;经典题,与上题思想一致,使用dfs深度搜索,用另一个数组去标记是否搜索过该数。 &nbsp;&nbsp;&nbsp;&nbsp;与第一道题不同, 我们所搜索的元素只可能在当前位置之后, 所以直接从当前位置循环, 而此题的排列没有任何顺序可言,我们从数组中遍历没有被标记的元素来作为下一个应该排的位置,所以区别还是挺大的() AC代码: #include&lt;stdio.h&gt; int a[10], v[10], n; void dfs(int t)&#123; if (t == n + 1) &#123; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot; %d&quot;, a[i]); &#125; printf(&quot;\\n&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if(v[i] != 1) &#123; v[i] = 1; a[t] = i; dfs(t + 1); v[i] = 0; &#125; &#125; &#125; int main(void) &#123; scanf(&quot;%d&quot;, &amp;n); dfs(1); &#125; P1451 求细胞数量 &nbsp;&nbsp;&nbsp;&nbsp;连通块问题,只要连通的区域统统都算1个,直接dfs,将要搜索的设为1,dfs搜索到的区域统统变为0,注意递归时是朝东南西北四个方向进行搜索, 当触碰到边界时停止搜索。 AC代码: #include&lt;stdio.h&gt; const int MAX = 110; int m, n; int arr[MAX][MAX]; int count = 0; //方向数组,分别对应东南西北。 int dx[4] = &#123;0,0,1,-1&#125;; int dy[4] = &#123;1,-1,0,0&#125;; void dfs(int a, int b) &#123; arr[a][b] = 0; for (int i = 0; i &lt; 4; i++) &#123; a += dx[i]; b += dy[i]; //判断搜索条件 if (a &lt;= m &amp;&amp; a &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; arr[a][b] == 1) &#123; dfs(a, b); &#125; a -= dx[i]; b -= dy[i]; &#125; &#125; int main(void) &#123; scanf(&quot;%d%d\\n&quot;,&amp;m,&amp;n); char temp; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf(&quot;%c&quot;, &amp;temp); if (temp &lt;= &#39;9&#39; &amp;&amp; temp &gt; &#39;0&#39;) &#123; arr[i][j] = 1; &#125; else &#123; arr[i][j] = 0; &#125; &#125; if (i != m) &#123; scanf(&quot;\\n&quot;); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (arr[i][j] == 1) &#123; dfs(i, j); //得到其一解 ++count; &#125; &#125; &#125; printf(&quot;%d&quot;, count); &#125; P1506 拯救oibh总部 &nbsp;&nbsp;&nbsp;&nbsp;如果你依然想套用上一题并信心满满的提交时,你会收到全WA的惊喜(我也一样233) &nbsp;&nbsp;&nbsp;&nbsp;其实我们可以在最外围搜一圈,凡是被洪水淹没的地段都设为1,最后循环查找没被淹没的地方(值为0的地方)就行了() AC代码: #include&lt;stdio.h&gt; const int MAX = 510; int arr[MAX][MAX], m, n, count = 0; //方向数组 int ax[4] = &#123;0, 0, 1, -1&#125;; int ay[4] = &#123;1, -1, 0, 0&#125;; void dfs(int x, int y) &#123; int x1, y1; arr[x][y] = 1; for (int i = 0; i &lt; 4; i++) &#123; x1 = x + ax[i]; y1 = y + ay[i]; if (x1 &gt;= 0 &amp;&amp; x1 &lt; n &amp;&amp; y1 &gt;=0 &amp;&amp; y1 &lt; m &amp;&amp; arr[x1][y1] == 0) &#123; dfs(x1, y1); &#125; &#125; &#125; int main(void) &#123; //读入 scanf(&quot;%d%d\\n&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; char temp; scanf(&quot;%c&quot;, &amp;temp); if (temp == &#39;0&#39;) &#123; arr[i][j] = 0; &#125; else&#123; arr[i][j] = 1; &#125; &#125; if (i != n - 1) &#123; scanf(&quot;\\n&quot;); &#125; &#125; //在最外面一圈进行搜索 for (int i = 0; i &lt; m; i++) &#123; if (arr[0][i] == 0) &#123; dfs(0, i); &#125; if (arr[n - 1][i] == 0) &#123; dfs(n - 1, i); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (arr[i][0] == 0) &#123; dfs(i, 0); &#125; if (arr[i][m - 1] == 0) &#123; dfs(i, m - 1); &#125; &#125; //统计没有被淹没的地段 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (arr[i][j] == 0) &#123; count++; &#125; &#125; &#125; printf(&quot;%d&quot;, count); &#125; P1036 [NOIP2002 普及组] 选数 &nbsp;&nbsp;&nbsp;&nbsp;此题跟其他dfs题如出一辙,可以说照着模版写就是了,唯一可能卡的点是判断是否为质数: int prime(int sum) &#123; for (int i = 2; i * i &lt;= sum; i++) &#123; if (sum % i == 0) &#123; return 0; &#125; &#125; return 1; &#125; dfs部分不作展示。 [USACO10OCT] Lake Counting S &nbsp;&nbsp;&nbsp;&nbsp;也是一般dfs思路,唯一不同的地方在于为八个方向,只需要将方向数组修改就行了。 //东、东南、南、西南、西、西北、北、东北 int ax[9] = &#123;0, 0, 1, 1, 1, 0, -1, -1, -1&#125;; int ay[9] = &#123;0, 1, 1, 0, -1, -1, -1, 0, 1&#125;; dfs部分不作展示。 [USACO1.5] 八皇后 Checker Challenge &nbsp;&nbsp;&nbsp;&nbsp;喜欢我八皇后吗,说实话,真的没一点思路。 &nbsp;&nbsp;&nbsp;&nbsp;在这个棋盘上,行列对角线上只能存在一个棋子,我写了点。 AC代码: #include&lt;stdio.h&gt; #include&lt;math.h&gt; //分别对应行,主对角线,副对角线,答案数组。 int col[14], d1[30], d2[50], ans[14]; int n, w = 0; void dfs(int x) &#123; if (x &gt; n) &#123; //题只要求输出前3种情况,所以w&lt;3,随后只让解的个数增加 if (w &lt; 3) &#123; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d &quot;, ans[i]); &#125; printf(&quot;\\n&quot;); &#125; w++; &#125; else &#123; for (int k = 1; k &lt;= n; k++) &#123; //平行的主对角线满足该特征:它们的行与列之差固定,但可能为负值,故再加上一个n。 int z = x + k - 1; //平行的副对角线满足该特征:它们的行与列之和固定。 int t = x - k + n; if (!col[k] &amp;&amp; !d1[z] &amp;&amp; !d2[t]) &#123; ans[x] = k;col[k] = 1;d1[z] = 1;d2[t] = 1; dfs(x + 1); col[k] = 0;d1[z] = 0;d2[t] = 0; &#125; &#125; &#125; &#125; int main(void) &#123; scanf(&quot;%d&quot;, &amp;n); dfs(1); printf(&quot;%d&quot;, w); &#125; P1189 SEARCH &nbsp;&nbsp;&nbsp;&nbsp;这个题的意思是给你一个初始地与N个方向,N个方向都要按顺序使用,寻找到它最终的落脚点,这题DFS和BFS都可以用 &nbsp;&nbsp;&nbsp;&nbsp;参考：dingcx:P1189 SEARCH&nbsp;&nbsp;&nbsp;&nbsp;考虑直接使用dfs会超时,我们选择优化,因为在dfs搜索过程中会出现多条路都通向一个节点的情况,我们在标记数组中加入方向长度减少这种情况,就进行优化,详细请读一读上面这篇文章~ AC代码: #include&lt;stdio.h&gt; const int MAX = 55; const int MAXN = 1010; int m, n, arr[MAX][MAX], arr1[MAXN][MAX][MAX], stx, sty, N, dir[MAXN]; int f[5][2] = &#123;0,0,0,1,1,0,0,-1,-1,0&#125;; void dfs(int len, int x, int y) &#123; if (arr1[len][x][y] == 1) &#123; return; &#125; else &#123; int x1 = x, y1 = y; arr1[len][x][y] = 1; if (len == 0) &#123; return; &#125; while (1) &#123; x1 += f[dir[len]][0]; y1 += f[dir[len]][1]; if (arr[x1][y1] == 1 || x1 &lt; 0 || x1 &gt;= m || y1 &lt; 0 || y1 &gt;= n) &#123; break; &#125; dfs(len - 1, x1, y1); &#125; &#125; &#125; int main(void) &#123; scanf(&quot;%d%d\\n&quot;, &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; char temp; scanf(&quot;%c&quot;, &amp;temp); if (temp == &#39;X&#39;) &#123; arr[i][j] = 1; &#125; else if (temp == &#39;.&#39;) &#123; arr[i][j] = 0; &#125; else&#123; stx = i; sty = j; arr[i][j] = 0; &#125; &#125; if (i != m - 1) &#123; scanf(&quot;\\n&quot;); &#125; &#125; scanf(&quot;%d\\n&quot;, &amp;N); for (int i = 1; i &lt;= N; i++) &#123; char str[10]; scanf(&quot;%s&quot;, str); if (str[0] == &#39;E&#39;) &#123; dir[N + 1 - i] = 1; &#125; else if (str[0] == &#39;S&#39;) &#123; dir[N + 1 - i] = 2; &#125; else if (str[0] == &#39;W&#39;) &#123; dir[N + 1 - i] = 3; &#125; else if (str[0] == &#39;N&#39;) &#123; dir[N + 1 - i] = 4; &#125; &#125; dfs(N, stx, sty); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (arr1[0][i][j] == 1) &#123; printf(&quot;*&quot;); &#125; else if (arr[i][j] == 0) &#123; printf(&quot;.&quot;); &#125; else&#123; printf(&quot;X&quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; &#125; 春空舞う花びらは，過ぎ去った奇跡じゃなく，巡った季節を超えても輝いて，二人の未来を彩るよ。","categories":[{"name":"算法","slug":"算法","permalink":"https://sakb1n.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://sakb1n.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"CSS学习","slug":"CSS学习","date":"2023-10-26T03:27:14.000Z","updated":"2024-03-04T16:32:03.486Z","comments":true,"path":"2023/10/26/CSS学习/","link":"","permalink":"https://sakb1n.github.io/2023/10/26/CSS%E5%AD%A6%E4%B9%A0/","excerpt":"CSS第一步CSS起步​ 1.link:&lt;link rel = &quot;stylesheet&quot; href=&quot;styles.css&quot;/&gt;​ 2.列表移除符号:list-style-type:none;​ 3.使用类名规范样式：CSS里写 .XXX​ 4.元素选择器可以与类名一起出现​ 5.包含选择符","text":"CSS第一步CSS起步​ 1.link:&lt;link rel = &quot;stylesheet&quot; href=&quot;styles.css&quot;/&gt;​ 2.列表移除符号:list-style-type:none;​ 3.使用类名规范样式：CSS里写 .XXX​ 4.元素选择器可以与类名一起出现​ 5.包含选择符 ​ 例： li em &#123; color: rebeccapurple; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将选择&lt;li&gt;内部的任何&lt;em&gt;元素（&lt;li&gt;的后代） ​ 相邻选择符 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置出现在标题后面并且与标题具有相同层级的段落样式， h1 + p &#123; font-size: 200%; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.根据标签状态确定样式 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 CSS对不同状态进行修饰 a:link &#123; //未访问链接 color: pink; &#125; a:visited &#123; //已访问链接 color: green; &#125; a:hover &#123; //鼠标悬停时 text-decoration: none; //移除下划线 &#125; CSS的组成​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS 应用于文档:外部(最常用)、内部(在head部分加入style)、内联（尽可能避免） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS用&#x2F;* *&#x2F;进行注释 选择器优先级​ 也叫层叠。 后面样式会替换较早样式 类选择器&gt;元素选择器 属性和值​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; font-size 设置字体大小 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width 设置元素宽度(默认设置内容区域的宽度) ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-color 设置元素背景色 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color 设置文本颜色 **`border`** 设置边界属性 可设置： border-width（设置边框宽度） border-style border-color /* width | style | color */ border: medium dashed green; 函数​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calc() 进行计算 .box &#123; width: calc(90% - 30px); &#125; transform函数，允许旋转，缩放，倾斜或平移指定元素，如rotate() .box &#123; transform: rotate(0.8turn); &#125; CSS如何运行浏览加载网页 载入 HTML 文件。 HTML 文件转化成DOM(文件在计算机内存中的表现形式) 拉取该 HTML 相关的大部分资源，(图片、视频和 CSS 样式)。JavaScript 则会稍后进行处理 拉取并解析，根据选择器的不同类型分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。 网页展示在屏幕上（这一步被称为着色）。 DOM​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 DOM 对应一个树形结构，标记语言中的每一个元素、属性、文字对应结构树中的一个节点。 CSS基础CSS选择器选择器列表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多个使用相同样式的 CSS 选择器，则可以被混编为一个“选择器列表” h1 &#123; color: blue; &#125; .special &#123; color: blue; &#125; 可以被合并为 h1, .special &#123; color: blue; &#125; 选择器种类类型、类与ID选择器h1 &#123; //类型选择器 &#125; .box &#123; //类选择器 &#125; #unique &#123; //id选择器 &#125; 标签属性选择器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一个元素上的某个标签的属性的存在以选择元素的不同方式 a[title] &#123; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一个有特定值的标签属性是否存在来选择 a[href=&quot;https://example.com&quot;]&#123; &#125; 伪类与伪元素​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伪类：用于样式化一个元素的特定状态 a:hover &#123; &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以包含伪元素，选择元素的某个部分 p::first-line &#123; //选择一个元素的第一行 &#125; 运算符​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其他选择器组合起来，更复杂的选择元素 article &gt; p &#123; //选择&lt;article&gt;元素的初代子元素 &#125; 类型、类和ID选择器全局选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个*，选择了文档中的所有内容。 * &#123; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全局选择器能让选择器更易读，如： article :first-child &#123; //选取&lt;article&gt;元素中第一子元素 &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易写成article:first-child，于是可以改成article *:first-child 类选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用时只需要在指定元素里加入class&#x3D;“ ”即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;避免复用，可以在类选择器前加入特定元素使其改变特定元素，如span.highlight, h1.highlight等。 多个类被应用的时候指向一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不太理解这个东西 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.notebox、.notebox.warning、.notebox.danger 知道可以这样用就行了() ID选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id选择器开头为#，用法与类选择器一致。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，一个ID只会用到一次。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在ID前面加上类型选择器 #one &#123; //id选择器 background-color: yellow; &#125; h1#heading &#123; //在id选择器前加上类型选择器 color: rebeccapurple; &#125; 属性选择器存否和值选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于一个元素自身是否存在或 各式不同的按属性值的匹配 来选取元素 选择器 示例 描述 [attr] a[title] 匹配带有一个名为attr的属性的元素 [attr&#x3D;value] 匹配带有一个名为attr的属性的元素 匹配带有一个名为attr的属性的元素，其值正为value [attr~&#x3D;value] p[class~&#x3D;”special”] 匹配带有一个名为attr的属性的元素，其值正为value，或者其值有一个或者更多，而至少有一个和value匹配。 [*attr|&#x3D;*value] div[lang|&#x3D;”zh”] 匹配带有一个名为attr的属性的元素，其值可正为value，或者开始为value，后面紧随着一个连字符。(?) 子字符串匹配选择器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你有box-warning和box-error类，想把开头为“box-”字符串的每个物件都匹配上的话，你可以用[class^=&quot;box-&quot;]来把它们两个都选中。 ​ 选择器 示例 描述 [attr^&#x3D;value] li[class^&#x3D;”box-“] 匹配带有一个名为attr的属性的元素，其值开头为value子字符串。 [attr$&#x3D;value] li[class$&#x3D;”-box”] 匹配带有一个名为attr的属性的元素，其值结尾为value子字符串 [attr*&#x3D;value] li[class*&#x3D;”box”] 匹配带有一个名为attr的属性的元素，其值的字符串中的任何地方，至少出现了一次value子字符串。 大小写敏感​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要在大小写不敏感的情况下匹配属性值，在闭合括号之前，使用i值。 li[class^=&quot;a&quot; i] &#123; color: red; &#125; 伪类和伪元素​ 用于选择处于特定状态的元素。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:first-child能选中第一个子元素。 用户行为伪类​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只会在用户以某种方式和文档交互的时候应用。用户行为伪类有时叫做动态伪类。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前用过的a:hover, a:visited 都算。 伪元素是神魔​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像在标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。 ::pseudo-element-name ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想选中一段的第一行，使用伪元素可以只选中第一行 article p::first-line &#123; font-size: 120%; font-weight: bold; &#125; 把伪类和伪元素组合起来（太难了）​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让第一段的第一行加粗，需要把:first-child和::first-line选择器放到一起 article p:first-child::first-line &#123; font-size: 120%; font-weight: bold; &#125; 生成带有::before 和::after 的内容（个人觉得没必要）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考伪类与伪元素：伪类和伪元素 - 学习 Web 开发 | MDN (mozilla.org) 关系选择器后代选择器body article p 子代关系选择器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。 article &gt; p //只选中作为&lt;article&gt;的直接子元素的&lt;p&gt;元素 ​ ul &gt; li &#123; //如果你移去指定子代选择器的`&gt;`的话，你最后得到的是后代选择器，所有的`&lt;li&gt;`会有 //个红色的边框。 border-top: 5px solid red; &#125; &lt;ul&gt; &lt;li&gt;Unordered item&lt;/li&gt; &lt;li&gt;Unordered item &lt;ol&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;/ul&gt; 邻接兄弟选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来选中恰好处于另一个在继承关系上同级的元素旁边的物件 p + img //选中所有紧随&lt;p&gt;元素之后的&lt;img&gt;元素 通用兄弟选择器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选中一个元素的兄弟元素但不直接相邻 p ~ img //选中所有的&lt;p&gt;元素后任何地方的&lt;img&gt;元素 层叠与继承CSS ：层叠样式表 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当两条同级别的规则应用到一个元素时，写在后面的会被使用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器根据优先级决定当不同选择器对应相同的元素需要使用哪个规则。 元素选择器不具体，会选择页面上该类型的所有元素，优先级会低一些。 类选择器稍微具体，会选择该页面中有特定 class 属性值的元素，优先级会高一点。 继承 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些设置在父元素上的CSS属性是可以被子元素继承的，有些则不能。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS为控制继承提供了五个特殊的通用属性值，每个CSS属性都接收这些值。 ​ inherit ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置该属性会使子元素属性和父元素相同。“开启继承”。 ​ initial ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将应用于选定元素的属性值设置为该属性的初始值。 ​ revert (en-US) ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。 ​ revert-layer (en-US) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将应用于选定元素的属性值重置为在上一个层叠层中建立的值。 ​ unset ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样 ​ ​ 重设所有属性值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all可以同时将继承值中的一个应用于所有属性（inherit、initial、unset或revert） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器如何决定该应用那个CSS规则： ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.资源顺序：超过一条规则，而且都是相同的权重，那么最后面的规则会应用。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.优先级：有些规则在最后出现，但是却应用了前面的规则。这是因为前面的有更高的优先级。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类选择器的权重大于元素选择器 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不会覆盖所有规则，只覆盖相同的属性 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先级的计算：ID * 100 + 类（类、属性、伪类） * 10 + 元素（元素、伪元素） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用选择器（*）、组合符（+、&gt;、~、’ ‘）和调整优先级的选择器（:where()）不会影响优先级。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;否定（:not()）和任意匹配（:is()）伪类对优先级没有影响，但它们的参数则会带来影响。参数中，对优先级算法有贡献的参数的优先级的最大值将作为该伪类选择器的优先级。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内联样式：style属性内的样式声明，优先于所有普通的样式。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!important覆盖所有优先级计算。强烈建议除了非常情况不要使用它。 层叠层​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我看不懂，多学点知识后再来这一节吧 盒模型​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h1、p默认情况都是块级盒子 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a、span、em、strong默认inline ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置为inline时，不会产生换行, width、height属性不起作用。垂直方向的内边距、外边距以及边框会被应用但不会把inline状态的盒子推开，而水平方向会推开。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给盒子设置width和height时实际设置的是context box. ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际大小不包括margin,会计算border、padding、content ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有替代盒模型，反正我不咋用 ​ .box &#123; box-sizing: border-box; &#125; ​ 外边距 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以为正也可以为负。设置负值会导致和其他内容重叠。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外边距折叠：外边距相接的元素将合并为一个外边距，即最大的单个外边距的大小。 边框 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用标准盒模型，边框的大小将添加宽度和高度。使用替代盒模型，边框的大小会使内容框更小。 内边距 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能设置负值 盒子模型和内联盒子​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有些属性也可以应用于内联盒子，例如span ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对一个span元素应用各种属性，高度、宽度被忽略，而边距、边框仍然生效，也不会改变与其他元素的关系。 背景与边框&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-color,background-image没必要多说了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-size调整背景图像大小 cover：浏览器将使图像足够大，完全覆盖盒子区域，同时仍然保持其宽高比。在这种情况下，图像的部分区域可能会跳出盒子外。 contain：浏览器会将图像调整到适合框内的尺寸。在这种情况下，如果图像的长宽比与盒子的长宽比不同，你可能会在图像的两边或顶部和底部出现空隙。 背景图像定位 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-position 属性允许你选择背景图片出现在它所应用的盒子上的位置 ​ background-position: top center; //水平、垂直定位 background-position: 20px 10%; //两种方式可以混用 background-position: top 20px right 10px; 定位在距顶部 20px 和右侧 10px 处 渐变背景 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你说的对，但这是什么？ 多个背景图像​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单个属性值中指定多个 background-image 值，用逗号分隔每个值。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能会出现背景图片相互重叠的情况，最后列出的背景图片位于最下层。 background-image: url(image1.png), url(image2.png), url(image3.png), url(image4.png); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的属性具有不同数量的值时，较小数量的值会循环 background-image: url(image1.png), url(image2.png), url(image3.png), url(image4.png); background-position: 10px 20px, top right; //image1为第一个值，image2为第二个值，此后循环 背景附加​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background-attachment:指定内容滚动时的滚动方式 scroll：随着页面的滚动而滚动 fixed：使元素的背景固定在视口上，不会滚动。 local：将背景固定在它所设置的元素上，所以当你滚动该元素时，背景也随之滚动。 使用background简写属性、背景的无障碍考虑​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我觉得没什么必要的其实说 .box &#123; background: linear-gradient(105deg, rgba(255,255,255,.2) 39%, rgba(51,56,57,1) 96%) center center / 400px 200px no-repeat, url(big-star.png) center no-repeat, rebeccapurple; &#125; 边框 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的东西就不写了。 圆角​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用border-radius属性设置： .box &#123; border-radius: 10px; //四个角的半径 border-top-right-radius: 1em 10%; //水平、垂直半径 &#125; 处理不同方向的文本​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;书写模式是指文本的排列方向是横向还是纵向的,使用writing-mode进行设置 h1 &#123; writing-mode: vertical-rl; //垂直方向设置从右往左 vertical-lr //垂直方向设置从左往右 horizontal-tb //水平方向设置从上至下 &#125; 逻辑属性和逻辑值​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处于纵向书写模式时，希望盒子可以向横向模式下一样得到拓宽。为了更容易实现这样的转变，用逻辑（logical）和相对变化（flow relative）代替了像宽width和高height一样的物理属性。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;横向书写模式下，映射到width的属性被称作内联尺寸（inline-size）。而映射height的属性被称为块级尺寸（block-size）。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉应该不会常用 溢出的内容​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;溢出是在盒子无法容纳下太多的内容的时候发生的，CSS不会隐藏溢出的内容。 overflow属性​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个控制元素溢出的方式。默认为visible。 ​ hidden:会隐藏掉溢出部分。 ​ scroll:将会为溢出部分设置x轴和y轴的滚动条，避免消失。 可以为单个方向设置，如overflow-y: scroll 可以让浏览器决定是否显示滚动条：overflow:auto CSS的值和单位数字、长度、百分比长度​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝对长度不受页面限制。 单位 名称 等价换算 cm 厘米 1cm &#x3D; 37.8px &#x3D; 25.2&#x2F;64in mm 毫米 1mm &#x3D; 1&#x2F;10 of 1cm px 像素 1px &#x3D; 1&#x2F;96 of 1in ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对长度受页面限制。 单位 相对于 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。 em和rem​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;em依据的是父元素的字体大小，而rem依据的是根元素的字体大小。 百分比​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元素字体的百分比依据的是其父元素大小，但不是所有都接受百分比。 颜色 关键字，如antiquewhite, blueviolet, greenyellow等 十六进制RGB值，如#02798b,#c55da1等 rgb()，如rgb(2 121 139), rgb(197 93 161)等 hsl(), 接受色调(0~360)、饱和度、亮度, 如hsl(188, 97%, 28%), hsl(321, 47%, 57%) 等 位置​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;position&gt;表示一组2D坐标，用于定位一个元素，如同这样。 background-position: left 80px; 在CSS中调整大小固有尺寸​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固有尺寸由其包含的内容决定。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图像的长和宽便是固有尺寸，当把图片放进网页时没有使用img或css进行尺寸设置，便会展示固有尺寸。 外部尺寸​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当给元素指定具体尺寸时，这便成为外部尺寸，例如给div上height和width。 min-和max-尺寸​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以设置一个元素的最大尺寸或最小尺寸。 .box &#123; border: 5px solid darkblue; min-height: 150px; width: 200px; &#125; 视口单位​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1vh为视口高度的1%，1vw为视口宽度的1%。 .box &#123; border: 5px solid darkblue; width: 10vw; height: 30vh; font-size: 10vh; &#125; 图像、媒体和表单元素图像处理溢出问题 使用max-width : 100% 保证其一直不会宽度溢出 使用object-fit属性，将图像调整到完全能够盖住一个盒子的大小。 object-fit: cover; //维持图像的原始比例，但多余部分会被裁剪 object-fit: contain; //缩放到足以完整放到盒子里的大小，但不会完全盖住 object-fit: fill; //充满盒子但不会维持比例 form元素​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没学表单，直接搬MDN上的实例了。 &lt;form&gt; &lt;div&gt;&lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot;&gt;&lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/div&gt; &lt;/form&gt; /*CSS设置*/ input[type=&quot;text&quot;], input[type=&quot;email&quot;] &#123; border: 2px solid #000; margin: 0 0 1em 0; padding: 10px; width: 100%; &#125; input[type=&quot;submit&quot;] &#123; border: 3px solid #333; background-color: #999; border-radius: 5px; padding: 10px 2em; font-weight: bold; color: #fff; &#125; input[type=&quot;submit&quot;]:hover, input[type=&quot;submit&quot;]:focus &#123; background-color: #333; &#125; 样式化表格​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节的代码写进文件好吧。 调试CSS与组织CSS​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工具调试，没有多写的必要，引用他的一句话： 任何代码问题都可能令人沮丧，尤其是 CSS 问题，因为你通常无法获得错误消息用于网络搜索来帮助你找到解决方案。如果你感到沮丧，请暂时离开该问题一会儿—散步，喝一杯，与同事聊天，或者做一些其他事情。有时，当你停止思考问题时，解决方案就会神奇地出现，即使没有出现，在感到清爽的时候解决起问题来要容易很多。 样式化文本基本文本和字体样式​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文本内容像内联元素，除非到达了行的尽头，否则不会换行，强制换行使用&lt;br&gt;元素。 包含在元素中的文本是作为一个单一的实体，不能将文字其中一部分选中或添加样式，必须适用元素来包装它们，用span或者strong，或者使用伪元素，像::first(选中元素文本的第一个字母)，::first-line(选中元素文本的第一行)，::selection(当前光标双击选中的文本) 字体属性 color:接受任何合法的CSS单位 font-family:设定字体，使用字体栈可以使用多种字体选择 p &#123; font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif; &#125; font-size:设置大小,font-size属性是由该元素的父元素继承的，浏览器的font-size默认为16px font-style:打开或关闭文本italic normal:不打开斜体 italic:若该字体的斜体版本可用，打开斜体，否则利用oblique状态来模拟italics oblique:使用普通文本的斜体 font-weight:文字粗细 normal, bold: 普通或者加粗 lighter, bolder: 设置为比其父元素更细或更粗一步，值在100~900之间 text-transform:字体转换 none:防止任何转型 uppercase:转为大写 lowercase:转为小写 capitalize:转单词首字母为大写 full-width:转为全角 text-decoration:设置文本装饰 none:取消已存在的文本装饰 overline:上划线 underline:下划线 line-through:穿过文本的线 文字阴影text-shadow: 4px 4px 5px red; /* 1.阴影与原始文本的水平偏移(必须) 2.阴影与原始文本的垂直偏移(必须) 3.模糊半径，默认为0 4.阴影基础颜色，默认黑色 */ 文本布局 text-align:控制对齐模式 left: 左对齐文本。 right: 右对齐文本。 center: 居中文字 justify: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。 line-height:设置行高 line-height: 1.5; letter-spacing:字母与字母的间距 word-spacing:单词与单词的间距 为列表添加样式列表属性 list-style-type:设置列表符号的类型 ol &#123; /*设置大号罗马数字*/ list-style-type: upper-roman; &#125; 效果： list-style-position:设置符号是出现在列表项内还是出现在其外，默认为outside。 list-style-image:对列表符号使用自定义图片，但有局限，最好使用background系列属性。 ul &#123; list-style-image: url(star.svg); &#125; /*修改*/ ul &#123; padding-left: 2rem; list-style-type: none; &#125; ul li &#123; padding-left: 2rem; background-image: url(star.svg); background-position: 0 0; /*将出现在每个列表项的最左上侧*/ background-size: 1.6rem 1.6rem; background-repeat: no-repeat; &#125; 管理列表计数/*将从4开始计数*/ &lt;ol start=&quot;4&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;/ol&gt; /*将从4反向计数*/ &lt;ol start=&quot;4&quot; reversed&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;/ol&gt; /*设置指定值*/ &lt;ol&gt; &lt;li value=&quot;2&quot;&gt;a&lt;/li&gt; &lt;li value=&quot;4&quot;&gt;b&lt;/li&gt; &lt;li value=&quot;6&quot;&gt;c&lt;/li&gt; &lt;li value=&quot;8&quot;&gt;d&lt;/li&gt; &lt;/ol&gt; 样式化链接链接状态​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接的状态可以用对应的伪类来实现。 /*按照该顺序写，否则有些伪类无法应用*/ a &#123; &#125; a:link &#123; &#125; a:visited &#123; &#125; a:focus &#123; &#125; a:hover &#123; &#125; a:active &#123; &#125; 在链接中包含图标check out &lt;a href=&quot;http://www.extremescience.com/weather.htm&quot; &gt;weather on Extreme Science&lt;/a&gt; /*选中拥有href属性，且属性包含”http“的a元素*/ a[href*=&quot;http&quot;] &#123; background: url(&quot;external-link-52.png&quot;) no-repeat 100% 0; background-size: 16px 16px; padding-right: 19px; &#125; 样式化链接为按钮&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Pizza&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Music&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Wombats&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Finland&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; body, html &#123; margin: 0; font-family: sans-serif; &#125; ul &#123; padding: 0; width: 100%; &#125; li &#123; /*设置为行内元素*/ display: inline; &#125; a &#123; outline: none; text-decoration: none; display: inline-block; width: 19.5%; margin-right: 0.625%; text-align: center; line-height: 3; color: black; &#125; li:last-child a &#123; margin-right: 0; &#125; a:link, a:visited, a:focus &#123; background: yellow; &#125; a:hover &#123; background: orange; &#125; a:active &#123; background: red; color: white; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"DOM学习","slug":"DOM学习","date":"2023-10-25T09:26:43.000Z","updated":"2024-03-04T16:32:13.041Z","comments":true,"path":"2023/10/25/DOM学习/","link":"","permalink":"https://sakb1n.github.io/2023/10/25/DOM%E5%AD%A6%E4%B9%A0/","excerpt":"DOM基础DOM概述​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM(文档对象模型)是一个网络文档的编程接口，DOM将文档表示为节点和对象，因此编程语言可以和页面交互。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页是既可以在浏览器窗口中显示，又可以作为HTML源代码的文档，用DOM使它可以被操作。","text":"DOM基础DOM概述​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM(文档对象模型)是一个网络文档的编程接口，DOM将文档表示为节点和对象，因此编程语言可以和页面交互。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页是既可以在浏览器窗口中显示，又可以作为HTML源代码的文档，用DOM使它可以被操作。 const paragraphs = document.querySelectorAll(&quot;p&quot;); //paragraphs[0], paragraphs[1]... alert(paragraphs[0].nodeName); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM是使用多个API构建的，核心DOM定义了描述任何文档和其中对象的实体，其他API对其进行扩展。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM不是一门编程语言，而是用于建立网站的API。所以DOM不一定非要JavaScript才能实现，Python也行。 访问DOM​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用document或window对象来操作文档本身 //创造一个新的h1元素，向元素添加文本，再将其添加到文档的树中 &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;script&gt; // 当文档加载时，运行这段函数 window.onload = () =&gt; &#123; // 在空 HTML 页面中创建一系列元素 const heading = document.createElement(&quot;h1&quot;); const headingText = document.createTextNode(&quot;Big Head!&quot;); heading.appendChild(headingText); document.body.appendChild(heading); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 基本的数据类型​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常把DOM中的节点成为元素，但严格来说不是每个节点都是一个元素。 数据类型 描述 Document 当一个成员返回 document 对象时，这个对象就是rootdocument 对象本身。参见文章 DOM document 参考 Node 位于文档中的每个对象都是某种类型的节点。一个对象可以是一个元素节点，也可以是一个文本节点或属性节点 Element 基于Node，指的是一个元素或由DOM API成员返回的element类型的节点 NodeList 由元素组成的数组 Attr attribute 通过成员函数返回时，是一个为属性暴露出专门接口的对象引用 NamedNodeMap 和数组类似，但是条目是由名称或索引访问的 DOM中的核心接口 document.querySelector() document.querySelectorAll() document.createElement() Element.innerHTML Element.setAttribute() Element.getAttribute() EventTarget.addEventListener() HTMLElement.style Node.appendChild() window.onload window.scrollTo() 示例设置文本内容&lt;div class=&quot;container&quot;&gt; &lt;textarea class=&quot;story&quot;&gt;&lt;/textarea&gt; &lt;button id=&quot;set-text&quot; type=&quot;button&quot;&gt;设置文本内容&lt;/button&gt; &lt;button id=&quot;clear-text&quot; type=&quot;button&quot;&gt;清除文本内容&lt;/button&gt; &lt;/div&gt; .container &#123; display: flex; gap: 0.5rem; flex-direction: column; &#125; button &#123; width: 200px; &#125; const story = document.body.querySelector(&quot;.story&quot;); const setText = document.body.querySelector(&quot;#set-text&quot;); setText.addEventListener(&quot;click&quot;, () =&gt; &#123; story.textContent = &quot;It was a dark and stormy night...&quot;; &#125;); const clearText = document.body.querySelector(&quot;#clear-text&quot;); clearText.addEventListener(&quot;click&quot;, () =&gt; &#123; story.textContent = &quot;&quot;; &#125;); 添加子元素&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;parent&quot;&gt;父元素&lt;/div&gt; &lt;button id=&quot;add-child&quot; type=&quot;button&quot;&gt;添加子元素&lt;/button&gt; &lt;button id=&quot;remove-child&quot; type=&quot;button&quot;&gt;移除子元素&lt;/button&gt; &lt;/div&gt; .container &#123; display: flex; gap: 0.5rem; flex-direction: column; &#125; button &#123; width: 100px; &#125; div.parent &#123; border: 1px solid black; padding: 5px; width: 100px; height: 100px; &#125; div.child &#123; border: 1px solid red; margin: 10px; padding: 5px; width: 80px; height: 60px; box-sizing: border-box; &#125; const parent = document.body.querySelector(&quot;.parent&quot;); const addChild = document.body.querySelector(&quot;#add-child&quot;); addChild.addEventListener(&quot;click&quot;, () =&gt; &#123; // 只在文本节点“父节点”没有子节点时添加一个子节点 if (parent.childNodes.length &gt; 1) &#123; return; &#125; const child = document.createElement(&quot;div&quot;); child.classList.add(&quot;child&quot;); child.textContent = &quot;子节点&quot;; parent.appendChild(child); &#125;); const removeChild = document.body.querySelector(&quot;#remove-child&quot;); removeChild.addEventListener(&quot;click&quot;, () =&gt; &#123; const child = document.body.querySelector(&quot;.child&quot;); parent.removeChild(child); &#125;); 实例方法document.querySelector概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回文档中与指定选择器或选择器组匹配的第一个Element对象，找不到返回null。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配：使用深度优先先序遍历，从文档第一个元素开始按子节点的顺序遍历。 语法element = document.querySelector(selectors); /* selectors: 包含一个或多个要匹配的选择器的DOM字符串，必须为CSS选择器，否则引发SYNTAX_ERR异常。 SYNTAX_ERR:指定selectors的语法无效 CSS伪类不会返回任何元素 */ 示例//查找第一个匹配.myclass属性的元素 let e1 = document.querySelector(&quot;.myclass&quot;); //查找一个元素，该元素是被一个class = &quot;user-panel main&quot;属性的div包裹的name = &quot;login&quot;的input let e2 = document.querySelector(&quot;div.user-panel.main input[name = &#39;login&#39;]&quot;); document.querySelectorAll()概要 此方法基于ParentNode mixin的querySelectorAll()实现。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与指定的选择器组匹配的文档中的元素列表，返回NodeList(可以为空)。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦返回了NodeList，就可以像数组一样使用。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配：深度优先先序遍历文档节点。 语法querySelectorAll(selectors) /* selectors: 必须为CSS选择器的字符串，否则引发SyntaxError异常。 selectors中包含CSS伪元素会始终返回空值。 SyntaxError:指定的选择器不合法会抛出该错误。 */ 示例//获取所有p元素 let e = document.querySelectorAll(&quot;p&quot;); //获取所有class为note和alert的div元素 let e1 = document.querySelectorAll(&quot;div.note&quot;, &quot;div.alert&quot;); //获得一个p元素的列表，直接父元素是一个class = &quot;highlighted&quot;的div，位于ID为&quot;test&quot;的容器中 let container = document.querySelector(&quot;#test&quot;); let matches = container.querySelectorAll(&quot;div.highlighted &gt; p&quot;); //获得文档中属性名为“data-src”的iframe元素列表 let matches = document.querySelectorAll(&quot;iframe[data-stc]&quot;); //获得ID为userlist的列表中包含值为1的data-active属性的元素 let container = document.querySelector(&quot;#userlist&quot;); let matcher = container.querySelector(&quot;li[data-active = &#39;1&#39;]&quot;); document.createElement概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建一个由标签名称tagName指定的HTML元素，如果无法识别该tagName会生成一个未知HTML元素HTMLUnknownElement。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会返回新建的元素。 语法var element = document.createElement(tagName[, options]); /* tagName:指定要创建元素类型的字符串 */ 示例//新建一个新的div并且插入到ID为div1的元素前 document.body.onload = addElement; function addElement()&#123; //创造一个新的div元素 let newDiv = document.createElement(&quot;div&quot;); //添加内容 let newtext = document.createTextNode(&quot;Hello World!&quot;); //添加文本节点到这个div元素 newDiv.appendChlid(newtext); //获取div1 let curDiv = document.getElementById(&quot;div1&quot;); //添加到div1的元素前 document.body.insertBefore(newDiv, curDiv); &#125; element.innerHTML概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置或获取HTML语法表示的元素的后代。 语法const content = element.innerHTML; element.innerHTML = htmlString; /* 设置元素的innerHTML将会删除所有该元素的后代并以htmlString替代。 SyntaxError:HTML没有正确标记时，设置innerHTML将抛出语法错误。 NoModificationAllowedError:当父元素是Document时设置innerHTML将抛出语法错误。 */ 示例&lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;strong&gt;Log:&lt;/strong&gt;&lt;/div&gt; &lt;div class=&quot;log&quot;&gt;&lt;/div&gt; &lt;/div&gt; .box&#123; width: 600px; height: 300px; border: 1px solid black; padding: 2px 4px; overflow-y: scroll; overflow-x: auto; &#125; .log&#123; margin-top: 8px; font-family: monospace; &#125; let s = document.querySelector(&quot;.box&quot;); s.addEventListener(&quot;click&quot;, logEvent); s.addEventListener(&quot;mousedown&quot;, logEvent); s.addEventListener(&quot;mouseup&quot;, logEvent); s.addEventListener(&quot;mouseenter&quot;, logEvent); s.addEventListener(&quot;mouseleave&quot;, logEvent); function logEvent()&#123; let msg = &quot;Event &lt;strong&gt;&quot; + event.type + &quot;&lt;/strong&gt; at &lt;em&gt;&quot; + event.clientX + &quot;,&quot; + event.clientY + &quot;&lt;/em&gt;&quot;; log(msg); &#125; function log(msg)&#123; let a = document.querySelector(&quot;.log&quot;); let time = new Date(); let timestr = time.toLocaleTimeString(); a.innerHTML += timestr + &#39;:&#39; + msg + &quot;&lt;br /&gt;&quot;; &#125; log(&quot;Logging mouse events inside this container...&quot;); element.setAttribute概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置指定元素上的某个属性值，若该属性存在则更新该值，否则使用指定的名称和值添加一个新的属性，返回undefined。 语法element.setAttribute(name, value) /* name:表示属性名称的字符串 value:属性的值 */ 示例//为HTML的button设置属性 let b = document.querySelector(&quot;button&quot;); b.setAttribute(&quot;name&quot;, &quot;helloButton&quot;); b.setAttribute(&quot;disabled&quot;, &quot;&quot;); element.getAttribute概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回元素上一个指定的属性值，若指定的属性不存在，返回null 或&quot;&quot;。 语法let attribute = element.getAttribute(attributeName); /* attributeName:你想获取属性值的属性名称。 */ 示例let div1 = document.getElementById(&quot;div1&quot;); let align = div1.getAttribute(&quot;align&quot;); alert(align); EventTarget.addEventListener概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的监听器注册到EventTarget上，该对象触发指定的事件时，相应的回调函数会被执行，无返回值。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventTarget可以是Element、Document、Window和任何支持事件的对象。 使用 addEventListener()的优点： 它允许为一个事件添加多个监听器。特别是对库、JavaScript 模块和其他需要兼容第三方库&#x2F;插件的代码来说，这一功能很有用。 相比于 onXYZ 属性绑定来说，它提供了一种更精细的手段来控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。 它对任何事件都有效，而不仅仅是 HTML 或 SVG 元素。 原理​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将EventListener的函数或对象添加到调用它的EventTarget 的事件侦听器列表中，若已被添加则不会重复该操作。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个EventListener在处理事件时被注册到EventTarget上时，不会被立即触发。 ​ 如果先前向事件侦听器列表中添加过一个匿名函数，并且在之后的代码中调用 addEventListener 来添加一个功能完全相同的匿名函数，那么之后的这个匿名函数也会被添加到列表中。 ​ 实际上，即使使用完全相同的代码来定义一个匿名函数，这两个函数仍然存在区别，在循环中也是如此。在使用该方法的情况下，匿名函数的重复定义会带来许多麻烦。 语法addEventLister(type, listener, [options], [useCapture]); /* type:监听类型 listener：一个实现了EventListener接口的对象，或函数 options：capture(事件捕获), once(最多只调用一次),passive(不会调用preventDefault), signal(abort()方法被调用时，监听器被移除) useCapture:是否要先于它下面的EventTarget调用该Listener(不太懂这个...) */ 示例&lt;table id=&quot;outside&quot;&gt; &lt;tr&gt; &lt;td id=&quot;t1&quot;&gt;one&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td id=&quot;t2&quot;&gt;two&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; /*1.添加一个简单的监听器*/ // 为 table 添加事件监听器 const el = document.getElementById(&quot;outside&quot;); el.addEventListener(&quot;click&quot;, modifyText, false); // 改变 t2 内容的函数 function modifyText() &#123; const t2 = document.getElementById(&quot;t2&quot;); const isNodeThree = t2.firstChild.nodeValue === &quot;three&quot;; t2.firstChild.nodeValue = isNodeThree ? &quot;two&quot; : &quot;three&quot;; &#125; /*2.添加一个可被移除的监听器*/ // 为 table 添加可被移除的事件监听器 const controller = new AbortController(); const el = document.getElementById(&quot;outside&quot;); el.addEventListener(&quot;click&quot;, modifyText, &#123; signal: controller.signal &#125;); // 改变 t2 内容的函数 function modifyText() &#123; const t2 = document.getElementById(&quot;t2&quot;); if (t2.firstChild.nodeValue === &quot;three&quot;) &#123; t2.firstChild.nodeValue = &quot;two&quot;; &#125; else &#123; t2.firstChild.nodeValue = &quot;three&quot;; controller.abort(); // 当值变为 &quot;three&quot; 后，移除监听器 &#125; &#125; /*3.带有匿名函数的监听器*/ // 改变 t2 内容的函数 function modifyText(new_text) &#123; const t2 = document.getElementById(&quot;t2&quot;); t2.firstChild.nodeValue = new_text; &#125; // 用匿名函数为 table 添加事件监听器 const el = document.getElementById(&quot;outside&quot;); el.addEventListener( &quot;click&quot;, function () &#123; modifyText(&quot;four&quot;); &#125;, false, ); /*4.带有箭头函数的监听器*/ // 改变 t2 内容的函数 function modifyText(new_text) &#123; var t2 = document.getElementById(&quot;t2&quot;); t2.firstChild.nodeValue = new_text; &#125; // 用箭头函数为 table 添加事件监听器 const el = document.getElementById(&quot;outside&quot;); el.addEventListener( &quot;click&quot;, () =&gt; &#123; modifyText(&quot;four&quot;); &#125;, false, ); Node.appendChlid概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个节点附加到指定父节点的子节点列表末尾处。若该节点已经存在，则将其移动到新的位置，返回追加后的子节点。 语法element.appendChild(aChild) /* aChild:要追加给父节点的节点。 */ 示例//创造一个新的段落元素p，然后将其添加到body的最尾部 let p = document.createElement(&quot;p&quot;); document.body.appendChild(p); window.onload概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load事件在整个页面及所有依赖资源都已完全加载时触发。 语法addEventListener(&quot;load&quot;, (event) =&gt; &#123;&#125;); onload = (event) =&gt; &#123;&#125;; 示例windows.addEventListener(&quot;load&quot;, (event) =&gt;&#123; console.log(&quot;page is fully loaded&quot;); &#125;); windows.onload = (event) =&gt; &#123; console.log(&quot;page is fully loaded&quot;); &#125;; window.scrollTo概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动到文档中的某个坐标。 语法window.scrollTo(x-coord, y-coord); window.scrollTo(options); /* x-coord:文档的横轴坐标=left y-coord:文档的纵轴坐标=top options:包含三个属性的对象 */ 示例window.scrollTo(0, 1000); //设置滚动行为为平滑的滚动 window.scrollTo(&#123; top:1000, behavior:&quot;smooth&quot; &#125;);","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"javaScript基础学习ver1.2","slug":"javascript基础学习ver1-0","date":"2023-10-19T04:38:49.000Z","updated":"2024-03-04T16:32:19.271Z","comments":true,"path":"2023/10/19/javascript基础学习ver1-0/","link":"","permalink":"https://sakb1n.github.io/2023/10/19/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0ver1-0/","excerpt":"2023.10.22: 更新了js对象内容(ver1.2)2023.10.21: 优化了排版，更新至ver1.12023.10.19：更新js ver1.0 JavaScript学习（MDN）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。","text":"2023.10.22: 更新了js对象内容(ver1.2)2023.10.21: 优化了排版，更新至ver1.12023.10.19：更新js ver1.0 JavaScript学习（MDN）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。 JavaScript第一步什么是javaScript？js简要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javascript是轻量级解释型语言，使用即时编译：会编译为二进制的格式。 js使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用内部js(在&lt;/head&gt;标签结束前插入&lt;script&gt;元素) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者直接外联（推荐): &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不建议内联（太乱了） 案例：使用addEventListener&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用querySelectorAll()函数选择按钮，使用addEventListener()为每个按钮分配一个处理器。 const buttons = document.querySelectorAll(&quot;button&quot;); for (let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].addEventListener(&quot;click&quot;, createParagraph); &#125; 脚本调用策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML是按其出现在页面中的次序调用的，若js加载在欲操作的元素之前会发生错误。 1.内部： document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; // … &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：这个事件监听器能监听浏览器的DOMContentLoaded事件，标志着HTML文档体完全加载和解析，而在该代码需在事件触发后才进行，从而避免了错误。 2.外部： &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在&lt;script&gt;最后加入defer解决问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：defer告知浏览器在遇到&lt;script&gt;元素时继续下载HTML内容。 async 和 defer 的区别 使用async 脚本时不会阻塞页面渲染，而是直接下载然后运行。但是，一旦下载完成，脚本就会执行，从而阻止页面渲染。脚本的运行次序无法控制。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，async 是最理想的选择。 使用 defer 属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完毕之前，脚本不会运行，如果脚本依赖于 DOM 的存在（例如，脚本修改了页面上的一个或多个元素），这一点非常有用。 例: &lt;script async src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;js/script2.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;js/script3.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三者的调用顺序是不确定的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async 应该在有大量后台脚本需要加载，并且只想尽快加载到位的情况下使用 &lt;script defer src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;js/script2.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;js/script3.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这将会按顺序以此加载。 注释 // 注释 /* 注释 */ javaScript初体验&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉没什么要写的，很多都是在java中学过的了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章更多是在讲第一个程序，贴个链接：[JavaScript 初体验](JavaScript 初体验 - 学习 Web 开发 | MDN (mozilla.org)) 事件​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;侦听事件的结构称为事件监听器(Event Listener）, 响应事件触发而运行的代码块称为事件处理器(Event Handler)。 for of循环const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]; for (const fruit of fruits) &#123; console.log(fruit); &#125; 结果： &#39;apples&#39;,&#39;bananas&#39;,&#39;cherries&#39; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for of在这里干了什么：获取fruits的第一个元素赋值给fruit，运行代码块，再重复这两个操作一直到fruits的末尾。 变量验证变量存在​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用变量的方式验证变量是否存在： myName; myAge; //若没数值会返回undefined，若不存在会产生报错信息 初始化变量var myName = &quot;Chris&quot;; var myAge = 37; 更新变量myName = &quot;Bob&quot;; myAge = 40; var和let的区别 let 是在现代版本中的 JavaScript 创建的一个新的关键字，用于创建与 var 工作方式有些不同的变量，解决了过程中的问题。 D1: myName = &quot;Chris&quot;; function logName() &#123; console.log(myName); &#125; logName(); var myName; //变量提升 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let将不再允许该操作，并产生错误。 D2: var myName = &quot;Chris&quot;; var myName = &quot;Bob&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let不能多次声明相同名称的变量。 注：Internet Explorer 直到第 11 版才支持 let ! 变量类型 Number String Boolean Array Object 注：js的变量为动态类型 数字与操作符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof：返回数据类型 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**: 幂， 5 ** 5 &#x3D;3125 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x3D;&#x3D;&#x3D;：严格等于，要求数据类型相等 字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js的字符串用单双引号都可以,但不能在字符串中包含相同的引号。 转义字符let bigmouth = &#39;I\\&#39;ve got no right to take my place...&#39;; // 使用\\&#39;转义 数字与字符串​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与字符串相互转换，用Number() 和 toString()方法。 let myNum = Number(myString); //转换为数值 let myString = myNum.toString(); //转换为字符串 字符串方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length方法返回长度： browserType.length; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexOf方法查找子字符串： browserType.indexOf(&quot;zilla&quot;); //找不到返回-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice方法提取字符串： browserType.slice(0, 3); //范围不包含第二个参数 browserType.slice(3); //返回自第三个字符后的字符串 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toLowerCase、toUpperCase大小写转换： let radData = &quot;mY&quot;; radData.toLowerCase(); //“my” radData.toUpperCase(); //&quot;MY&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace进行替换： let browserType = mozilia; browserType.replace(&quot;moz&quot;, &quot;van&quot;); //vanilia 数组创建数组let shopping = [&quot;bread&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot;]; let random = [&quot;tree&quot;, 795, [0, 1, 2]]; //不一定同一种类 访问数组shopping[0] = &quot;tahini&quot;; shopping; // shopping will now return [ &quot;tahini&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot; ] 获取数组长度shopping.length; 字符串和数组的转换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split方法: let myData = &quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;; let myArray = myData.split(&quot;,&quot;); myArray; //Manchester London Liverpool Birmingham Leeds Carlisle&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join方法: let myNewString = myArray.join(&quot;,&quot;); myNewString; //Manchester,London,Liverpool,Birmingham,Leeds,Carlisle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toString方法： myArray.toString(); 添加或删除数组项let myArray = [ &quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;, ]; myArray.push(&quot;Cardiff&quot;, &quot;Bradford&quot;); //末尾添加Cardiff、Bradford myArray.pop() //删除最后一个元素 myArray.unshift(&quot;Edinburgh&quot;) //首部添加Edinburgh myArray.shift() //删除第一个元素 JavaScript基础条件语句if (condition) &#123; &#125; else &#123; &#125; 例子: &lt;label for=&quot;weather&quot;&gt;选择今天的天气：&lt;/label&gt; &lt;select id=&quot;weather&quot;&gt; &lt;option value=&quot;&quot;&gt;--作出选择--&lt;/option&gt; &lt;option value=&quot;sunny&quot;&gt;晴天&lt;/option&gt; &lt;option value=&quot;rainy&quot;&gt;雨天&lt;/option&gt; &lt;option value=&quot;snowing&quot;&gt;雪天&lt;/option&gt; &lt;option value=&quot;overcast&quot;&gt;阴天&lt;/option&gt; &lt;/select&gt; &lt;p&gt;&lt;/p&gt; const select = document.querySelector(&quot;select&quot;); const para = document.querySelector(&quot;p&quot;); select.addEventListener(&quot;change&quot;, setWeather); function setWeather() &#123; const choice = select.value; if (choice === &quot;sunny&quot;) &#123; //进行判断 para.textContent = &quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;; &#125; else if (choice === &quot;rainy&quot;) &#123; para.textContent = &quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;; &#125; else if (choice === &quot;snowing&quot;) &#123; para.textContent = &quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;; &#125; else if (choice === &quot;overcast&quot;) &#123; para.textContent = &quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;; &#125; else &#123; para.textContent = &quot;&quot;; &#125; &#125; 循环语句​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同java，不再写笔记了。 函数自定义函数function myFunction() &#123; alert(&quot;hello world!&quot;); &#125; myFunction(); 匿名函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也称函数表达式，没有函数名的函数，经常与事件处理程序一起使用。 function() &#123; alert(&quot;hello world!&quot;); &#125; 例: var Button = document.querySelector(&quot;button&quot;); Button.onclick = function() &#123; alert(&quot;hello World!&quot;); &#125; 又如: var test = function () &#123; alert(&quot;hello world!&quot;); &#125;; test(); 事件介绍 事件是发生在你正在编程的系统中的事情——当事件发生时，系统产生（或“触发”）某种信号，并提供一种机制，当事件发生时，可以自动采取某种行动（即运行一些代码）。事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了对一个事件做出反应，你要给它附加一个事件处理器 实例：处理点击事件​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt;元素将在用户点击按钮时触发一个事件（定义了一个addEventListener函数） &lt;button&gt;改变颜色&lt;/button&gt; const btn = document.querySelector(&quot;button&quot;);//引用 function random(number) &#123; return Math.floor(Math.random() * (number + 1)); &#125; //click可以监听点击事件 btn.addEventListener(&quot;click&quot;, () =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅仅可以监听点击事件，addEventListener还可以: focus:聚焦（按Tab） blur:失焦(再次按下Tab) dblclick:双击按键 mouseover：鼠标指针在按钮上悬停 mouseout：鼠标指针移出按钮 移除监听器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用removeEventListener()方法 btn.removeEventListener(&quot;click&quot;, changeBackground); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以传递AbortSignal到addEventListener()，在拥有AbortSignal的控制器上调用abort()来删除。 const controller = new AbortController(); btn.addEventListener(&quot;click&quot;,() =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;, &#123; signal: controller.signal &#125; // 向该处理器传递 AbortSignal ); 然后 controller.abort(); // 移除所有与该控制器相关的事件处理器 在单个事件上添加多个监听器myElement.addEventListener(&quot;click&quot;, functionA); myElement.addEventListener(&quot;click&quot;, functionB); 其他事件监听器机制​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件处理器属性：可以触发事件的对象通常有on+事件名称的属性，例如 onclick。 ​ 所以也可以这样写： btn.onclick = () =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;; ​ 或者btn.onclick = functionA; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件处理器属性不能添加多个处理程序。 ​ 内联事件处理器 &lt;button onclick=&quot;bgChange()&quot;&gt;按下我&lt;/button&gt; function bgChange() &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125; 许多常见的服务器配置将禁止内联 JavaScript。 你永远不应该使用 HTML 事件处理器属性——那些已经过时了，使用它们是不好的做法。 事件对象​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在事件处理函数内部可能会看到一个固定指定名称的参数，例如 event、evt 或 e，这就是事件对象。 //e.target指的是按钮本身。事件对象 e 的 target 属性始终是事件刚刚发生的元素的引用 const btn = document.querySelector(&quot;button&quot;); function bgChange(e) &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; e.target.style.backgroundColor = rndCol; console.log(e); &#125; btn.addEventListener(&quot;click&quot;, bgChange); ​ 事件对象的额外属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keydown 事件在用户按下一个键时发生。它的事件对象是 KeyboardEvent，它是一个专门的 Event 对象，有一个 key 属性，告诉你哪个键被按下。 例： &lt;input id=&quot;textBox&quot; type=&quot;text&quot; /&gt; &lt;div id=&quot;output&quot;&gt;&lt;/div&gt; const textBox = document.querySelector(&quot;#textBox&quot;); const output = document.querySelector(&quot;#output&quot;); textBox.addEventListener(&quot;keydown&quot;, (event) =&gt; &#123; output.textContent = `You pressed &quot;$&#123;event.key&#125;&quot;.`; &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行后，每当你在输入框内敲下字母，将会显示你刚敲下的内容。 阻止默认行为&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码创造表单，要求填入名和姓，并有提交按钮。 &lt;form&gt; &lt;div&gt; &lt;label for=&quot;fname&quot;&gt;First name: &lt;/label&gt; &lt;input id=&quot;fname&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;lname&quot;&gt;Last name: &lt;/label&gt; &lt;input id=&quot;lname&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在submit事件中实行简单检查，如果文本字段为空，调用preventDefault()停止提交并报告错误信息，否则继续提交。 const form = document.querySelector(&quot;form&quot;); const fname = document.getElementById(&quot;fname&quot;); const lname = document.getElementById(&quot;lname&quot;); const para = document.querySelector(&quot;p&quot;); form.addEventListener(&quot;submit&quot;, (e) =&gt; &#123; if (fname.value === &quot;&quot; || lname.value === &quot;&quot;) &#123; e.preventDefault(); para.textContent = &quot;You need to fill in both names!&quot;; &#125; &#125;); 事件冒泡&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;button&gt;点我！&lt;/button&gt; &lt;/div&gt; &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt; &lt;/body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素上附加事件处理器，也会触发单击事件： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); container.addEventListener(&quot;click&quot;, handleClick); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素与按钮上同时附加事件处理器，都会触发： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); const button = document.querySelector(&quot;button&quot;); document.body.addEventListener(&quot;click&quot;, handleClick); container.addEventListener(&quot;click&quot;, handleClick); button.addEventListener(&quot;click&quot;, handleClick); /*Result: 你在BUTTON元素上进行了点击 你在DIV元素上进行了点击 你在BODY元素上进行了点击 */ 实例：视频播放器 单击显示”视频按钮“时，显示包含视频的盒子但不开始播放 单击视频时播放 单击盒子内视频以外的任何区域时隐藏盒子 &lt;button&gt;显示视频&lt;/button&gt; &lt;div class=&quot;hidden&quot;&gt; &lt;video&gt; &lt;source src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;p&gt; 你的浏览器不支持 HTML 视频，这里有视频的&lt;a href=&quot;rabbit320.mp4&quot;&gt;替代链接&lt;/a&gt;。 &lt;/p&gt; &lt;/video&gt; &lt;/div&gt; const btn = document.querySelector(&quot;button&quot;); const box = document.querySelector(&quot;div&quot;); const video = document.querySelector(&quot;video&quot;); btn.addEventListener(&quot;click&quot;, () =&gt; box.classList.remove(&quot;hidden&quot;)); video.addEventListener(&quot;click&quot;, () =&gt; video.play()); box.addEventListener(&quot;click&quot;, () =&gt; box.classList.add(&quot;hidden&quot;)); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当点击按钮后，因为div包含着video，盒子和视频都会同时显示，当点击视频时，会同时运行两个事件处理器，所以视频播放但盒子又消失了。 使用stopPropagation()修复问题​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event对象有一个stopPropagation()函数，可以在当一个事件处理器调用时防止事件向其他元素传递。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将video的addEventListener修改即可解决问题: video.addEventListener(&quot;click&quot;, (event) =&gt; &#123; event.stopPropagation(); video.play(); &#125;); 事件捕获 先在最小嵌套元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件捕获默认禁用，需要在addEventListener()中的capture选项中启用 接事件冒泡中的代码： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); const button = document.querySelector(&quot;button&quot;); //设置事件捕获 document.body.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;); container.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;); button.addEventListener(&quot;click&quot;, handleClick); /* Result: 你在BODY元素上进行了点击 你在DIV元素上进行了点击 你在BUTTON元素上进行了点击 */ 事件委托​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在父元素上设置监听器，让发生在它们身上的事件冒泡到父元素上。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户点击一个按钮时页面的区域设置成随机颜色 &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;/div&gt; //设置区域尺寸 .tile &#123; height: 100px; width: 25%; float: left; &#125; function random(number) &#123; return Math.floor(Math.random() * number); &#125; function bgChange() &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; return rndCol; &#125; const container = document.querySelector(&quot;#container&quot;); container.addEventListener(&quot;click&quot;, (event) =&gt;&#123; event.target.style.backgroundColor = bgChange(); &#125;); javaScript对象介绍java对象基础构造对象以及表示法/*构造一个空对象*/ const person = &#123;&#125;; /*用对象字面量创造对象*/ const person = &#123; name: [&quot;Bob&quot;, &quot;Smith&quot;], age: 32, bio() &#123; console.log(`$&#123;this.name[0]&#125; $&#123;this.name[1]&#125; 现在 $&#123;this.age&#125; 岁了。`); &#125;, introduceSelf() &#123; console.log(`你好！我是 $&#123;this.name[0]&#125;。`); &#125;, &#125;; /* 调用对象方法和属性 1.点表示法 */ person.name; person.name[0]; person.age; person.bio(); // &quot;Bob Smith 现在 32 岁了。&quot; person.introduceSelf(); // &quot;你好！我是 Bob。&quot; /* 2,括号表示法 */ person[&quot;age&quot;]; person[&quot;name&quot;][&quot;first&quot;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多数情况下用点表示法，但某些情况下你必须用括号表示法。 /*当对象属性名称保存在变量中，只能用括号表示法*/ const person = &#123; name: [&quot;Bob&quot;, &quot;Smith&quot;]; age:32; &#125;; function logProperty(propertyName)&#123; console.log(person[propertyName]); &#125; logProperty(&quot;name&quot;); //[&quot;Bob&quot;, &quot;Smith&quot;] logProperty(&quot;age&quot;); // 32 子命令空间/*用一个对象来做另一个对象成员的值*/ const person = &#123; name:&#123; first:&quot;Bob&quot;, last:&quot;Smith&quot;, &#125; &#125;; //访问 person.name.first; person.name.last; 设置对象成员&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;括号表示法可以动态创建成员名字，而点表示法不行。 /*设置对象成员*/ person.age = 45; person[&quot;name&quot;][&quot;last&quot;] = &quot;Cratchit&quot;; /*创建对象成员*/ person[&quot;eyes&quot;] = &quot;hazel&quot;; person.farewell = function()&#123; console.log(&quot;再见！&quot;); &#125;; person[&quot;eyes&quot;]; person.farewell(); 构造函数/*创造person的构造函数*/ function Person(name)&#123; this.name = name; this.introduceSelf = function( console.log(`你好！我是$(this.name)。`); ); &#125; /*调用构造函数*/ const salva = new Person(&quot;Salva&quot;); salva.name; salva.introduceSelf(); // &quot;你好！我是 Salva。&quot; 对象原型原型链const myObject = &#123; city: &quot;Madrid&quot;, greet()&#123; console.log(`来自$(this.city)的问候`); &#125;, &#125;; myObject.greet(); //来自 Madrid 的问候 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用myObject.时,出现以下信息 __defineGetter__ __defineSetter__ __lookupGetter__ __lookupSetter__ __proto__ city constructor greet hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf //调用其中的toString myObject.toString(); //&quot;[object Object]&quot; javaScript中所有对象都有一个内置属性，称作原型，原型对象也会有自己的原型，逐渐构成了原型链，原型链终止于拥有null作为其原型的对象上。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当访问一个对象的属性时，如果在其本身找不到该属性，就会在原型中搜索，仍然找不到则继续搜索原型的原型，直到链的末端（返回undefined）。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype是最基础的原型，所有对象默认都拥有它， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的原型是null，故其位于原型链的终点。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个对象的原型不一定就是Object.prototype const myDate = new Date(); let object = myDate; do &#123; object = Object.getPrototypeOf(object); console.log(object); &#125; while (object); // Date.prototype // Object &#123; &#125; // null 属性遮蔽 如果在对象中定义属性，而在对象原型中也定义了一个同名属性会发生什么？ const myDate = new Date(1995, 11, 17); console.log(myDate.getYear()); // 95 myDate.getYear = function () &#123; console.log(&quot;别的东西！&quot;); &#125;; myDate.getYear(); // &#39;别的东西！&#39; /*调用 getYear时，会先在myDate中寻找。这叫做属性遮蔽 */ 设置原型/*方式一：使用Object.create()*/ const personPrototype = &#123; greet() &#123; console.log(&quot;hello!&quot;); &#125;, &#125;; //创造一个以personPrototype为原型的新对象 const carl = Object.create(personPrototype); //原型为对象提供了greet方法 carl.greet(); /*方式二：使用构造函数*/ //创造personPrototype对象，该对象具有方法greet。 const personPrototype = &#123; greet() &#123; console.log(`你好，我的名字是 $&#123;this.name&#125;！`); &#125;, &#125;; //创造Person的构造函数 function Person(name) &#123; this.name = name; &#125; //将personPrototype中的方法绑定到Person的prototype属性上 Object.assign(Person.prototype, personPrototype); // 或 // Person.prototype.greet = personPrototype.greet; //调用 const reuben = new Person(&quot;Reuben&quot;); reuben.greet(); // 你好，我的名字是 Reuben！ 自有属性​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接在对象中定义的属性，被称为自有属性。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用静态方法 Object.hasOwn()检查一个属性是否是自有属性。 const irma = new Person(&quot;Irma&quot;); console.log(Object.hasOwn(irma, &quot;name&quot;)); // true console.log(Object.hasOwn(irma, &quot;greet&quot;)); // false 面向对象编程基本概念​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java方面知识，不再赘述。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javaScript中的原型与对象很像java中的类与对象，但两者依旧有区别。 javaScript中的类基本使用//用class声明一个类 class Person&#123; name; //构造函数 constructor(name)&#123; this.name = name; &#125; introduceSelf()&#123; console.log(`Hi! I&#39;m $&#123;this.name&#125;`); &#125; &#125; //创建并使用 const giles = new Person(&quot;Giles&quot;); giles.introduceSelf(); // Hi! I&#39;m Giles 省略构造函数/*不需要初始化时，默认构造函数将自动生成*/ class Animal &#123; sleep() &#123; console.log(&quot;zzzzzzz&quot;); &#125; &#125; const spot = new Animal(); spot.sleep(); //&#39;zzzzzzz&#39; 继承class Professor extends Person&#123; teaches; constructor(name, teaches)&#123; super(name); this.teaches = teaches; &#125; introduceSelf() &#123; console.log( `My name is $&#123;this.name&#125;, and I will be your $&#123;this.teaches&#125; professor.`, )&#125;; grade(paper) &#123; const grade = Math.floor(Math.random() * (5 - 1) + 1); console.log(grade); &#125; &#125; //使用 const walsh = new Professor(&quot;Walsh&quot;, &quot;Psychology&quot;); walsh.introduceSelf(); // &#39;My name is Walsh, and I will be your Psychology professor&#39; walsh.grade(&quot;my paper&quot;); // some random grade 封装class Student extends Person &#123; //#year是私有数据属性,&#39;用#&#39;表示。 #year; constructor(name, year) &#123; super(name); this.#year = year; &#125; introduceSelf() &#123; console.log(`Hi! I&#39;m $&#123;this.name&#125;, and I&#39;m in year $&#123;this.#year&#125;.`); &#125; canStudyArchery() &#123; return this.#year &gt; 1; &#125; &#125; //在类的外部尝试访问#year将会出错 const summers = new Student(&quot;Summers&quot;, 2); summers.#year; // SyntaxError 私有方法//与私有属性一样 class Example &#123; somePublicMethod() &#123; this.#somePrivateMethod(); &#125; #somePrivateMethod() &#123; console.log(&quot;You called me?&quot;); &#125; &#125; const myExample = new Example(); myExample.somePublicMethod(); // &#39;You called me?&#39; myExample.#somePrivateMethod(); // SyntaxError 使用JSONJSON简介 javaScript对象表示法（JSON）是用于将结构化数据表示为 JavaScript 对象的标准格式，通常用于在网站上表示和传输数据。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON可以作为一个对象或者字符串存在，前者用于解读JSON中的数据，后者用于通过网络传输JSON数据。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串转换为原生对象称为反序列化，原生对象转换为字符串称为序列化。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON存储在.json中。 ​ JSON结构​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON类似于对象字面量。 &#123; &quot;squadName&quot;: &quot;Super hero squad&quot;, &quot;homeTown&quot;: &quot;Metro City&quot;, &quot;formed&quot;: 2016, &quot;secretBase&quot;: &quot;Super tower&quot;, &quot;active&quot;: true, &quot;members&quot;: [ &#123; &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] &#125;, &#123; &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Eternal Flame&quot;, &quot;age&quot;: 1000000, &quot;secretIdentity&quot;: &quot;Unknown&quot;, &quot;powers&quot;: [ &quot;Immortality&quot;, &quot;Heat Immunity&quot;, &quot;Inferno&quot;, &quot;Teleportation&quot;, &quot;Interdimensional travel&quot; ] &#125; ] &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串加载入js程序中，并解析到名叫superHeroes变量中，可以用该变量访问数据。 superHeroes.hometown; superHeroes[&quot;active&quot;]; //访问members数组的第二个元素，其中的powers数组的第三个元素 superHeroes[&quot;members&quot;][1][&quot;powers&quot;][2]; JSON数组​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组与JSON可以相互转换，比如这样写依然有效。 [ &#123; &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] &#125;, &#123; &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] &#125; ] //调用 [0][&quot;powers&quot;][0]; JSON注意事项 是纯数据格式，只有属性，没有方法。 要求在字符串和属性名称周围用双引号。 JSON文件很容易出错，可以用JSONLint验证JSON。 JSON中只有带引号的字符串可以用作属性。","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"sql学习ver1.0","slug":"sql学习ver1-0","date":"2023-10-16T13:06:44.000Z","updated":"2024-03-04T16:32:36.417Z","comments":true,"path":"2023/10/16/sql学习ver1-0/","link":"","permalink":"https://sakb1n.github.io/2023/10/16/sql%E5%AD%A6%E4%B9%A0ver1-0/","excerpt":"2023.10.19：文章周末更新，会把排版优化一下~2023.10.16：更新sql ver1.0 数据库概念操作者用SQL语言向数据库管理系统(DBMS)发出指令，系统在数据库(DB)里进行操作。","text":"2023.10.19：文章周末更新，会把排版优化一下~2023.10.16：更新sql ver1.0 数据库概念操作者用SQL语言向数据库管理系统(DBMS)发出指令，系统在数据库(DB)里进行操作。 数据库存储特点 数据放进表（按行存储），表放进数据库 数据库有多个表，每个表只有一个名字 表中的每一列（也称字段）类似于java中对象的属性，每一行类似于java中的对象 配置文件my.ini 文件位置：C:\\ProgramData\\MySQL\\MySQL Server 8.0 SQL启动与停止方式一：计算机 ——– 管理 ——-服务 方式二：命令行(管理员) net start/stop mysql端口 SQL登陆与退出方式一：MySQL Command Line Client登陆(仅限于root) 方式二：命令行(管理员) mysql [-h主机名 -P端口号] -u用户名 -p密码 (仅限本地可以省略) 退出：exit或ctrl+c SQL常见命令show databases; //查看数据库 use 库名; //打开指定库 show tables //查看表 desc 表名 //查看表结构 查看版本： select version(); mysql --version SQL语法规范 不区分大小写 用分号结尾 可以换行 单行注释#或– + 空格 多行注释&#x2F;* *&#x2F; 查询基础查询SELECT 列表 FROM 表名； 注意：1.查询的可以是字段、变量、表达式或函数； ​ 2.返回的是虚拟表格。 ​ 3.SELECT * 会返回所有字段。 ​ 4.如果查询的列与SQL关键字冲突时，用反引号(&#96;&#96;)包裹。 ​ 5.SELECT可以查询常量值（意义何在…） 去重直接在字段前加上DISTINCT MySQL里的+号没有连接符的作用，只有运算符的作用 若一方是字符型，会自动隐式转换为数值型，失败会当做0 一方为NULL，最终值也为NULL 若要拼接字段，使用CONCAT(str1, str2, …)，如果其中有NULL值最终也会变为NULL，使用ISNULL(字段，赋值) 来判断。 条件查询SELECT 列表 FROM 表名 WHERE 条件； 按条件表达式筛选（&gt; &lt; &#x3D; !&#x3D;或&lt;&gt; &gt;&#x3D; &lt;&#x3D;） 按逻辑表达式筛选（&amp; || ! and or not） 模糊查询（like between and in isnull） ESCAPE ‘ ‘ 指定转义字符 用IN模糊查询时不能用通配符。 条件等于NULL值时 不能用&#x3D;，用专门的IS NULL。 安全等于(&lt;&#x3D;&gt;) 可以判断NULL值。 排序查询SELECT 列表 FROM 表名 WHERE 条件 ORDER BY 排序列表 ASC|DESC； ORDER BY 一般是放在查询语句的最后。 常用函数LENGTH() 求长 CONCAT() 连接字段 UPPER() 大写化 LOWER() 小写化 SUBSTR(str1, index1, index2) 返回在str1 index1~index2 位置上的子字符串（索引从1开始） INSTR(str1, str2) 返回在str2中第一次出现str1的索引,未查到返回0 TRIM(str1, str2) 在str2的头和尾上去除str1，未填str1默认为空格 L(R)PAD(str1, str2，length) 用str1在str2的左(右)边填充直到length长度 REPLACE(str1, str2, str3) 将str1中的str2全部替换为str3 数学函数ROUND(x, y) //四舍五入,对x保留y位小数 CEIL(x) //向上取整 FLOOR(x) //向下取整 RTUNCATE(x, y) //截断，对y + 1位后的小数进行截断 MOD(x, y) //x对y取余 日期函数NOW() //返回当前系统日期+时间 CURDATE() //返回当前系统日期 CURTIME() //返回当前时间 YEAR(time)、MONTH(time)... //可以获取指定时间的年、月等...(MONTHNAME可获得英文月份) STR_TO_DATE() //将日期格式的字符转换成指定格式的日期 例：STR_TO_DATE(&#39;1998-3-2&#39;, &#39;%Y-%c-%D&#39;); DATE_FORMAT //将日期转换为字符 例：DATE_FORMAT(NOW(), &#39;%y年%m月%d日&#39;) 其他函数VERSION() //版本号 DATABASE() //查看当前库 USER() //查看当前用户 流程控制函数IF的使用： IF(exp1, exp2, exp3) 例： IF(10 &lt; 5, &#39;大&#39;， ‘小&#39;) CASE的使用： 1.CASE 要判断的字段或表达式 WHEN 常量1 THEN 要显示的值或语句; WHEN 常量2 THEN 要显示的值或语句; WHEN 常量3 THEN 要显示的值或语句; ... ELSE 要显示的值或语句； END 2.CASE WHEN 条件1 THEN 要显示的值或语句; WHEN 条件2 THEN 要显示的值或语句; WHEN 条件3 THEN 要显示的值或语句; ... ELSE 要显示的值或语句； END","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"从零开始的博客搭建生活-003","slug":"从零开始的博客搭建生活-003","date":"2023-10-04T16:15:24.000Z","updated":"2024-03-05T05:35:34.130Z","comments":true,"path":"2023/10/05/从零开始的博客搭建生活-003/","link":"","permalink":"https://sakb1n.github.io/2023/10/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-003/","excerpt":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 今天写的是对博客各种功能的学习。预计这个系列在下一集就会完结www。","text":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 今天写的是对博客各种功能的学习。预计这个系列在下一集就会完结www。 文章编写新建文章:hexo new 文件名 执行该命令后会在根目录的source_posts生成文章。 新建草稿:hexo new draft 文件名 执行后同上，会在_drafts下生成草稿，草稿不会被更新在博客中。 通过上面这两个命令，相信已经知道Hexo文章的生成了，而文章的撰写需要学会Markdown语法，这部分内容会放在Extra章节中。 模版在主目录的scaffolds文件夹中，存放有: ├── draft.md //草稿模板├── page.md //页面模板├── post.md //文章模板 打开post.md，可以看到: ---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 向其中加入”categories：”,这样就添加了分类标签，此后生成文章后，文章头部将自带categories字段。 网页基础设置主目录的_config.yml在主目录的_config.yml下，可以对网站基础进行设置。 title:标题 subtitle:子标题 description:主页介绍 keywords:关键字 author:作者 language:语言(建议改为zh-CN) timezone:时区 在#site底下可以改url，这是博客上线后的地址，会在分享时用到。url:http://example.com 主题的_config.yml在themes&#x2F;你的主题&#x2F;_config.yml下，也有一部分能设置的东西。 注：以主题作者的文档为准！","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"}]},{"title":"从零开始的博客搭建生活-002","slug":"从零开始的博客搭建生活-002","date":"2023-10-03T15:31:04.000Z","updated":"2024-03-05T05:38:47.666Z","comments":true,"path":"2023/10/03/从零开始的博客搭建生活-002/","link":"","permalink":"https://sakb1n.github.io/2023/10/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-002/","excerpt":"前文指引：从零开始的博客搭建生活-001","text":"前文指引：从零开始的博客搭建生活-001 在第一篇文章中省略的正式上线流程，还是有点路程的（） 首先你要有一个github账户，easy。 github pages配置，easy。 git配置SSH公钥（第一次用git），小麻烦。 webstorm链接远程，easy。 用一下hexo g ，就这样我们网站就能正式上线了啊哈哈，但是通过github来访问难以记忆，第二篇要写的东西，就是域名。 有了域名，我们访问网站就会更加方便，只需记住名字就行，当然这是付费项目。 我在阿里云花钱买了个.top域名，.com一年23块我买不起，这个一年9块还是比较便宜的注意：购买域名需要实名认证，一般当天就通过了 接下来便是解析域名 (我耗费时间最长的地方，出现了各种莫名其妙的问题)：在域名解析里添加记录 参考 照搬了多个教程最后决定添加的2条记录,除了第一条的记录值要改为名字.github.io.（末尾一定要有这个点）外，其他都按照图上写。 最后在github pages上添加自己的域名即可。(在这里，依旧没有解决一个叫”DNS valid for primary”的问题，我翻了很多网站都没找到合适的解决方案，虽然不影响使用，但这个问题在未来会追加解决的！) 稍作一会，你便可以直接通过域名看到自己的网站咯wow 至于为什么没有买云服务器搭配呢，原因很简单，我没钱买ECS云服务器，一个计算型c5算上公网带宽一个月起码200元花销，真的很贵。~~（什么，你说新生计划？抱歉，已经被我拿去做mc服务器用掉了）~~~ 域名就写这么多，在下一篇中，将对个人博客进行进一步的美化！ 从零开始的博客搭建生活-002 Finished！","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"}]},{"title":"从零开始的博客搭建生活-001","slug":"从零开始的博客搭建生活-001","date":"2023-10-01T15:40:23.000Z","updated":"2024-03-05T05:41:16.359Z","comments":true,"path":"2023/10/01/从零开始的博客搭建生活-001/","link":"","permalink":"https://sakb1n.github.io/2023/10/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-001/","excerpt":"这是一个预谋已久的计划准备搭建一个属于自己的个人博客，至于原因，就是闲来无事在上面写点文章。该系列会持续更新，这是第一篇，大概会更新4~5集，讲讲我这个新手从零开始的艰辛路程（）","text":"这是一个预谋已久的计划准备搭建一个属于自己的个人博客，至于原因，就是闲来无事在上面写点文章。该系列会持续更新，这是第一篇，大概会更新4~5集，讲讲我这个新手从零开始的艰辛路程（） 文章链接：https://blog.csdn.net/m0_51269961/article/details/122575897快速搭建个人博客——保姆级教程 首先下载所需要的软件(如果要收钱的话你懂得) Webstorm (或Vscode, 但JetBrains全家桶可以用校园账户免费领) Hexo (网站博客框架，也可以用WordPress) Node.js (Hexo前置) git (工具) 需要注意的是，Node.js的安装可能需要自行配置环境变量，否则可能根本就运行不了指令，网上有一大堆教程。 Hexo安装：在桌面上git bash就行npm install -g hexo-cli插件：npm install hexo-renderer-pug hexo-renderer-stylus --save 初始化：建议自己创建新文件夹，在文件夹里面右键git bashhexo init hexo的一些常用文件： public: 网站最终呈现形态 node_modules: 插件 _config.yml: 配置文件 scaffolds: 模版文件夹 themes: 存放主题文件 source: 存放用户资源 在webstorm中打开终端，输入：hexo s 提示打开网站就成功了，进入网站将是hexo最开始的形态（用ctrl+c来关闭本地网站） 但我们需要让网站更漂亮的话，该怎么办呢？答案就是使用官方提供的theme主题。 地址：https://hexo.io/themes/我所选用的是ParticleX 克隆：git clone https://github.com/theme-particlex/hexo-theme-particlex.git particlex --depth=1 会多出以下文件: 在hexo根目录下修改_config.yml(不是themes里面的那个！) 里的theme属性，改为theme: particlex(值中间要留有空格)再hexo s,进入后主题更改，至此网站基础搭建成功！ 网站构建三件套：hexo clean //执行此命令后继续下一条 hexo g //生成博客目录hexo s //本地预览 而如何用github来对外展现自己的网站呢？在最开始的那个链接中详细指导了网站部署，很快就能学会！ 从零开始的博客搭建生活-001, Finished!","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","permalink":"https://sakb1n.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"算法","slug":"算法","permalink":"https://sakb1n.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"网站, 学习","slug":"网站-学习","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E7%AB%99-%E5%AD%A6%E4%B9%A0/"},{"name":"二次元","slug":"二次元","permalink":"https://sakb1n.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"生活","slug":"生活","permalink":"https://sakb1n.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"https://sakb1n.github.io/tags/%E7%AE%97%E6%B3%95/"}]}