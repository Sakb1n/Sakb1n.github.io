{"meta":{"title":"Bin's blog","subtitle":"","description":"小彬彬的博客","author":"Binbin","url":"https://sakb1n.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2023-10-01T13:00:23.000Z","updated":"2023-10-08T06:28:53.169Z","comments":true,"path":"about/index.html","permalink":"https://sakb1n.github.io/about/index.html","excerpt":"","text":"这是我的简介 The supreme happiness of life is the conviction that we are loved. 帐号 网站 帐号 QQ 648005280 GitHub Sakbin 洛谷 Sakbin Florr.io Noooooob"},{"title":"categories","date":"2023-10-07T04:57:20.000Z","updated":"2023-10-08T06:10:49.265Z","comments":true,"path":"categories/index.html","permalink":"https://sakb1n.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-10-07T04:57:42.000Z","updated":"2023-10-07T04:57:42.641Z","comments":true,"path":"tags/index.html","permalink":"https://sakb1n.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DOM学习","slug":"DOM学习","date":"2023-10-25T09:26:43.000Z","updated":"2023-10-25T09:29:08.663Z","comments":true,"path":"2023/10/25/DOM学习/","link":"","permalink":"https://sakb1n.github.io/2023/10/25/DOM%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"DOM基础DOM概述​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM(文档对象模型)是一个网络文档的编程接口，DOM将文档表示为节点和对象，因此编程语言可以和页面交互。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页是既可以在浏览器窗口中显示，又可以作为HTML源代码的文档，用DOM使它可以被操作。 const paragraphs = document.querySelectorAll(&quot;p&quot;); //paragraphs[0], paragraphs[1]... alert(paragraphs[0].nodeName); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM是使用多个API构建的，核心DOM定义了描述任何文档和其中对象的实体，其他API对其进行扩展。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM不是一门编程语言，而是用于建立网站的API。所以DOM不一定非要JavaScript才能实现，Python也行。 访问DOM​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用document或window对象来操作文档本身 //创造一个新的h1元素，向元素添加文本，再将其添加到文档的树中 &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;script&gt; // 当文档加载时，运行这段函数 window.onload = () =&gt; &#123; // 在空 HTML 页面中创建一系列元素 const heading = document.createElement(&quot;h1&quot;); const headingText = document.createTextNode(&quot;Big Head!&quot;); heading.appendChild(headingText); document.body.appendChild(heading); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 基本的数据类型​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常把DOM中的节点成为元素，但严格来说不是每个节点都是一个元素。 数据类型 描述 Document 当一个成员返回 document 对象时，这个对象就是rootdocument 对象本身。参见文章 DOM document 参考 Node 位于文档中的每个对象都是某种类型的节点。一个对象可以是一个元素节点，也可以是一个文本节点或属性节点 Element 基于Node，指的是一个元素或由DOM API成员返回的element类型的节点 NodeList 由元素组成的数组 Attr attribute 通过成员函数返回时，是一个为属性暴露出专门接口的对象引用 NamedNodeMap 和数组类似，但是条目是由名称或索引访问的 DOM中的核心接口 document.querySelector() document.querySelectorAll() document.createElement() Element.innerHTML Element.setAttribute() Element.getAttribute() EventTarget.addEventListener() HTMLElement.style Node.appendChild() window.onload window.scrollTo() 示例设置文本内容&lt;div class=&quot;container&quot;&gt; &lt;textarea class=&quot;story&quot;&gt;&lt;/textarea&gt; &lt;button id=&quot;set-text&quot; type=&quot;button&quot;&gt;设置文本内容&lt;/button&gt; &lt;button id=&quot;clear-text&quot; type=&quot;button&quot;&gt;清除文本内容&lt;/button&gt; &lt;/div&gt; .container &#123; display: flex; gap: 0.5rem; flex-direction: column; &#125; button &#123; width: 200px; &#125; const story = document.body.querySelector(&quot;.story&quot;); const setText = document.body.querySelector(&quot;#set-text&quot;); setText.addEventListener(&quot;click&quot;, () =&gt; &#123; story.textContent = &quot;It was a dark and stormy night...&quot;; &#125;); const clearText = document.body.querySelector(&quot;#clear-text&quot;); clearText.addEventListener(&quot;click&quot;, () =&gt; &#123; story.textContent = &quot;&quot;; &#125;); 添加子元素&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;parent&quot;&gt;父元素&lt;/div&gt; &lt;button id=&quot;add-child&quot; type=&quot;button&quot;&gt;添加子元素&lt;/button&gt; &lt;button id=&quot;remove-child&quot; type=&quot;button&quot;&gt;移除子元素&lt;/button&gt; &lt;/div&gt; .container &#123; display: flex; gap: 0.5rem; flex-direction: column; &#125; button &#123; width: 100px; &#125; div.parent &#123; border: 1px solid black; padding: 5px; width: 100px; height: 100px; &#125; div.child &#123; border: 1px solid red; margin: 10px; padding: 5px; width: 80px; height: 60px; box-sizing: border-box; &#125; const parent = document.body.querySelector(&quot;.parent&quot;); const addChild = document.body.querySelector(&quot;#add-child&quot;); addChild.addEventListener(&quot;click&quot;, () =&gt; &#123; // 只在文本节点“父节点”没有子节点时添加一个子节点 if (parent.childNodes.length &gt; 1) &#123; return; &#125; const child = document.createElement(&quot;div&quot;); child.classList.add(&quot;child&quot;); child.textContent = &quot;子节点&quot;; parent.appendChild(child); &#125;); const removeChild = document.body.querySelector(&quot;#remove-child&quot;); removeChild.addEventListener(&quot;click&quot;, () =&gt; &#123; const child = document.body.querySelector(&quot;.child&quot;); parent.removeChild(child); &#125;); 实例方法document.querySelector概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回文档中与指定选择器或选择器组匹配的第一个Element对象，找不到返回null。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配：使用深度优先先序遍历，从文档第一个元素开始按子节点的顺序遍历。 语法element = document.querySelector(selectors); /* selectors: 包含一个或多个要匹配的选择器的DOM字符串，必须为CSS选择器，否则引发SYNTAX_ERR异常。 SYNTAX_ERR:指定selectors的语法无效 CSS伪类不会返回任何元素 */ 示例//查找第一个匹配.myclass属性的元素 let e1 = document.querySelector(&quot;.myclass&quot;); //查找一个元素，该元素是被一个class = &quot;user-panel main&quot;属性的div包裹的name = &quot;login&quot;的input let e2 = document.querySelector(&quot;div.user-panel.main input[name = &#39;login&#39;]&quot;); document.querySelectorAll()概要 此方法基于ParentNode mixin的querySelectorAll()实现。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与指定的选择器组匹配的文档中的元素列表，返回NodeList(可以为空)。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦返回了NodeList，就可以像数组一样使用。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配：深度优先先序遍历文档节点。 语法querySelectorAll(selectors) /* selectors: 必须为CSS选择器的字符串，否则引发SyntaxError异常。 selectors中包含CSS伪元素会始终返回空值。 SyntaxError:指定的选择器不合法会抛出该错误。 */ 示例//获取所有p元素 let e = document.querySelectorAll(&quot;p&quot;); //获取所有class为note和alert的div元素 let e1 = document.querySelectorAll(&quot;div.note&quot;, &quot;div.alert&quot;); //获得一个p元素的列表，直接父元素是一个class = &quot;highlighted&quot;的div，位于ID为&quot;test&quot;的容器中 let container = document.querySelector(&quot;#test&quot;); let matches = container.querySelectorAll(&quot;div.highlighted &gt; p&quot;); //获得文档中属性名为“data-src”的iframe元素列表 let matches = document.querySelectorAll(&quot;iframe[data-stc]&quot;); //获得ID为userlist的列表中包含值为1的data-active属性的元素 let container = document.querySelector(&quot;#userlist&quot;); let matcher = container.querySelector(&quot;li[data-active = &#39;1&#39;]&quot;); document.createElement概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于创建一个由标签名称tagName指定的HTML元素，如果无法识别该tagName会生成一个未知HTML元素HTMLUnknownElement。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会返回新建的元素。 语法var element = document.createElement(tagName[, options]); /* tagName:指定要创建元素类型的字符串 */ 示例//新建一个新的div并且插入到ID为div1的元素前 document.body.onload = addElement; function addElement()&#123; //创造一个新的div元素 let newDiv = document.createElement(&quot;div&quot;); //添加内容 let newtext = document.createTextNode(&quot;Hello World!&quot;); //添加文本节点到这个div元素 newDiv.appendChlid(newtext); //获取div1 let curDiv = document.getElementById(&quot;div1&quot;); //添加到div1的元素前 document.body.insertBefore(newDiv, curDiv); &#125; element.innerHTML概要​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置或获取HTML语法表示的元素的后代。 语法const content = element.innerHTML; element.innerHTML = htmlString; /* 设置元素的innerHTML将会删除所有该元素的后代并以htmlString替代。 SyntaxError:HTML没有正确标记时，设置innerHTML将抛出语法错误。 NoModificationAllowedError:当父元素是Document时设置innerHTML将抛出语法错误。 */ 示例&lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;strong&gt;Log:&lt;/strong&gt;&lt;/div&gt; &lt;div class=&quot;log&quot;&gt;&lt;/div&gt; &lt;/div&gt; .box&#123; width: 600px; height: 300px; border: 1px solid black; padding: 2px 4px; overflow-y: scroll; overflow-x: auto; &#125; .log&#123; margin-top: 8px; font-family: monospace; &#125; let s = document.querySelector(&quot;.box&quot;); s.addEventListener(&quot;click&quot;, logEvent); s.addEventListener(&quot;mousedown&quot;, logEvent); s.addEventListener(&quot;mouseup&quot;, logEvent); s.addEventListener(&quot;mouseenter&quot;, logEvent); s.addEventListener(&quot;mouseleave&quot;, logEvent); function logEvent()&#123; let msg = &quot;Event &lt;strong&gt;&quot; + event.type + &quot;&lt;/strong&gt; at &lt;em&gt;&quot; + event.clientX + &quot;,&quot; + event.clientY + &quot;&lt;/em&gt;&quot;; log(msg); &#125; function log(msg)&#123; let a = document.querySelector(&quot;.log&quot;); let time = new Date(); let timestr = time.toLocaleTimeString(); a.innerHTML += timestr + &#39;:&#39; + msg + &quot;&lt;br /&gt;&quot;; &#125; log(&quot;Logging mouse events inside this container...&quot;);","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DOM,学习","slug":"DOM-学习","permalink":"https://sakb1n.github.io/tags/DOM-%E5%AD%A6%E4%B9%A0/"}]},{"title":"javaScript基础学习ver1.2","slug":"javascript基础学习ver1-0","date":"2023-10-19T04:38:49.000Z","updated":"2023-10-22T16:27:21.832Z","comments":true,"path":"2023/10/19/javascript基础学习ver1-0/","link":"","permalink":"https://sakb1n.github.io/2023/10/19/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0ver1-0/","excerpt":"2023.10.22: 更新了js对象内容(ver1.2)2023.10.21: 优化了排版，更新至ver1.12023.10.19：更新js ver1.0 JavaScript学习（MDN）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。","text":"2023.10.22: 更新了js对象内容(ver1.2)2023.10.21: 优化了排版，更新至ver1.12023.10.19：更新js ver1.0 JavaScript学习（MDN）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MDN上的javascript基础学习。 JavaScript第一步什么是javaScript？js简要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javascript是轻量级解释型语言，使用即时编译：会编译为二进制的格式。 js使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用内部js(在&lt;/head&gt;标签结束前插入&lt;script&gt;元素) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者直接外联（推荐): &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不建议内联（太乱了） 案例：使用addEventListener&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用querySelectorAll()函数选择按钮，使用addEventListener()为每个按钮分配一个处理器。 const buttons = document.querySelectorAll(&quot;button&quot;); for (let i = 0; i &lt; buttons.length; i++) &#123; buttons[i].addEventListener(&quot;click&quot;, createParagraph); &#125; 脚本调用策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML是按其出现在页面中的次序调用的，若js加载在欲操作的元素之前会发生错误。 1.内部： document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; // … &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：这个事件监听器能监听浏览器的DOMContentLoaded事件，标志着HTML文档体完全加载和解析，而在该代码需在事件触发后才进行，从而避免了错误。 2.外部： &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在&lt;script&gt;最后加入defer解决问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：defer告知浏览器在遇到&lt;script&gt;元素时继续下载HTML内容。 async 和 defer 的区别 使用async 脚本时不会阻塞页面渲染，而是直接下载然后运行。但是，一旦下载完成，脚本就会执行，从而阻止页面渲染。脚本的运行次序无法控制。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，async 是最理想的选择。 使用 defer 属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完毕之前，脚本不会运行，如果脚本依赖于 DOM 的存在（例如，脚本修改了页面上的一个或多个元素），这一点非常有用。 例: &lt;script async src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;js/script2.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;js/script3.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三者的调用顺序是不确定的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async 应该在有大量后台脚本需要加载，并且只想尽快加载到位的情况下使用 &lt;script defer src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;js/script2.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;js/script3.js&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这将会按顺序以此加载。 注释 // 注释 /* 注释 */ javaScript初体验&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉没什么要写的，很多都是在java中学过的了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章更多是在讲第一个程序，贴个链接：[JavaScript 初体验](JavaScript 初体验 - 学习 Web 开发 | MDN (mozilla.org)) 事件​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;侦听事件的结构称为事件监听器(Event Listener）, 响应事件触发而运行的代码块称为事件处理器(Event Handler)。 for of循环const fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;]; for (const fruit of fruits) &#123; console.log(fruit); &#125; 结果： &#39;apples&#39;,&#39;bananas&#39;,&#39;cherries&#39; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for of在这里干了什么：获取fruits的第一个元素赋值给fruit，运行代码块，再重复这两个操作一直到fruits的末尾。 变量验证变量存在​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用变量的方式验证变量是否存在： myName; myAge; //若没数值会返回undefined，若不存在会产生报错信息 初始化变量var myName = &quot;Chris&quot;; var myAge = 37; 更新变量myName = &quot;Bob&quot;; myAge = 40; var和let的区别 let 是在现代版本中的 JavaScript 创建的一个新的关键字，用于创建与 var 工作方式有些不同的变量，解决了过程中的问题。 D1: myName = &quot;Chris&quot;; function logName() &#123; console.log(myName); &#125; logName(); var myName; //变量提升 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let将不再允许该操作，并产生错误。 D2: var myName = &quot;Chris&quot;; var myName = &quot;Bob&quot;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但let不能多次声明相同名称的变量。 注：Internet Explorer 直到第 11 版才支持 let ! 变量类型 Number String Boolean Array Object 注：js的变量为动态类型 数字与操作符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof：返回数据类型 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**: 幂， 5 ** 5 &#x3D;3125 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x3D;&#x3D;&#x3D;：严格等于，要求数据类型相等 字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js的字符串用单双引号都可以,但不能在字符串中包含相同的引号。 转义字符let bigmouth = &#39;I\\&#39;ve got no right to take my place...&#39;; // 使用\\&#39;转义 数字与字符串​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与字符串相互转换，用Number() 和 toString()方法。 let myNum = Number(myString); //转换为数值 let myString = myNum.toString(); //转换为字符串 字符串方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length方法返回长度： browserType.length; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexOf方法查找子字符串： browserType.indexOf(&quot;zilla&quot;); //找不到返回-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice方法提取字符串： browserType.slice(0, 3); //范围不包含第二个参数 browserType.slice(3); //返回自第三个字符后的字符串 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toLowerCase、toUpperCase大小写转换： let radData = &quot;mY&quot;; radData.toLowerCase(); //“my” radData.toUpperCase(); //&quot;MY&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace进行替换： let browserType = mozilia; browserType.replace(&quot;moz&quot;, &quot;van&quot;); //vanilia 数组创建数组let shopping = [&quot;bread&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot;]; let random = [&quot;tree&quot;, 795, [0, 1, 2]]; //不一定同一种类 访问数组shopping[0] = &quot;tahini&quot;; shopping; // shopping will now return [ &quot;tahini&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot; ] 获取数组长度shopping.length; 字符串和数组的转换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split方法: let myData = &quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;; let myArray = myData.split(&quot;,&quot;); myArray; //Manchester London Liverpool Birmingham Leeds Carlisle&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join方法: let myNewString = myArray.join(&quot;,&quot;); myNewString; //Manchester,London,Liverpool,Birmingham,Leeds,Carlisle &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toString方法： myArray.toString(); 添加或删除数组项let myArray = [ &quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;, ]; myArray.push(&quot;Cardiff&quot;, &quot;Bradford&quot;); //末尾添加Cardiff、Bradford myArray.pop() //删除最后一个元素 myArray.unshift(&quot;Edinburgh&quot;) //首部添加Edinburgh myArray.shift() //删除第一个元素 JavaScript基础条件语句if (condition) &#123; &#125; else &#123; &#125; 例子: &lt;label for=&quot;weather&quot;&gt;选择今天的天气：&lt;/label&gt; &lt;select id=&quot;weather&quot;&gt; &lt;option value=&quot;&quot;&gt;--作出选择--&lt;/option&gt; &lt;option value=&quot;sunny&quot;&gt;晴天&lt;/option&gt; &lt;option value=&quot;rainy&quot;&gt;雨天&lt;/option&gt; &lt;option value=&quot;snowing&quot;&gt;雪天&lt;/option&gt; &lt;option value=&quot;overcast&quot;&gt;阴天&lt;/option&gt; &lt;/select&gt; &lt;p&gt;&lt;/p&gt; const select = document.querySelector(&quot;select&quot;); const para = document.querySelector(&quot;p&quot;); select.addEventListener(&quot;change&quot;, setWeather); function setWeather() &#123; const choice = select.value; if (choice === &quot;sunny&quot;) &#123; //进行判断 para.textContent = &quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;; &#125; else if (choice === &quot;rainy&quot;) &#123; para.textContent = &quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;; &#125; else if (choice === &quot;snowing&quot;) &#123; para.textContent = &quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;; &#125; else if (choice === &quot;overcast&quot;) &#123; para.textContent = &quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;; &#125; else &#123; para.textContent = &quot;&quot;; &#125; &#125; 循环语句​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同java，不再写笔记了。 函数自定义函数function myFunction() &#123; alert(&quot;hello world!&quot;); &#125; myFunction(); 匿名函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也称函数表达式，没有函数名的函数，经常与事件处理程序一起使用。 function() &#123; alert(&quot;hello world!&quot;); &#125; 例: var Button = document.querySelector(&quot;button&quot;); Button.onclick = function() &#123; alert(&quot;hello World!&quot;); &#125; 又如: var test = function () &#123; alert(&quot;hello world!&quot;); &#125;; test(); 事件介绍 事件是发生在你正在编程的系统中的事情——当事件发生时，系统产生（或“触发”）某种信号，并提供一种机制，当事件发生时，可以自动采取某种行动（即运行一些代码）。事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了对一个事件做出反应，你要给它附加一个事件处理器 实例：处理点击事件​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt;元素将在用户点击按钮时触发一个事件（定义了一个addEventListener函数） &lt;button&gt;改变颜色&lt;/button&gt; const btn = document.querySelector(&quot;button&quot;);//引用 function random(number) &#123; return Math.floor(Math.random() * (number + 1)); &#125; //click可以监听点击事件 btn.addEventListener(&quot;click&quot;, () =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅仅可以监听点击事件，addEventListener还可以: focus:聚焦（按Tab） blur:失焦(再次按下Tab) dblclick:双击按键 mouseover：鼠标指针在按钮上悬停 mouseout：鼠标指针移出按钮 移除监听器​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用removeEventListener()方法 btn.removeEventListener(&quot;click&quot;, changeBackground); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以传递AbortSignal到addEventListener()，在拥有AbortSignal的控制器上调用abort()来删除。 const controller = new AbortController(); btn.addEventListener(&quot;click&quot;,() =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;, &#123; signal: controller.signal &#125; // 向该处理器传递 AbortSignal ); 然后 controller.abort(); // 移除所有与该控制器相关的事件处理器 在单个事件上添加多个监听器myElement.addEventListener(&quot;click&quot;, functionA); myElement.addEventListener(&quot;click&quot;, functionB); 其他事件监听器机制​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件处理器属性：可以触发事件的对象通常有on+事件名称的属性，例如 onclick。 ​ 所以也可以这样写： btn.onclick = () =&gt; &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125;; ​ 或者btn.onclick = functionA; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件处理器属性不能添加多个处理程序。 ​ 内联事件处理器 &lt;button onclick=&quot;bgChange()&quot;&gt;按下我&lt;/button&gt; function bgChange() &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; document.body.style.backgroundColor = rndCol; &#125; 许多常见的服务器配置将禁止内联 JavaScript。 你永远不应该使用 HTML 事件处理器属性——那些已经过时了，使用它们是不好的做法。 事件对象​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在事件处理函数内部可能会看到一个固定指定名称的参数，例如 event、evt 或 e，这就是事件对象。 //e.target指的是按钮本身。事件对象 e 的 target 属性始终是事件刚刚发生的元素的引用 const btn = document.querySelector(&quot;button&quot;); function bgChange(e) &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; e.target.style.backgroundColor = rndCol; console.log(e); &#125; btn.addEventListener(&quot;click&quot;, bgChange); ​ 事件对象的额外属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keydown 事件在用户按下一个键时发生。它的事件对象是 KeyboardEvent，它是一个专门的 Event 对象，有一个 key 属性，告诉你哪个键被按下。 例： &lt;input id=&quot;textBox&quot; type=&quot;text&quot; /&gt; &lt;div id=&quot;output&quot;&gt;&lt;/div&gt; const textBox = document.querySelector(&quot;#textBox&quot;); const output = document.querySelector(&quot;#output&quot;); textBox.addEventListener(&quot;keydown&quot;, (event) =&gt; &#123; output.textContent = `You pressed &quot;$&#123;event.key&#125;&quot;.`; &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行后，每当你在输入框内敲下字母，将会显示你刚敲下的内容。 阻止默认行为&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下代码创造表单，要求填入名和姓，并有提交按钮。 &lt;form&gt; &lt;div&gt; &lt;label for=&quot;fname&quot;&gt;First name: &lt;/label&gt; &lt;input id=&quot;fname&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;lname&quot;&gt;Last name: &lt;/label&gt; &lt;input id=&quot;lname&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;p&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在submit事件中实行简单检查，如果文本字段为空，调用preventDefault()停止提交并报告错误信息，否则继续提交。 const form = document.querySelector(&quot;form&quot;); const fname = document.getElementById(&quot;fname&quot;); const lname = document.getElementById(&quot;lname&quot;); const para = document.querySelector(&quot;p&quot;); form.addEventListener(&quot;submit&quot;, (e) =&gt; &#123; if (fname.value === &quot;&quot; || lname.value === &quot;&quot;) &#123; e.preventDefault(); para.textContent = &quot;You need to fill in both names!&quot;; &#125; &#125;); 事件冒泡&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;button&gt;点我！&lt;/button&gt; &lt;/div&gt; &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt; &lt;/body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素上附加事件处理器，也会触发单击事件： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); container.addEventListener(&quot;click&quot;, handleClick); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父元素与按钮上同时附加事件处理器，都会触发： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); const button = document.querySelector(&quot;button&quot;); document.body.addEventListener(&quot;click&quot;, handleClick); container.addEventListener(&quot;click&quot;, handleClick); button.addEventListener(&quot;click&quot;, handleClick); /*Result: 你在BUTTON元素上进行了点击 你在DIV元素上进行了点击 你在BODY元素上进行了点击 */ 实例：视频播放器 单击显示”视频按钮“时，显示包含视频的盒子但不开始播放 单击视频时播放 单击盒子内视频以外的任何区域时隐藏盒子 &lt;button&gt;显示视频&lt;/button&gt; &lt;div class=&quot;hidden&quot;&gt; &lt;video&gt; &lt;source src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;p&gt; 你的浏览器不支持 HTML 视频，这里有视频的&lt;a href=&quot;rabbit320.mp4&quot;&gt;替代链接&lt;/a&gt;。 &lt;/p&gt; &lt;/video&gt; &lt;/div&gt; const btn = document.querySelector(&quot;button&quot;); const box = document.querySelector(&quot;div&quot;); const video = document.querySelector(&quot;video&quot;); btn.addEventListener(&quot;click&quot;, () =&gt; box.classList.remove(&quot;hidden&quot;)); video.addEventListener(&quot;click&quot;, () =&gt; video.play()); box.addEventListener(&quot;click&quot;, () =&gt; box.classList.add(&quot;hidden&quot;)); ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当点击按钮后，因为div包含着video，盒子和视频都会同时显示，当点击视频时，会同时运行两个事件处理器，所以视频播放但盒子又消失了。 使用stopPropagation()修复问题​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event对象有一个stopPropagation()函数，可以在当一个事件处理器调用时防止事件向其他元素传递。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将video的addEventListener修改即可解决问题: video.addEventListener(&quot;click&quot;, (event) =&gt; &#123; event.stopPropagation(); video.play(); &#125;); 事件捕获 先在最小嵌套元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件捕获默认禁用，需要在addEventListener()中的capture选项中启用 接事件冒泡中的代码： const output = document.querySelector(&quot;#output&quot;); function handleClick(e) &#123; output.textContent += `你在 $&#123;e.currentTarget.tagName&#125; 元素上进行了点击\\n`; &#125; const container = document.querySelector(&quot;#container&quot;); const button = document.querySelector(&quot;button&quot;); //设置事件捕获 document.body.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;); container.addEventListener(&quot;click&quot;, handleClick, &#123; capture: true &#125;); button.addEventListener(&quot;click&quot;, handleClick); /* Result: 你在BODY元素上进行了点击 你在DIV元素上进行了点击 你在BUTTON元素上进行了点击 */ 事件委托​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在父元素上设置监听器，让发生在它们身上的事件冒泡到父元素上。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户点击一个按钮时页面的区域设置成随机颜色 &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tile&quot;&gt;&lt;/div&gt; &lt;/div&gt; //设置区域尺寸 .tile &#123; height: 100px; width: 25%; float: left; &#125; function random(number) &#123; return Math.floor(Math.random() * number); &#125; function bgChange() &#123; const rndCol = `rgb($&#123;random(255)&#125;, $&#123;random(255)&#125;, $&#123;random(255)&#125;)`; return rndCol; &#125; const container = document.querySelector(&quot;#container&quot;); container.addEventListener(&quot;click&quot;, (event) =&gt;&#123; event.target.style.backgroundColor = bgChange(); &#125;); javaScript对象介绍java对象基础构造对象以及表示法/*构造一个空对象*/ const person = &#123;&#125;; /*用对象字面量创造对象*/ const person = &#123; name: [&quot;Bob&quot;, &quot;Smith&quot;], age: 32, bio() &#123; console.log(`$&#123;this.name[0]&#125; $&#123;this.name[1]&#125; 现在 $&#123;this.age&#125; 岁了。`); &#125;, introduceSelf() &#123; console.log(`你好！我是 $&#123;this.name[0]&#125;。`); &#125;, &#125;; /* 调用对象方法和属性 1.点表示法 */ person.name; person.name[0]; person.age; person.bio(); // &quot;Bob Smith 现在 32 岁了。&quot; person.introduceSelf(); // &quot;你好！我是 Bob。&quot; /* 2,括号表示法 */ person[&quot;age&quot;]; person[&quot;name&quot;][&quot;first&quot;]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多数情况下用点表示法，但某些情况下你必须用括号表示法。 /*当对象属性名称保存在变量中，只能用括号表示法*/ const person = &#123; name: [&quot;Bob&quot;, &quot;Smith&quot;]; age:32; &#125;; function logProperty(propertyName)&#123; console.log(person[propertyName]); &#125; logProperty(&quot;name&quot;); //[&quot;Bob&quot;, &quot;Smith&quot;] logProperty(&quot;age&quot;); // 32 子命令空间/*用一个对象来做另一个对象成员的值*/ const person = &#123; name:&#123; first:&quot;Bob&quot;, last:&quot;Smith&quot;, &#125; &#125;; //访问 person.name.first; person.name.last; 设置对象成员&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;括号表示法可以动态创建成员名字，而点表示法不行。 /*设置对象成员*/ person.age = 45; person[&quot;name&quot;][&quot;last&quot;] = &quot;Cratchit&quot;; /*创建对象成员*/ person[&quot;eyes&quot;] = &quot;hazel&quot;; person.farewell = function()&#123; console.log(&quot;再见！&quot;); &#125;; person[&quot;eyes&quot;]; person.farewell(); 构造函数/*创造person的构造函数*/ function Person(name)&#123; this.name = name; this.introduceSelf = function( console.log(`你好！我是$(this.name)。`); ); &#125; /*调用构造函数*/ const salva = new Person(&quot;Salva&quot;); salva.name; salva.introduceSelf(); // &quot;你好！我是 Salva。&quot; 对象原型原型链const myObject = &#123; city: &quot;Madrid&quot;, greet()&#123; console.log(`来自$(this.city)的问候`); &#125;, &#125;; myObject.greet(); //来自 Madrid 的问候 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用myObject.时,出现以下信息 __defineGetter__ __defineSetter__ __lookupGetter__ __lookupSetter__ __proto__ city constructor greet hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf //调用其中的toString myObject.toString(); //&quot;[object Object]&quot; javaScript中所有对象都有一个内置属性，称作原型，原型对象也会有自己的原型，逐渐构成了原型链，原型链终止于拥有null作为其原型的对象上。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当访问一个对象的属性时，如果在其本身找不到该属性，就会在原型中搜索，仍然找不到则继续搜索原型的原型，直到链的末端（返回undefined）。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype是最基础的原型，所有对象默认都拥有它， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的原型是null，故其位于原型链的终点。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个对象的原型不一定就是Object.prototype const myDate = new Date(); let object = myDate; do &#123; object = Object.getPrototypeOf(object); console.log(object); &#125; while (object); // Date.prototype // Object &#123; &#125; // null 属性遮蔽 如果在对象中定义属性，而在对象原型中也定义了一个同名属性会发生什么？ const myDate = new Date(1995, 11, 17); console.log(myDate.getYear()); // 95 myDate.getYear = function () &#123; console.log(&quot;别的东西！&quot;); &#125;; myDate.getYear(); // &#39;别的东西！&#39; /*调用 getYear时，会先在myDate中寻找。这叫做属性遮蔽 */ 设置原型/*方式一：使用Object.create()*/ const personPrototype = &#123; greet() &#123; console.log(&quot;hello!&quot;); &#125;, &#125;; //创造一个以personPrototype为原型的新对象 const carl = Object.create(personPrototype); //原型为对象提供了greet方法 carl.greet(); /*方式二：使用构造函数*/ //创造personPrototype对象，该对象具有方法greet。 const personPrototype = &#123; greet() &#123; console.log(`你好，我的名字是 $&#123;this.name&#125;！`); &#125;, &#125;; //创造Person的构造函数 function Person(name) &#123; this.name = name; &#125; //将personPrototype中的方法绑定到Person的prototype属性上 Object.assign(Person.prototype, personPrototype); // 或 // Person.prototype.greet = personPrototype.greet; //调用 const reuben = new Person(&quot;Reuben&quot;); reuben.greet(); // 你好，我的名字是 Reuben！ 自有属性​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接在对象中定义的属性，被称为自有属性。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用静态方法 Object.hasOwn()检查一个属性是否是自有属性。 const irma = new Person(&quot;Irma&quot;); console.log(Object.hasOwn(irma, &quot;name&quot;)); // true console.log(Object.hasOwn(irma, &quot;greet&quot;)); // false 面向对象编程基本概念​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java方面知识，不再赘述。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javaScript中的原型与对象很像java中的类与对象，但两者依旧有区别。 javaScript中的类基本使用//用class声明一个类 class Person&#123; name; //构造函数 constructor(name)&#123; this.name = name; &#125; introduceSelf()&#123; console.log(`Hi! I&#39;m $&#123;this.name&#125;`); &#125; &#125; //创建并使用 const giles = new Person(&quot;Giles&quot;); giles.introduceSelf(); // Hi! I&#39;m Giles 省略构造函数/*不需要初始化时，默认构造函数将自动生成*/ class Animal &#123; sleep() &#123; console.log(&quot;zzzzzzz&quot;); &#125; &#125; const spot = new Animal(); spot.sleep(); //&#39;zzzzzzz&#39; 继承class Professor extends Person&#123; teaches; constructor(name, teaches)&#123; super(name); this.teaches = teaches; &#125; introduceSelf() &#123; console.log( `My name is $&#123;this.name&#125;, and I will be your $&#123;this.teaches&#125; professor.`, )&#125;; grade(paper) &#123; const grade = Math.floor(Math.random() * (5 - 1) + 1); console.log(grade); &#125; &#125; //使用 const walsh = new Professor(&quot;Walsh&quot;, &quot;Psychology&quot;); walsh.introduceSelf(); // &#39;My name is Walsh, and I will be your Psychology professor&#39; walsh.grade(&quot;my paper&quot;); // some random grade 封装class Student extends Person &#123; //#year是私有数据属性,&#39;用#&#39;表示。 #year; constructor(name, year) &#123; super(name); this.#year = year; &#125; introduceSelf() &#123; console.log(`Hi! I&#39;m $&#123;this.name&#125;, and I&#39;m in year $&#123;this.#year&#125;.`); &#125; canStudyArchery() &#123; return this.#year &gt; 1; &#125; &#125; //在类的外部尝试访问#year将会出错 const summers = new Student(&quot;Summers&quot;, 2); summers.#year; // SyntaxError 私有方法//与私有属性一样 class Example &#123; somePublicMethod() &#123; this.#somePrivateMethod(); &#125; #somePrivateMethod() &#123; console.log(&quot;You called me?&quot;); &#125; &#125; const myExample = new Example(); myExample.somePublicMethod(); // &#39;You called me?&#39; myExample.#somePrivateMethod(); // SyntaxError 使用JSONJSON简介 javaScript对象表示法（JSON）是用于将结构化数据表示为 JavaScript 对象的标准格式，通常用于在网站上表示和传输数据。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON可以作为一个对象或者字符串存在，前者用于解读JSON中的数据，后者用于通过网络传输JSON数据。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串转换为原生对象称为反序列化，原生对象转换为字符串称为序列化。 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON存储在.json中。 ​ JSON结构​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON类似于对象字面量。 &#123; &quot;squadName&quot;: &quot;Super hero squad&quot;, &quot;homeTown&quot;: &quot;Metro City&quot;, &quot;formed&quot;: 2016, &quot;secretBase&quot;: &quot;Super tower&quot;, &quot;active&quot;: true, &quot;members&quot;: [ &#123; &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] &#125;, &#123; &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] &#125;, &#123; &quot;name&quot;: &quot;Eternal Flame&quot;, &quot;age&quot;: 1000000, &quot;secretIdentity&quot;: &quot;Unknown&quot;, &quot;powers&quot;: [ &quot;Immortality&quot;, &quot;Heat Immunity&quot;, &quot;Inferno&quot;, &quot;Teleportation&quot;, &quot;Interdimensional travel&quot; ] &#125; ] &#125; ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将字符串加载入js程序中，并解析到名叫superHeroes变量中，可以用该变量访问数据。 superHeroes.hometown; superHeroes[&quot;active&quot;]; //访问members数组的第二个元素，其中的powers数组的第三个元素 superHeroes[&quot;members&quot;][1][&quot;powers&quot;][2]; JSON数组​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组与JSON可以相互转换，比如这样写依然有效。 [ &#123; &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] &#125;, &#123; &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] &#125; ] //调用 [0][&quot;powers&quot;][0]; JSON注意事项 是纯数据格式，只有属性，没有方法。 要求在字符串和属性名称周围用双引号。 JSON文件很容易出错，可以用JSONLint验证JSON。 JSON中只有带引号的字符串可以用作属性。","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"笔记,学习,js","slug":"笔记-学习-js","permalink":"https://sakb1n.github.io/tags/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0-js/"}]},{"title":"sql学习ver1.0","slug":"sql学习ver1-0","date":"2023-10-16T13:06:44.000Z","updated":"2023-10-19T04:38:04.759Z","comments":true,"path":"2023/10/16/sql学习ver1-0/","link":"","permalink":"https://sakb1n.github.io/2023/10/16/sql%E5%AD%A6%E4%B9%A0ver1-0/","excerpt":"2023.10.19：文章周末更新，会把排版优化一下~2023.10.16：更新sql ver1.0 数据库概念操作者用SQL语言向数据库管理系统(DBMS)发出指令，系统在数据库(DB)里进行操作。","text":"2023.10.19：文章周末更新，会把排版优化一下~2023.10.16：更新sql ver1.0 数据库概念操作者用SQL语言向数据库管理系统(DBMS)发出指令，系统在数据库(DB)里进行操作。 数据库存储特点 数据放进表（按行存储），表放进数据库 数据库有多个表，每个表只有一个名字 表中的每一列（也称字段）类似于java中对象的属性，每一行类似于java中的对象 配置文件my.ini 文件位置：C:\\ProgramData\\MySQL\\MySQL Server 8.0 SQL启动与停止方式一：计算机 ——– 管理 ——-服务 方式二：命令行(管理员) net start/stop mysql端口 SQL登陆与退出方式一：MySQL Command Line Client登陆(仅限于root) 方式二：命令行(管理员) mysql [-h主机名 -P端口号] -u用户名 -p密码 (仅限本地可以省略) 退出：exit或ctrl+c SQL常见命令show databases; //查看数据库 use 库名; //打开指定库 show tables //查看表 desc 表名 //查看表结构 查看版本： select version(); mysql --version SQL语法规范 不区分大小写 用分号结尾 可以换行 单行注释#或– + 空格 多行注释&#x2F;* *&#x2F; 查询基础查询SELECT 列表 FROM 表名； 注意：1.查询的可以是字段、变量、表达式或函数； ​ 2.返回的是虚拟表格。 ​ 3.SELECT * 会返回所有字段。 ​ 4.如果查询的列与SQL关键字冲突时，用反引号(&#96;&#96;)包裹。 ​ 5.SELECT可以查询常量值（意义何在…） 去重直接在字段前加上DISTINCT MySQL里的+号没有连接符的作用，只有运算符的作用 若一方是字符型，会自动隐式转换为数值型，失败会当做0 一方为NULL，最终值也为NULL 若要拼接字段，使用CONCAT(str1, str2, …)，如果其中有NULL值最终也会变为NULL，使用ISNULL(字段，赋值) 来判断。 条件查询SELECT 列表 FROM 表名 WHERE 条件； 按条件表达式筛选（&gt; &lt; &#x3D; !&#x3D;或&lt;&gt; &gt;&#x3D; &lt;&#x3D;） 按逻辑表达式筛选（&amp; || ! and or not） 模糊查询（like between and in isnull） ESCAPE ‘ ‘ 指定转义字符 用IN模糊查询时不能用通配符。 条件等于NULL值时 不能用&#x3D;，用专门的IS NULL。 安全等于(&lt;&#x3D;&gt;) 可以判断NULL值。 排序查询SELECT 列表 FROM 表名 WHERE 条件 ORDER BY 排序列表 ASC|DESC； ORDER BY 一般是放在查询语句的最后。 常用函数LENGTH() 求长 CONCAT() 连接字段 UPPER() 大写化 LOWER() 小写化 SUBSTR(str1, index1, index2) 返回在str1 index1~index2 位置上的子字符串（索引从1开始） INSTR(str1, str2) 返回在str2中第一次出现str1的索引,未查到返回0 TRIM(str1, str2) 在str2的头和尾上去除str1，未填str1默认为空格 L(R)PAD(str1, str2，length) 用str1在str2的左(右)边填充直到length长度 REPLACE(str1, str2, str3) 将str1中的str2全部替换为str3 数学函数ROUND(x, y) //四舍五入,对x保留y位小数 CEIL(x) //向上取整 FLOOR(x) //向下取整 RTUNCATE(x, y) //截断，对y + 1位后的小数进行截断 MOD(x, y) //x对y取余 日期函数NOW() //返回当前系统日期+时间 CURDATE() //返回当前系统日期 CURTIME() //返回当前时间 YEAR(time)、MONTH(time)... //可以获取指定时间的年、月等...(MONTHNAME可获得英文月份) STR_TO_DATE() //将日期格式的字符转换成指定格式的日期 例：STR_TO_DATE(&#39;1998-3-2&#39;, &#39;%Y-%c-%D&#39;); DATE_FORMAT //将日期转换为字符 例：DATE_FORMAT(NOW(), &#39;%y年%m月%d日&#39;) 其他函数VERSION() //版本号 DATABASE() //查看当前库 USER() //查看当前用户 流程控制函数IF的使用： IF(exp1, exp2, exp3) 例： IF(10 &lt; 5, &#39;大&#39;， ‘小&#39;) CASE的使用： 1.CASE 要判断的字段或表达式 WHEN 常量1 THEN 要显示的值或语句; WHEN 常量2 THEN 要显示的值或语句; WHEN 常量3 THEN 要显示的值或语句; ... ELSE 要显示的值或语句； END 2.CASE WHEN 条件1 THEN 要显示的值或语句; WHEN 条件2 THEN 要显示的值或语句; WHEN 条件3 THEN 要显示的值或语句; ... ELSE 要显示的值或语句； END","categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习,mysql","slug":"学习-mysql","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0-mysql/"}]},{"title":"近期计划","slug":"近期计划","date":"2023-10-09T15:42:26.000Z","updated":"2023-10-25T06:38:40.351Z","comments":true,"path":"2023/10/09/近期计划/","link":"","permalink":"https://sakb1n.github.io/2023/10/09/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/","excerpt":"","text":"今年剩下的梦想： (难度从低到高) 买一张SSD 买一台显示器(在攒钱ing) 把sql和web学会(慢慢来吧) 拿到学校奖学金 进回声实验室(概率太低了，我觉得几乎不可能) 完成一项就会划掉一项，年末审视自己，能把前两项做好我觉得已经很满足了哦，至于后面的三项，能走到哪里就走到哪里吧（我终究是个普通人罢了）","categories":[],"tags":[]},{"title":"从零开始的博客搭建生活-003","slug":"从零开始的博客搭建生活-003","date":"2023-10-04T16:15:24.000Z","updated":"2023-10-07T04:54:05.213Z","comments":true,"path":"2023/10/05/从零开始的博客搭建生活-003/","link":"","permalink":"https://sakb1n.github.io/2023/10/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-003/","excerpt":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 今天写的是对博客各种功能的学习。预计这个系列在下一集就会完结www。","text":"前文指引： 从零开始的博客搭建生活-001 从零开始的博客搭建生活-002 今天写的是对博客各种功能的学习。预计这个系列在下一集就会完结www。 文章编写新建文章:hexo new 文件名 执行该命令后会在根目录的source_posts生成文章。 新建草稿:hexo new draft 文件名 执行后同上，会在_drafts下生成草稿，草稿不会被更新在博客中。 通过上面这两个命令，相信已经知道Hexo文章的生成了，而文章的撰写需要学会Markdown语法，这部分内容会放在Extra章节中。 模版在主目录的scaffolds文件夹中，存放有: ├── draft.md //草稿模板├── page.md //页面模板├── post.md //文章模板 打开post.md，可以看到: ---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 向其中加入”categories：”,这样就添加了分类标签，此后生成文章后，文章头部将自带categories字段。 网页基础设置主目录的_config.yml在主目录的_config.yml下，可以对网站基础进行设置。 title:标题 subtitle:子标题 description:主页介绍 keywords:关键字 author:作者 language:语言(建议改为zh-CN) timezone:时区 在#site底下可以改url，这是博客上线后的地址，会在分享时用到。url:http://example.com 主题的_config.yml在themes&#x2F;你的主题&#x2F;_config.yml下，也有一部分能设置的东西。 注：以主题作者的文档为准！","categories":[{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]},{"title":"从零开始的博客搭建生活-002","slug":"从零开始的博客搭建生活-002","date":"2023-10-03T15:31:04.000Z","updated":"2023-10-07T04:53:20.293Z","comments":true,"path":"2023/10/03/从零开始的博客搭建生活-002/","link":"","permalink":"https://sakb1n.github.io/2023/10/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-002/","excerpt":"前文指引：从零开始的博客搭建生活-001","text":"前文指引：从零开始的博客搭建生活-001 在第一篇文章中省略的正式上线流程，还是有点路程的（） 首先你要有一个github账户，easy。 github pages配置，easy。 git配置SSH公钥（第一次用git），小麻烦。 webstorm链接远程，easy。 用一下hexo g ，就这样我们网站就能正式上线了啊哈哈，但是通过github来访问难以记忆，第二篇要写的东西，就是域名。 有了域名，我们访问网站就会更加方便，只需记住名字就行，当然这是付费项目。 我在阿里云花钱买了个.top域名，.com一年23块我买不起，这个一年9块还是比较便宜的注意：购买域名需要实名认证，一般当天就通过了 接下来便是解析域名 (我耗费时间最长的地方，出现了各种莫名其妙的问题)：在域名解析里添加记录 参考 照搬了多个教程最后决定添加的2条记录,除了第一条的记录值要改为名字.github.io.（末尾一定要有这个点）外，其他都按照图上写。 最后在github pages上添加自己的域名即可。(在这里，依旧没有解决一个叫”DNS valid for primary”的问题，我翻了很多网站都没找到合适的解决方案，虽然不影响使用，但这个问题在未来会追加解决的！) 稍作一会，你便可以直接通过域名看到自己的网站咯wow 至于为什么没有买云服务器搭配呢，原因很简单，我没钱买ECS云服务器，一个计算型c5算上公网带宽一个月起码200元花销，真的很贵。~~（什么，你说新生计划？抱歉，已经被我拿去做mc服务器用掉了）~~~ 域名就写这么多，在下一篇中，将对个人博客进行进一步的美化！ 从零开始的博客搭建生活-002 Finished！","categories":[{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]},{"title":"从零开始的博客搭建生活-001","slug":"从零开始的博客搭建生活-001","date":"2023-10-01T15:40:23.000Z","updated":"2023-10-07T04:53:53.198Z","comments":true,"path":"2023/10/01/从零开始的博客搭建生活-001/","link":"","permalink":"https://sakb1n.github.io/2023/10/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%94%9F%E6%B4%BB-001/","excerpt":"这是一个预谋已久的计划准备搭建一个属于自己的个人博客，至于原因，就是闲来无事在上面写点文章。该系列会持续更新，这是第一篇，大概会更新4~5集，讲讲我这个新手从零开始的艰辛路程（）","text":"这是一个预谋已久的计划准备搭建一个属于自己的个人博客，至于原因，就是闲来无事在上面写点文章。该系列会持续更新，这是第一篇，大概会更新4~5集，讲讲我这个新手从零开始的艰辛路程（） 文章链接：https://blog.csdn.net/m0_51269961/article/details/122575897快速搭建个人博客——保姆级教程 首先下载所需要的软件(如果要收钱的话你懂得) Webstorm (或Vscode, 但JetBrains全家桶可以用校园账户免费领) Hexo (网站博客框架，也可以用WordPress) Node.js (Hexo前置) git (工具) 需要注意的是，Node.js的安装可能需要自行配置环境变量，否则可能根本就运行不了指令，网上有一大堆教程。 Hexo安装：在桌面上git bash就行npm install -g hexo-cli插件：npm install hexo-renderer-pug hexo-renderer-stylus --save 初始化：建议自己创建新文件夹，在文件夹里面右键git bashhexo init hexo的一些常用文件： public: 网站最终呈现形态 node_modules: 插件 _config.yml: 配置文件 scaffolds: 模版文件夹 themes: 存放主题文件 source: 存放用户资源 在webstorm中打开终端，输入：hexo s 提示打开网站就成功了，进入网站将是hexo最开始的形态（用ctrl+c来关闭本地网站） 但我们需要让网站更漂亮的话，该怎么办呢？答案就是使用官方提供的theme主题。 地址：https://hexo.io/themes/我所选用的是ParticleX 克隆：git clone https://github.com/theme-particlex/hexo-theme-particlex.git particlex --depth=1 会多出以下文件: 在hexo根目录下修改_config.yml(不是themes里面的那个！) 里的theme属性，改为theme: particlex(值中间要留有空格)再hexo s,进入后主题更改，至此网站基础搭建成功！ 网站构建三件套：hexo clean //执行此命令后继续下一条 hexo g //生成博客目录hexo s //本地预览 而如何用github来对外展现自己的网站呢？在最开始的那个链接中详细指导了网站部署，很快就能学会！ 从零开始的博客搭建生活-001, Finished!","categories":[{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://sakb1n.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"开发","slug":"开发","permalink":"https://sakb1n.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"DOM,学习","slug":"DOM-学习","permalink":"https://sakb1n.github.io/tags/DOM-%E5%AD%A6%E4%B9%A0/"},{"name":"笔记,学习,js","slug":"笔记-学习-js","permalink":"https://sakb1n.github.io/tags/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0-js/"},{"name":"学习,mysql","slug":"学习-mysql","permalink":"https://sakb1n.github.io/tags/%E5%AD%A6%E4%B9%A0-mysql/"},{"name":"网页,Hexo,博客","slug":"网页-Hexo-博客","permalink":"https://sakb1n.github.io/tags/%E7%BD%91%E9%A1%B5-Hexo-%E5%8D%9A%E5%AE%A2/"}]}